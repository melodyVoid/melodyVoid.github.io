<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[创建对象的几种方式的优缺点对比]]></title>
    <url>%2F2017%2F07%2F18%2F%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%E5%AF%B9%E6%AF%94%2F</url>
    <content type="text"><![CDATA[#1. 工厂模式 1234567891011function createObj(name, sex)&#123; var obj = new Object(); obj.name = name; obj.sex = sex; obj.sayName = function()&#123; alert(this.name); &#125; return obj;&#125;var person = createObj(&apos;Tom&apos;, &apos;man&apos;); 缺点： 无法确定对象的类型（因为都是Object）。 创建的多个对象之间没有关联。 #2. 构造函数 123456789function createObj(name, sex)&#123; this.name = name; this.sex = sex; this.sayName = function()&#123; alert(this.name); &#125;&#125; var person = new createObj(&apos;Tom&apos;, &apos;man&apos;); 缺点：①多个实例重复创建方法，无法共享。 ②多个实例都有sayName方法，但均不是同一个Function的实例。 #3. 原型方法 123456789function createObj()&#123;&#125;createObj.prototype.name = &apos;Tom&apos;;createObj.prototype.sex = &apos;man&apos;;createObj.prototype.sayName = function()&#123; alert(this.name);&#125;var person = new createObj(); 缺点： 无法传入参数，不能初始化属性值。 如果包含引用类型的值时，改变其中一个实例的值，则会在所有实例中体现。 #4. 组合式（构造函数+原型方法）推荐使用 123456789function createObj(name, sex)&#123; this.name = name; this.sex = sex;&#125;createObj.prototype.sayName = function()&#123; alert(this.name);&#125; var person = new createObj(&apos;Tom&apos;, &apos;man&apos;); 优点： 构造函数共享实例属性，原型共享方法和想要共享的属性。可传递参数，初始化属性值。 #5. 动态原型方法 1234567891011function createObj(name, sex)&#123; this.name = name; this.sex = sex; if(typeof this.sayName != &apos;function&apos;)&#123; createObj.prototype.sayName = function()&#123; alert(this.name); &#125; &#125;&#125;var person = new createObj(&apos;Tom&apos;, &apos;man&apos;); 说明： if语句中只会调用一次，就是在碰到第一个实例调用方法时会执。此后所有实例都会共享该方法。在动态原型方法下，不能使用对象字面量重写原型。 #6.寄生构造函数 ​ 寄生构造函数,其实就是工厂模式+构造函数模式,这种模式比较通用,但不能确定对象关系,所以,在可以使用之前所说的模式时,不建议使用此模式 ​ ​ 在什么情况下使用寄生构造函数比较合适呢?假设要创建一个具有额外方法的引用类型,例如直接String.prototype.addstring,可以通过寄生构造的方式来添加. 123456789function myString(string)&#123; var str = new String(string); str.addstring = function () &#123; return this + &quot;,被添加了&quot;; &#125;; return str;&#125;var box = new myString(&quot;lee&quot;);alert(box.addstring()); #7.稳妥构造函数 在一些安全环境中,比如禁止使用this和new,这里的this是构造函数里不使用this,这里的new 是在外部实例化构造函数时不使用new,这种创建方式叫做稳妥构造函数. 123456789function A(name,age)&#123; var obj = new Object(); obj.showName = function () &#123; return name; &#125;; return obj;&#125;var a = A(&quot;lee&quot;,100);alert(a.showName()); ​]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
      </tags>
  </entry>
</search>