<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[英语跟读计划0731]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0731.html</url>
    <content type="text"><![CDATA[必备句型​ Each of us has our own understanding of what love is. 我们每个人都对爱情有着不同的理解 Love is mysterious. 爱很神秘 ​ 场景对话​ A: What do people mean when they say they love someone? B: Each of us has our own understanding of what love is. A: Do you believe in love? B: Love is mysterious, but I do believe in it. ​ 参考译文​ A: 当人们说他们爱某人时，他们是怎么想的呢？ B: 我们每个人都对爱情有着不同的理解。 A: 你相信爱情吗？ B: 爱是很神秘，但是我真的相信它。 ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gulp学习笔记]]></title>
    <url>%2Fgulp%2Fgulp-learning-notes.html</url>
    <content type="text"><![CDATA[gulp是什么我们来看官网给出的解释： Automate and enhance your workflow 翻译过来就是：用自动化构建工具增强你的工作流程！ gulp是前端开发过程中对代码进行构建的工具，是自动化项目的构建利器；它不仅能对网站资源进行优化，而且在开发过程中很多重复的任务能够使用正确的工具自动完成；使用它，我们不仅可以很愉快的编写代码，而且大大提高我们的工作效率。 gulp能用来做什么 搭建web服务器 使用预处理器Sass，Less 压缩优化，可以压缩HTML、css、JavaScript、 图片 自动将更新变化的代码实时显示在浏览器 前端测试 …… gulp有极丰富的插件来帮助我们实现各种功能 gulp插件地址：http://gulpjs.com/plugins 安装gulp前提假设我们已经安装了node，并且对npm也了解 全局安装gulp全局安装gulp目的是为了通过它执行gulp任务 1$ npm install gulp -g 查看是否正确安装，我们在终端输入gulp -v 123$ gulp -v[10:26:05] CLI version 3.9.1[10:26:05] Local version 3.9.1 出现版本号，说明正确安装 新建package.json文件首先我们先新建一个项目文件夹 1$ mkdir Gulp 然后进入项目文件夹 1$ cd Gulp 创建一个package.json 1$ npm init -y 在项目目录里局部安装gulp 1$ npm install gulp --save-dev 创建gulpfile.js在根目录下面创建gulpfile.js文件，此文件为配置文件 自定义任务gulpfile.js 123456const gulp = require("gulp");//定义一个任务gulp.task("hello",()=&gt;&#123; console.log("Hello World");&#125;) 然后在命令行执行gulp任务 12345$ gulp hello[11:51:14] Using gulpfile ~/WebstormProjects/Gulp/gulpfile.js[11:51:14] Starting 'hello'...Hello World[11:51:14] Finished 'hello' after 392 μs 我们会看到打印出了”Hello World” 默认任务gulpfile.js 1234567const gulp = require("gulp");gulp.task("hello",()=&gt;&#123; console.log("Hello World")&#125;);//第一个参数是"default",第二个参数是一个数组，里面存放的是自定义任务名gulp.task("default",["hello"]); 这样我们就可以直接gulp了 1234567$ gulp[12:21:34] Using gulpfile ~/WebstormProjects/Gulp/gulpfile.js[12:21:34] Starting 'hello'...Hello World[12:21:34] Finished 'hello' after 171 μs[12:21:34] Starting 'default'...[12:21:34] Finished 'default' after 43 μs Basic读取想要处理的文件，然后把处理好的文件放到指定的地方 gulp.src()gulp.src()方法可以帮我们找到想要处理的文件 .pipe()然后通过.pipe()来处理这些找出来的文件，pipe就是一个管道，每一个管道里面我们都可以指定它的功能来处理这个文件 .pipe(gulp.dest())最后我们再使用.pipe(gulp.dest())方法，去把处理好的文件放到指定的地方。 dest is short for destination(目的地，目标位置) Copy目录结构 12|--index.html|--gulpfile.js gulpfile.js 123456const gulp = require("gulp");gulp.task("copy",()=&gt;&#123; return gulp.src("index.html") //注意：这里写"./index.html"和"index.html"效果一样 .pipe(gulp.dest("dist"))&#125;); 然后在命令行执行gulp copy 1234$ gulp copy[12:42:06] Using gulpfile ~/WebstormProjects/Gulp/gulpfile.js[12:42:06] Starting 'copy'...[12:42:06] Finished 'copy' after 16 ms 然后目录结构就变了 1234|--dist |--index.html|--index.html|--gulpfile.js glob目录结构 123456789101112|--dist |--index.html|--images |--icon |--01.png |--02.png |--03.png |--01.jpg |--02.jpg |--03.png|--index.html|--gulpfile.js 下面我们要做的就是把jpg图片复制到dist目录下的images文件夹里 gulpfile.js 123456const gulp = require("gulp");gulp.task("images",()=&gt;&#123; return gulp.src("images/*.jpg") //只匹配images目录下的jpg文件 .pipe(gulp.dest("dist/images"))&#125;); 执行gulp images 1234$ gulp images[13:07:12] Using gulpfile ~/WebstormProjects/Gulp/gulpfile.js[13:07:12] Starting 'images'...[13:07:12] Finished 'images' after 39 ms 然后我们观察目录结构变化 123456789101112131415|--dist |--index.html |--images |--01.jpg |--02.jpg|--images |--icon |--01.png |--02.png |--03.png |--01.jpg |--02.jpg |--03.png|--index.html|--gulpfile.js 那么怎么才能把png和jpg都复制过来呢？ gulpfile.js 1234567 const gulp = require("gulp"); gulp.task("images",()=&gt;&#123;- return gulp.src("images/*.jpg") //只匹配images目录下的jpg文件+ return gulp.src("images/*.&#123;jpg,png&#125;") //匹配image目录下的jpg和png文件 .pipe(gulp.dest("dist/images")) &#125;); 执行gulp images后，dist文件夹目录结构如下 123456|--dist |--index.html |--images |--01.jpg |--02.jpg |--03.png 我们再来看，修改一下 12345678910gulpfile.js里面匹配是*.*gulp.src(&quot;images/*.*&quot;)那么dist目录结构|--dist |--index.html |--images |--01.jpg |--02.jpg |--03.png 1234567891011gulpfile.js里面匹配是*gulp.src(&quot;images/*&quot;)那么dist目录结构|--dist |--index.html |--images |--icon |--01.jpg |--02.jpg |--03.png 如果想要深层次匹配 1234567891011121314gulpfile.js里面匹配是**/*gulp.src(&quot;images/**/*&quot;)那么dist目录结构|--dist |--index.html |--images |--icon |--01.png |--02.png |--03.png |--01.jpg |--02.jpg |--03.png 怎么样，images里的文件全都匹配过来了 多个glob目录结构 12345678|--dist |--index.html|--json |--01.json|--xml |--01.xmlindex.htmlgulpfile.js gulpfile.js 123456const gulp = require("gulp");gulp.task("data",()=&gt;&#123; return gulp.src(["json/*.json","xml/*.xml"]) //用数组的形式匹配多个glob .pipe(gulp.dest("dist/data"))&#125;); 执行gulp data dist的目录结构变为 12345|--dist |--index.html |--data |--01.json |--01.xml negate不想包含的文件用!排除 例如json文件夹里 123|--json |--01.json |--negate-01.json 我们不想要negate开头的json文件 gulpfile.js 123456const gulp = require("gulp");gulp.task("data",()=&gt;&#123; return gulp.src(["json/*.json","xml/*.xml","!json/negate-*.json"]) //再多加一个排除的glob，注意前面用！号 .pipe(gulp.dest("dist/data"))&#125;); 执行完过后，就不会复制negate-01.json这个文件了 任务依赖如果一个任务的建立是依赖于其他任务，就需要用到以下的写法 gulpfile.js 1234567891011121314151617181920const gulp = require("gulp");//复制index.htmlgulp.task("copy",()=&gt;&#123; return gulp.src("index.html") .pipe(gulp.dest("dist"))&#125;);//复制图片gulp.task("images",()=&gt;&#123; return gulp.src("images/**/*") .pipe(gulp.dest("dist/images"))&#125;);//复制数据gulp.task("data",()=&gt;&#123; return gulp.src(["json/*.json","xml/*.xml"]) .pipe(gulp.dest("dist/data"))&#125;);//build任务是依赖于前三个任务的，那么我们第二个参数，传入数组，数组里存放的是它所依赖的任务名gulp.task("build",["copy","images","data"],()=&gt;&#123; console.log("编译完成");&#125;) 然后执行gulp build 1234567891011$ gulp build[13:48:20] Using gulpfile ~/WebstormProjects/Gulp/gulpfile.js[13:48:20] Starting 'copy'...[13:48:20] Starting 'images'...[13:48:20] Starting 'data'...[13:48:20] Finished 'copy' after 53 ms[13:48:20] Finished 'data' after 43 ms[13:48:20] Finished 'images' after 52 ms[13:48:20] Starting 'build'...编译完成[13:48:20] Finished 'build' after 154 μs 我们可以看出，copy,images和data三个任务是同时进行的，然后再执行build任务 watch用gulp.watch()方法可以监视文件的变化 gulpfile.js 12345678910111213141516171819202122232425const gulp = require("gulp");//复制index.htmlgulp.task("copy",()=&gt;&#123; return gulp.src("index.html") .pipe(gulp.dest("dist"))&#125;);//复制图片gulp.task("images",()=&gt;&#123; return gulp.src("images/**/*") .pipe(gulp.dest("dist/images"))&#125;);//复制数据gulp.task("data",()=&gt;&#123; return gulp.src(["json/*.json","xml/*.xml"]) .pipe(gulp.dest("dist/data"))&#125;);//监视文件gulp.task("watch",()=&gt;&#123; //当index.html文件变化时，就执行copy任务 gulp.watch("index.html",["copy"]); //当图片变化时，就执行images任务 gulp.watch("images/**/*.&#123;png,jpg&#125;",["images"]); //当数据发生变化时，就执行data任务 gulp.watch(["json/*.json","xml/*.xml","!json/negate-*.json"],["data"]);&#125;); 执行gulp watch就可以监视文件的变化 plugingulp提供了很好的接口，它本身并不会去做太多的事情，除了去可以读取文件，监视文件的变化，可以把文件放到指定的位置，我们可以插件来扩展gulp的功能，这些插件可以取执行特定的任务，比如说： 编译Sass，编译Less 合并文件 压缩、混淆文件 重命名 优化图像的尺寸 创建一个本地的开发服务器 … gulp插件地址：[http://gulpjs.com/plugins 使用方法都类似 先找到所需的插件，然后npm install 插件名 --save-dev安装 然后在gulpfile.js中引入插件const minifycss = require(&quot;gulp-minify-css&quot;) 查看插件文档，看使用方法 gulp-sass安装gulp-sass1$ npm install gulp-sass --save-dev 使用gulp-sass在配置文件gulpfile.js中引入这个插件 12345678const gulp = require("gulp");const sass = require("gulp-sass");gulp.task("sass",()=&gt;&#123; return gulp.src("style/**/*.scss") .pipe(sass()) .pipe(gulp.dest("dist/css"))&#125;); 然后执行gulp sass 呃，我们遇到个错误 1Node Sass does not yet support your current environment: OS X 64-bit with Unsupported runtime (57) 在Stack Overflow上查了一下，说让我们运行一下npm rebuild node-sass 于是我们执行npm rebuild node-sass 然后再执行gulp sass 还是不行，于是我们在https://github.com/sass/node-sass/releases/tag/v3.13.1里看到了 想起来我装的是node的最新版，输入node -v 12$ node -vv8.2.1 也罢，那就等着它支持到8.x了吧。 于是，我们假装成功了（不要脸.jpg) 然后我们就能看见在dist文件夹下有一个css文件夹，里面有style.css文件 gulp-less安装gulp-less1$ npm install gulp-less --save-dev 使用gulp-less在配置文件gulpfile.js中引入这个插件 12345678const gulp = require("gulp");const less = require("gulp-less");gulp.task("less",()=&gt;&#123; return gulp.src("style/**/*.less") .pipe(less()) .pipe(gulp.dest("dist/css"))&#125;); 然后执行gulp less 1234$ gulp less[17:49:26] Using gulpfile ~/WebstormProjects/Gulp/gulpfile.js[17:49:26] Starting 'less'...[17:49:26] Finished 'less' after 72 ms 会在dist下面生成 123|--dist |--css |--style.css gulp-connect安装gulp-connect1$ npm install gulp-connect --save-dev 使用gulp-connect将gulp-connect模块导入 123456789const gulp = require("gulp");const connect = require("gulp-connect");gulp.task("server",()=&gt;&#123; connect.server(&#123; //在这个配置对象里可以配置端口，根目录等相关信息 root:"dist" &#125;)&#125;); 然后执行gulp server，我们会看到如下信息 12345$ gulp server[17:47:54] Using gulpfile ~/WebstormProjects/Gulp/gulpfile.js[17:47:54] Starting 'server'...[17:47:54] Finished 'server' after 51 ms[17:47:54] Server started http://localhost:8080 告诉我们在http://localhost:8080就可以查看网页了 reload当某些文件变化以后，能实时地刷新页面，这样就不用每次修改之后，再手动地刷新页面来查看变化。 打开gulpfile.js,找到创建服务器的任务，把livereload的值设置为true 1234567891011121314151617181920212223242526272829303132333435const gulp = require("gulp");const connect = require("gulp-connect");gulp.task("copy",()=&gt;&#123; return gulp.src("index.html") .pipe(gulp.dest("dist")) //2.文件复制过后执行reload方法 .pipe(connect.reload())&#125;);gulp.task("images",()=&gt;&#123; return gulp.src("images/**/*") .pipe(gulp.dest("dist/images"))&#125;);gulp.task("data",()=&gt;&#123; return gulp.src(["json/*.json","xml/*.xml"]) .pipe(gulp.dest("dist/data"))&#125;);gulp.task("watch",()=&gt;&#123; gulp.watch("index.html",["copy"]); gulp.watch("images/**/*.&#123;png,jpg&#125;",["images"]); gulp.watch(["json/*.json","xml/*.xml","!json/negate-*.json"],["data"]);&#125;);gulp.task("server",()=&gt;&#123; connect.server(&#123; root:"dist", //1.将livereload设置为true livereload: true &#125;)&#125;);//3.设置默认任务，依赖于server和watchgulp.task("default", ["server","watch"]); 执行顺序是 index.html文件发生变化 触发watch任务 watch任务又触发copy任务 将更改后的index.html拷贝到dist文件夹中 reload gulp-concat使用gulp-concat这个插件我们可以使几个文件合并到一块儿 安装插件1$ npm install gulp-concat --save-dev 使用gulp-concat123456789const gulp = require("gulp");//1.引入gulp-concatconst concat = require("gulp-concat");gulp.task("scripts",()=&gt;&#123; return gulp.src("javascript/**/*.js") //2.找到需要合并的js文件 .pipe(concat("index.js")) //3.通过pipe流入concat()方法，concat方法的参数是合并后的名字 .pipe(gulp.dest("dist/js")) //4.流入指定的文件夹&#125;); 合并后的dist目录 123|--dist |--js |--index.js gulp-uglify把几个js文件合并到一块儿，接下来我们可以再压缩混淆一下，完成这个动作我们可以使用gulp-uglify这个插件 安装插件1$ npm install gulp-uglify --save-dev 使用插件123456789101112const gulp = require("gulp");const concat = require("gulp-concat");//1.引入gulp-uglifyconst uglify = require("gulp-uglify");gulp.task("scripts",()=&gt;&#123; return gulp.src("javascript/**/*.js") .pipe(concat("index.js")) //2.合并之后压缩混淆 .pipe(uglify()) .pipe(gulp.dest("dist/js"))&#125;); 然后执行gulp scripts就可以压缩混淆了 注意： 若出现一下种错误，说明js代码有问题 1234events.js:182 throw er; // Unhandled &apos;error&apos; event ^GulpUglifyError: unable to minify JavaScript rename在把处理好的文件存储到指定的位置之前，我们可以重命名一下它，这里使用gulp-rename这个插件 安装插件1$ npm install gulp-rename --save-dev 使用插件12345678910111213const gulp = require("gulp");const concat = require("gulp-concat");const uglify = require("gulp-uglify");const rename = require("gulp-rename");gulp.task("scripts",()=&gt;&#123; return gulp.src("javascript/**/*.js") .pipe(concat("index.js")) .pipe(gulp.dest("dist/js")) .pipe(uglify()) .pipe(rename("index.min.js")) .pipe(gulp.dest("dist/js"))&#125;); 这个就不一一解释了 gulp-minify-css压缩css使用gulp-minify-css 安装插件1$ npm install gulp-minify-css --save-dev 使用插件 1234567891011121314const gulp = require("gulp");const less = require("gulp-less");const connect = require("gulp-connect");const concat = require("gulp-concat");const uglify = require("gulp-uglify");const rename = require("gulp-rename");const minifycss = require("gulp-minify-css");gulp.task("less",()=&gt;&#123; return gulp.src("style/**/*.less") .pipe(less()) .pipe(minifycss()) //如果愿意，在这里也可以压缩完重命名什么的 .pipe(gulp.dest("dist/css"))&#125;); 执行gulp less就可以压缩css代码了 gulp-imagemingulp-imagemin可以帮我们优化图片的尺寸，在保证不改变图像质量的情况下可以让图像的体积变得更小一些，下面我们先去安装一下这个插件 安装插件1$ npm install gulp-imagemin --save-dev 使用插件12345678const gulp = require("gulp");const imagemin = require("gulp-imagemin");gulp.task("images",()=&gt;&#123; return gulp.src("images/**/*") .pipe(imagemin()) .pipe(gulp.dest("dist/images"))&#125;); 然后执行gulp images就可以执行了。 本文结束，感谢阅读。 本文作者：melody0z 本文链接：https://melodyvoid/gulp/gulp-learning-notes.html 欢迎转载，转载请注明文本链接]]></content>
      <categories>
        <category>gulp</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>前端自动化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node学习笔记03]]></title>
    <url>%2FNode%2Fnode-learning-notes-03.html</url>
    <content type="text"><![CDATA[缓冲区处理（二进制数据）什么是缓冲区 缓冲区就是内存中操作数据的容器 只是数据容器而已 通过缓冲区可以很方便的操作二进制数据 而且在大文件操作时必须有缓冲区 为什么要有缓冲区 JavaScript是比较擅长处理字符串，但是早期的应用场景主要用于处理HTML文档，不会有太大篇幅的数据处理，也不会接触到二进制的数据。 而在Node中操作数据、网络通信是没办法完全以字符串的方式操作的 所以在Node中引入了一个二进制的缓冲区的实现：Buffer 创建缓冲区 创建长度为4个字节的缓冲区 1let buffer = new Buffer(4) 通过指定数组内容的方式创建 1let buffer = new Buffer([00,01]) 通过指定编码的方式创建 1let buffer = new Buffer("hello","utf8"); Node默认支持的编码Buffers和JavaScript字符串对象之间转换时需要一个明确的编码方法。下面是字符串的不同编码。 “ASCII” —7位的ASCII数据，这种编码方式非常快，它会移除最高位内容 “UTF8” — 多字节编码Unicode字符。大部分网页和文档使用这类编码方式。 “UTF16LE” — 2个或4个字节，Little Endian（LE）编码Unicode字符。编码范围（U+10000到U+10FFFF)。 “UCS2” — “UTF16LE”的子集。 “base64” — Base64字符编码 “binary” — 仅使用每个字符的头8位将原始的二进制信息进行编码。在需使用Buffer的情况下，应该尽量避免使用这个已经过时的编码方式，这个编码方式将会在未来某个版本中弃用。 “hex” — 每个字节都采用2进制编码。 文件流什么是流？ 文件流、网络流 任何数据的最根本 表现形式都是二进制的 文件流 文件流就是以面向对象的概念对文件数据进行的抽象 文件流定义了一些对文件数据的操作方式 以文件流的方式来拷贝文件1234567891011121314151617181920212223//以文件流的方式复制const fs = require("fs");const path = require("path");//创建读取流let streamReader = fs.createReadStream("./github.css");//创建写入流let streamWriter = fs.createWriteStream("./markdown.css");fs.stat("./github.css",(err,stats) =&gt; &#123; if(stats) &#123; let readTotal = 0; streamReader.on("data",(chunk)=&gt;&#123; streamWriter.write(chunk,(err) =&gt; &#123; console.log("写入进度：" + ((readTotal += chunk.length) / stats.size * 100) + "%"); &#125;) &#125;); streamReader.on("end",()=&gt;&#123; console.log("复制完毕") &#125;) &#125;&#125;); 当然我们还可以用pipe方法 12345678//用pipe的方式复制文件const fs =require("fs");const path = require("path");let streamReader = fs.createReadStream("./github.css");let streamWriter = fs.createWriteStream("./github1.css");streamReader.pipe(streamWriter); 是不是清爽了好多 网络操作相关模块 url：用于解析URL格式的模块 querystring：用于操作类似k1=v1&amp;k2=v2的查询字符串 http：用于创建http服务器或http客户端 URL解析模块 将一个URL字符串解析为一个URL对象 1url.parse(urlStr[,parseQueryString][,slashesDenoteHost]) 将一个URL对象格式化为字符串的形式 1url.format(urlObj) 用于组合URL成员为完整的URL字符串 1url.resolve(from,to) 查询字符串模块（querystring） querystring.escape querystring.parse(str[, sep][, eq][, options]) querystring.stringify(obj[, sep][, eq][, options]) querystring.unescape ​ 本文结束，感谢阅读。 本文作者：melody0z 本文链接：https://melodyvoid/Node/node-learning-notes-03.html 欢迎转载，转载请注明文本链接]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0730]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0730.html</url>
    <content type="text"><![CDATA[必备句型​ We are close friend. 我们是很亲密的朋友 Suspicion is the poison fo true friendship 猜疑是真诚友谊的一副毒剂 ​ 场景对话​ A: It seems that you and Alex are good friends. B: Well,yes. We are close friends, but I don’t really trust him. A: You know,suspicon is the posion of true friendship. ​ 参考译文​ A: 看起来你和Alex非常好。 B: 是的呢，我们是很亲密的朋友，但是我并不是真正信任她。 A: 你要知道，猜疑是真诚友谊的一副毒剂。 ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新概念计划]]></title>
    <url>%2FEassy%2Fnew-concept-plan.html</url>
    <content type="text"><![CDATA[写在前面好久没有写过随笔了，人每当开始树立一个新的目标或是决定开始一项新的任务时总是会异常兴奋，甚至是想用文字来记录下来。下面说说我此篇文章的意义。 ​ 今天是2017年7月30日，我在网上下载了新概念英语的全套录音，然后在淘宝上淘了一套四本新概念英语的旧书(ps:买旧书真的是超值，4本总共才40元，而且买回来基本也是新的）。8月是一个新的开始，而在这新的开始我也将开始我的计划，姑且叫做新概念计划。计划内容大概是用两年时间背完2、3、4册，乍一看两年时间挺长，其实可以说很短，因为我并不是全日制地在学，在背，在自己空余时间用两年时间完成3本书的背诵，任务其实还是挺艰巨的。目标就是把英语口语练好。我希望自己不是三分钟热度，希望自己可以坚持下来，两年后我会回来打卡，到时会写一篇文章做一次思想报告，来汇报新概念计划的完成情况，以及我自己的改变。 关于坚持说到坚持，我其实有很多想跟大家分享的，请大家回想一下自己坚持时间最长的一件有意义的事情是什么，我曾经这样问过我自己，但是我的答案是：Nothing。现在想想还真有点儿可悲，我放弃过很多东西，其实说到底还是自己没有坚持去做。 很多东西放下很容易，但要再次拾起却很难 自己大学毕业到现在一直坚持下来的总共也就四件事： 学编程 学英语 读书 健身 在这个浮躁的世界里，慢就是快 我为什么这么说？我看过太多人不想经过时间的磨练而速成一件事情的，事实告诉你：不可能！“我零基础，在学习JavaScript，两个月能学会吗？” “我报了个培训班，培训四个月，出来后就可以拿10k的工资吗”不知各位看到诸如此类的问题怎么看，反正我是非常反感。我从去年9月开始学习前端，到现在基本上快一年了。我说下我自己的体会，时间的沉淀真的很重要，不要觉得自己一次可以吸收那么多，我每一次看书都有新的体会。当初读Head First系列的从书，很多是看不懂的，一本书读下来能理解吸收50%都是很不错的，到后面随着你接触的越来越多，好多东西你会觉得“哦，原来是这个样子！”那种豁然开朗的心情是非常愉悦的。等等，好像要跑题，说起前端的学习体会，真是一时半会儿说不完的（捂脸.jpg)，然而这次的主题是英语。 咱们继续说坚持，健身，坚持了一年多了，真的有很大的改观，身体变强壮了，胸肌和二头比以前更加结实，这种变化是坚持的结果，绝不是我这个礼拜心血来潮了，练上个三五天就能成的样子。我在健身房发现一个有趣的现象，就是陌生的面孔越来越多，最开始和我一起办卡的那些人，慢慢的都不见踪影了，所能坚持下来一年的超不过10个人（认真脸）one more thing,我还发现一个有趣的现象：健身房里的女生永远比男生多，男士们难道真的这么不在乎自己的体型了吗？还是女生特别在意自己的体型？而且越是身材好的妹子，越能自律。同样的现象也发生在我学习英语的群。上过发音课和练口语的微信群，里面女生的比例远远大于男生。是女生太努力还是男生太忙？不得而知。 关于英语接下来步入正题，说说我学习英语的路线。其实最大的驱动力还是兴趣 我经常会问自己一些问题：为什么学了这么时间英语，英语还是这么烂？ 我记得张庆和我说过，他说“咱们就是学学就放下了，没有一直坚持去学“，说的没错，放下很容易，再拾起就困难了。我在毕业后和万词王曲根老师学习过单词坚持过两个月 然后后来就不学单词了，记得后来每天晚上一直在听一个电台，在网易云音乐上有个叫英语怎么说的节目，内容是萌叔肖恩和女神米歇尔以对话的形式来说英语，不时穿插着汉语在里面，我每一集都听过，现在好像停止更新了。 再到后来，张祎买了一个发音的课，账号分享给我了，我跟着上了课，真的是刷新了我的英语观，没错，真的是刷新，我才发现自己有大概50%的发音都是错误的。于是我决定开始从发音开始练口语，从Bingo到洛基英语到乐口英语，上的公开课以及发音群，真的让我收获了不少。 记得第一次在群里发语音的时候，真是张不开嘴，练了至少20分钟才敢于在群里发20s的语音，虽说我是一个不怎么在乎面子的人，群里也没人认识我，可是张嘴读英语还是那么地难。之前学的都是哑巴英语 我是2017.06.21开始加入了英语跟读计划，至今已经坚持了一个多月，很感谢纠音老师的每一次指导，你的每一次纠音我都有收藏 同样也是由于您给了我前进的动力，您告诉我可以再向上迈一个台阶，每天阅读英文和听听力，再默写之类的。于是乎我决定从新概念下手。在知乎上也看到好多人说新概念是经典中的经典。 关于行动既然已经决定，那就干吧。不要以没有时间做借口，因为现在是你时间最多的时候 You will never have more time than you do right now. 本文结束，感谢阅读。 本文作者：melody0z 本文链接：https://melodyvoid/Eassy/new-concept-plan.html 欢迎转载，转载请注明文本链接]]></content>
      <categories>
        <category>Eassy</category>
      </categories>
      <tags>
        <tag>NCE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0729]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0729.html</url>
    <content type="text"><![CDATA[必备句型​ I do love you. 我真的爱你 I don’t buy your story. 我不相信你的话 ​ 场景对话​ A: Last fall you said we couldn’t be together, and I believe you. Why are you here now? B: I am sorry Alex, but I do love you. And I… A: Enough, I don’t buy your story. ​ 参考译文​ A: 去年秋天你说我们不能在一起，而我相信了你。你来这里做什么？ B: 对不起，Alex。但是我是真的爱你。我… A: 够了，我猜不相信你的话。 ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[循环创建文件夹]]></title>
    <url>%2FNode%2Fcycle-creation-folder.html</url>
    <content type="text"><![CDATA[创建文件夹目录结构 |— 20-mkdir.js 12345678const fs = require("fs");const path = require("path");fs.mkdir(path.join(__dirname,"demo1"),(err) =&gt; &#123; console.log(err)&#125;);fs.mkdir(path.join(__dirname,"./demo2"),(err) =&gt; &#123; console.log(err)&#125;); 执行20-mkdir.js 123$ node 20-mkdir.js nullnull 目录结构变为 |— 20-mkdir.js |— demo1 |— demo2 报错什么情况下会报错呢？ 文件夹已经存在目录结构 |— 20-mkdir.js |— demo1 |— demo2 这里的意思是原本就已经存在demo1和demo2，我们试着再创建一下 同样执行20-mkdir.js 1234567891011$ node 20-mkdir.js &#123; Error: EEXIST: file already exists, mkdir '/Users/melody0z/github/nodejs/second/demo1' errno: -17, code: 'EEXIST', syscall: 'mkdir', path: '/Users/melody0z/github/nodejs/second/demo1' &#125;&#123; Error: EEXIST: file already exists, mkdir '/Users/melody0z/github/nodejs/second/demo2' errno: -17, code: 'EEXIST', syscall: 'mkdir', path: '/Users/melody0z/github/nodejs/second/demo2' &#125; 报错信息为Error: EEXIST: file already exists说文件夹已经存在。 不存在的文件夹20-mkdir.js 1234567891011 const fs = require("fs"); const path = require("path");- fs.mkdir(path.join(__dirname,"demo1"),(err) =&gt; &#123;- console.log(err)- &#125;);- fs.mkdir(path.join(__dirname,"./demo2"),(err) =&gt; &#123;- console.log(err)- &#125;);+ fs.mkdir(path.join(__dirname,"./test/demo3"),(err) =&gt; &#123;+ console.log(err);+ &#125;); 执行20-mkdir.js 123456$ node 20-mkdir.js &#123; Error: ENOENT: no such file or directory, mkdir '/Users/melody0z/github/nodejs/second/test/demo3' errno: -2, code: 'ENOENT', syscall: 'mkdir', path: '/Users/melody0z/github/nodejs/second/test/demo3' &#125; 报错信息Error: ENOENT: no such file or directory不存在的文件夹，因为我们并没有test文件夹，所以它不会帮我们创建，就直接报错。 创建层级目录我们先来创建一个模块 mkdirs.js 12function mkdirs(pathname,callback)&#123;&#125;module.exports = mkdirs; 在21-mkdirs.js中引入 123const fs = require("fs");const path = require("path");const mkdirs = require("./mkdirs"); 这是大体的骨架，然后我们来完善mkdirs.js模块 123456789101112131415161718+ //我们需要文件操作，文件操作就需要引入fs和path+ const fs = require("fs");+ const path = require("path"); function mkdirs(pathname, callback) &#123;+ //1.判断传入的是否是绝对路径+ pathname = path.isAbsolute(pathname)+ ? pathname+ : path.join(__dirname, pathname);+ //2.获取想要创建的部分+ // /Users/melody0z/github/nodejs/second/test/demo3+ // test文件夹和demo3文件夹需要创建，我们需要获取+ // dirname 是/Users/melody0z/github/nodejs/second+ pathname = pathname.replace(__dirname,"");+ console.log(pathname); &#125; module.exports = mkdirs; 写到这里我们来测试一下，在21-mkdirs.js中 123456const fs = require("fs");const path = require("path");const mkdirs = require("./mkdirs");mkdirs("test/demo3");mkdirs("/Users/melody0z/github/nodejs/second/test/demo3") 执行 123$ node 21-mkdirs.js /test/demo3/test/demo3 是我们想要的结果，我们得到了test和demo3 然而我们还有一种方法，那就是path模块自带的path.relative()方法 mkdirs.js中 12345678910111213141516 const fs = require("fs"); const path = require("path"); function mkdirs(pathname, callback) &#123; //1.判断传入的是否是绝对路径 pathname = path.isAbsolute(pathname) ? pathname : path.join(__dirname, pathname); //2.获取想要创建的部分 // /Users/melody0z/github/nodejs/second/test/demo3 // test文件夹和demo3文件夹需要创建，我们需要获取 // dirname 是/Users/melody0z/github/nodejs/second- //pathname = pathname.replace(__dirname,"");+ pathname = path.relative(__dirname,pathname); console.log(pathname); &#125; module.exports = mkdirs; 其余不变，我们再来执行21-mkdirs.js 123$ node 21-mkdirs.js test/demo3test/demo3 同样也能得到test和demo3。 以上两种方法的区别仅仅是多一个少一个/ 好了，我们用第二种方法接着往下写 mkdirs.js 12345678910111213141516171819const fs = require("fs");const path = require("path");function mkdirs(pathname, callback) &#123; //1.判断传入的是否是绝对路径 pathname = path.isAbsolute(pathname) ? pathname : path.join(__dirname, pathname); //2.获取想要创建的部分 // /Users/melody0z/github/nodejs/second/test/demo3 // test文件夹和demo3文件夹需要创建，我们需要获取 // dirname 是/Users/melody0z/github/nodejs/second let relativePath = path.relative(__dirname,pathname); let folders = relativePath.split(path.sep); console.log(folders);&#125;module.exports = mkdirs; 注意14行let folders = relativePath.split(path.sep);中不能写成let folders = relativePath.split(&quot;/&quot;);因为windows和POSIX平台上是不同的，需要用path.sep来代替。 然后我们执行一下21-mkdirs.js来测试一下 123$ node 21-mkdirs.js [ 'test', 'demo3' ][ 'test', 'demo3' ] good！是我们想要的结果。 我们继续写 12345678910111213141516171819202122232425262728 const fs = require("fs"); const path = require("path"); function mkdirs(pathname, callback) &#123; //1.判断传入的是否是绝对路径 pathname = path.isAbsolute(pathname) ? pathname : path.join(__dirname, pathname); //2.获取想要创建的部分 // /Users/melody0z/github/nodejs/second/test/demo3 // test文件夹和demo3文件夹需要创建，我们需要获取 // dirname 是/Users/melody0z/github/nodejs/second let relativePath = path.relative(__dirname,pathname); let folders = relativePath.split(path.sep);+ //3.遍历，由于遍历是同步的(文件夹需要有顺序)，创建文件夹也需要同步+ //同步的话就需要用try...catch来捕获错误+ try&#123;+ folders.forEach(folder =&gt; &#123;+ fs.mkdirSync(path.join(__dirname,folder));+ &#125;);+ callback &amp;&amp; callback(null);+ &#125;catch (error)&#123;+ callback &amp;&amp; callback(error)+ &#125; &#125;module.exports = mkdirs; 21-mkdirs.js 12345const fs = require("fs");const path = require("path");const mkdirs = require("./mkdirs");mkdirs(path.join(__dirname,"test/demo3")); 我们来执行一下21-mkdirs.js 目录结构发生了变化 |— 21-mkdirs.js |— mkdirs.js |— test |— demo3 我们发现demo3并没有在test文件夹里面，所以我们还需要修改 mkdirs.js 123456789101112131415161718192021222324252627282930 const fs = require("fs"); const path = require("path"); function mkdirs(pathname, callback) &#123; //1.判断传入的是否是绝对路径 pathname = path.isAbsolute(pathname) ? pathname : path.join(__dirname, pathname); //2.获取想要创建的部分 // /Users/melody0z/github/nodejs/second/test/demo3 // test文件夹和demo3文件夹需要创建，我们需要获取 // dirname 是/Users/melody0z/github/nodejs/second let relativePath = path.relative(__dirname,pathname); let folders = relativePath.split(path.sep);+ let pre = ""; try&#123; folders.forEach(folder =&gt; &#123;- fs.mkdirSync(path.join(__dirname,folder));+ fs.mkdirSync(path.join(__dirname,pre,folder));+ pre = path.join(pre,folder); &#125;); callback &amp;&amp; callback(null); &#125;catch (error)&#123; callback &amp;&amp; callback(error) &#125; &#125; module.exports = mkdirs; 我们再来执行21-mkdirs.js 目录结构 |— 21-mkdirs.js |— mkdirs.js |— test |— demo3 这样就打成我们的目标了 ​ 注意点我们更改一下目录结构 |— module |— mkdirs.js |— 21-mkdirs.js 再来执行21-mkdirs.js就会报错，说文件夹已存在，原因就在于mkdirs.js模块里的__dirname; __dirname是相对于mkdirs.js模块的路径，而我们需要的是谁引用了mkdirs.js模块，路径就相对于谁，这里需要使用module.parent. module/mkdirs.js 12345678910111213141516171819202122232425262728293031323334353637383940const fs = require("fs");const path = require("path");function mkdirs(pathname, callback) &#123; const filename = module.parent.filename; const root = path.dirname(filename); //1.判断传入的是否是绝对路径 pathname = path.isAbsolute(pathname) ? pathname : path.join(root, pathname); //2.获取想要创建的部分 // /Users/melody0z/github/nodejs/second/test/demo3 // test文件夹和demo3文件夹需要创建，我们需要获取 // __dirname 是/Users/melody0z/github/nodejs/second //pathname = pathname.replace(__dirname,""); //注意：这里的__dirname有问题，应该是谁调用这个模块，__dirname就是就是这个文件的路径 let relativePath = path.relative(root,pathname); let folders = relativePath.split(path.sep); let pre = ""; try&#123; folders.forEach(folder =&gt; &#123; try&#123; //检测文件夹状态，文件夹不存在跳到catch里面去创建 fs.statSync(path.join(root,pre,folder)); &#125;catch (error)&#123; fs.mkdirSync(path.join(root,pre,folder)); &#125; pre = path.join(pre,folder); &#125;); callback &amp;&amp; callback(null); &#125;catch (error)&#123; callback &amp;&amp; callback(error) &#125;&#125;module.exports = mkdirs; 21-mkdirs.js 12345678910const fs = require("fs");const path = require("path");const mkdirs = require("./module/mkdirs");mkdirs(path.join(__dirname,"test/demo3/demo4"),(err) =&gt; &#123; console.log(err)&#125;);mkdirs(path.join(__dirname,"test/demo3/demo5"),(err) =&gt; &#123; console.log(err)&#125;); 我们执行后，创建的目录如下 |— test |— demo3 |— demo4 |— demo5 ​ ​ 本文结束，感谢阅读。 本文作者：melody0z 本文链接：https://melodyvoid/Node/cycle-creation-folder.html 欢迎转载，转载请注明文本链接]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0728]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0728.html</url>
    <content type="text"><![CDATA[必备句型​ What the hell is wrong with you? 你到底怎么了？ I mean it. 我是认真的。 ​ 场景对话​ A: I’ve had enough, I don’t wanna talk to you anymore,and I don’t want to see you again in my life. B: What the hell is wrong with you? Are you kidding me? A: No,I mean it. ​ 参考译文​ A: 我真的受够了，不想再跟你说话，这辈子都不想再见到你了。 B: 你到底怎么了？你是在开玩笑吗？ A: 不，我是认真的。 ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文件写入]]></title>
    <url>%2FNode%2Ffile-write.html</url>
    <content type="text"><![CDATA[我们来看一下如何写一个文件。 创建19-writeFile.js 首先，先引入fs模块和path模块 12const fs = require("fs");const path = require("path"); 写入文件一共有三种方式， 异步写入 fs.writeFile() 同步写入 fs.writeFileSync() 以流的方式写入 fs.createWriteStream() ​ 一、fs.writeFile() 123456789101112const fs = require("fs");const path = require("path");const filename = path.join(__dirname,"./demo.txt");fs.writeFile(filename,&#123;name:"Jack"&#125;,(err) =&gt; &#123; if(err)&#123; console.log("error"); &#125;else&#123; console.log("success"); &#125;&#125;); fs.writeFile()的第二个参数是类型值，可以是any，我们刚写入了一个对象，看看会是什么结果。我们执行一下 12$ node 19-writeFile.js success 写入成功，我们看看demo.txt里是什么 1[object Object] 我们可以发现，写入的内容就是object.toString()过后的结果。 那么怎么才能达到我们想要的结果呢？ 答案是用JSON.stringify()把对象转换为JSON（序列化） JSON.stringify() =&gt; 序列化 JSON.parse() =&gt; 反序列化 我们修改一下上面的代码 123456789101112const fs = require("fs");const path = require("path");const filename = path.join(__dirname,"./demo.txt");fs.writeFile(filename,JSON.stringify(&#123;name:"Jack"&#125;),(err) =&gt; &#123; if(err)&#123; console.log("error"); &#125;else&#123; console.log("success"); &#125;&#125;); 再来执行一下。我们看到demo.txt是如下结果 1&#123;&quot;name&quot;:&quot;Jack&quot;&#125; 什么情况会出现写文件错误呢？ 意外错误 文件权限问题 文件夹找不到（不会自动创建文件夹） 二、fs.writeFileSync() 123456789const fs = require("fs");const path = require("path");const filename = path.join(__dirname,"./demo.txt");try&#123; fs.writeFileSync(filename,JSON.stringify(&#123;name:"Mary"&#125;));&#125;catch (e)&#123; console.log(e)&#125; 执行过后，demo.txt里的内容变为 1&#123;&quot;name&quot;:&quot;Mary&quot;&#125; 三、fs.createWriteStream() 12345678910const fs = require("fs");const path = require("path");const filename = path.join(__dirname,"./demo.txt");let writeStream = fs.createWriteStream(filename);writeStream.write("Hello",(err) =&gt; &#123; if (err) throw err; console.log("写入成功")&#125;); 执行过后，demo.txt里的内容变为 1Hello 以上就是写入文件的三种方式。 but，我们发现了一个问题，就是文件写入默认是会覆盖之前的内容的，那么怎么才能不覆盖呢？好，我们引出下面的API，fs.appendFile(),用法和上面的一样。 123456789101112const fs = require("fs");const path = require("path");const filename = path.join(__dirname,"./demo.txt");fs.appendFile(filename,&#123;name:"Jack"&#125;,(err) =&gt; &#123; if(err)&#123; console.log("error"); &#125;else&#123; console.log("success"); &#125;&#125;); 执行本代码过后，demo.txt里的内容变为了 1Hello&#123;&quot;name&quot;:&quot;Jack&quot;&#125; 本文结束，感谢阅读。 本文作者：melody0z 本文链接：https://melodyvoid/Node/file-write.html 欢迎转载，转载请注明文本链接]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>文件写入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node学习笔记02]]></title>
    <url>%2FNode%2Fnode-learning-notes-02.html</url>
    <content type="text"><![CDATA[核心模块和对象核心模块的意义 如果只是在服务器运行JavaScript代码，意义并不大，因为无法实现任何功能（读写文件，访问网络）。 Node的用处在于它本身还提供的一系列功能模块，用于与操作系统互动。 这些核心的功能模块在Node中内置。 内置模块： path: 处理文件路径 fs: 操作（CRUD）文件系统 CRUD—增加（Create）、读取查询（Retrieve)、更新（Update）和删除（Delete） child_process: 新建子进程 util: 提供一系列实用小工具 http: 提供HTTP服务器功能 url: 用于解析URL querystring: 解析URL中的查询字符串 crypto: 提供加密和解密功能 …… 包的概念什么是包 由于Node是一套轻内核的平台，虽然提供了一系列的内置模块，但是不足以满足开发者的需求，于是乎出现了包（package）的概念。 与核心模块类似，就是将一些预先设计好的功能或者API封装到一个文件夹，提供给开发者使用 包的加载机制 id：包名的情况：require(“http”) 现在系统核心（优先级最高）的模块中找（以后不要创建一些和现有的包重名的包） 然后再到当前项目中node_modules目录中找 如何管理那么多的包 由于Node本身并没有太多的功能性API，所以市面上涌现出大量的第三方人员开发出来的Package 包的生态圈一旦繁荣起来，就必须有工具去代替人脑或者文档的方式管理 NPMNPM概述Node Package Manager 随着时间的发展，NPM出现了两层概念： 一层含义是Node的开放式模块登记和管理系统，也可以说是一个生态圈，一个社区 另一层含义是Node默认的模块管理器，是一个命令行下的软件，用来安装和管理Node模块 安装NPM NPM不需要单独安装，默认在安装Node的时候，会连带一起安装NPM。 但是，Node附带的NPM可能不是最新版本，最好用下面的命令，更新到最新版本 npm install npm -g 默认安装到当前系统Node所在目录下。 常用NPM命令 npm config npm init npm search npm info npm install npm uninstall npm list npm outdated npm update npm run npm cache 文件系统操作相关模块 fs：基础的文件操作API path：提供和路径相关的操作API readline：用于读取大文本文件，一行一行读 fs-extra(第三方) https://www.npmjs.com/package/fs-extra 路径操作模块（path) 在文件操作的过程中，都“必须”使用物理路径（绝对路径） path模块提供了一系列一系列与路径相关的API path.join([p1][,p2]…) =&gt;连接多个路径 path.basename(p,ext) =&gt;获取文件名 path.dirname(p) =&gt;获取文件夹路径 path.extname(p) =&gt;获取文件扩展名 path.format(obj) 和path.parse(p) 一个是格式化对象为字符串，一个是将字符串解析为对象 path.relative(from,to) =&gt; 获取从from到to的相对路径。 同步或异步调用 fs模块对文件的几乎所有操作都有同步和异步两种形式 例如：readFile() 和readFileSync() 区别： 同步调用会阻塞代码的执行，异步则不会 异步调用会将读取任务下达到任务队列，知道任务执行完成才会回调 异常处理方面，同步必须使用try…catch方式，异步可以通过回调函数的第一个参数（错误优先） 文件读取 异步文件读取 fs.readFile(file[,option],callback(err,data)) 同步文件读取 fs.readFileSync(file[,option]) 文件流的方式读取 fs.createReadStream(path[,options]) readline模块逐行读取文本12345678const readline = require("readline");const fs = require("fs");const rl = readline.createInterface(&#123;input:fs.createReadStream("sample.txt")&#125;);rl.on("line",(line) =&gt; &#123; console.log("Line from file:",line);&#125;); 文件写入 确保操作没有额外的问题，一定使用绝对路径的方式 异步文件写入 fs.writeFile(file,data[,option],callback(err)) 同步文件写入 fs.writeFileSync(file,data[,option]) 流式文件写入 fs.createWriteStream(path[,option]) 默认写入操作是覆盖源文件 异步追加 fs.appendFile(file,data[,option],callback(err)) 同步追加 fs.appendFileSync(file,data[,options]) 其他文件操作 获取文件信息 fs.stat(path,callback(err,stats)) fs.statSync(path) =&gt;返回一个fs.stats实例 移动文件 fs.rename(oldPath,newPath) 重命名文件或目录 fs.rename(oldPath,newPath,callback) fs.renameSync(oldPath,newPath) 删除文件 fs.unlink(path,callback(err)) fs.unlinkSync(path) 目录操作 创建一个目录 fs.mkdir(path[,model],callback) fs.mkdirSync(path[,model]) 删除一个空目录 fs.rmdir(path,callback) fs.rmdirSync(path) 读取一个目录 fs.readdir(path,callback(err,files)) fs.readdirSync(path) =&gt; 返回files 监视文件 监视文件变化 fs.watchFile(filename[,options],listener(curr,prev)) options:{persistent,interval} fs.watch(filename[,options][,listener]) 本文结束，感谢阅读。 本文作者：melody0z 本文链接：https://melodyvoid/Node/node-learning-notes-02.html 欢迎转载，转载请注明文本链接]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0727]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0727.html</url>
    <content type="text"><![CDATA[必备句型​ Mind your own business. 管好你自己的事 What do you mean by saying so? 你这样说是什么意思？ ​ 场景对话​ A: I still don’t understand, why did you do that? B: It’s not what you think. Mind your own business. A: What do you mean by saying so? I was just trying to help. ​ 参考译文​ A: 我还是不明白，你为什么要那样做？ B: 不是你想的那样，管好你自己的事。 A: 你这样说是什么意思？我只是想帮忙。 ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[以文件流的方式读取文件内容]]></title>
    <url>%2FNode%2Freads-file-contents-in-a-file-stream.html</url>
    <content type="text"><![CDATA[目录结构 |— 16.createStream.js |— blood.lrc 12345678910111213141516171819const fs = require("fs");const path = require("path");const iconv = require("iconv-lite");const filename = path.join(__dirname,"./blood.lrc");//创建一个文件读取流let stream = fs.createReadStream(filename);//让文件流通过iconv过滤编码stream = stream.pipe(iconv.decodeStream("gbk"));let content = "";stream.on("data",(chunk) =&gt; &#123; content += chunk;&#125;);//读取结束stream.on("end",() =&gt; &#123; console.log(content);&#125;) 我们来执行一下它 1234567$ node 16-createStream.js [ti:血染的风采][ar:黄耀明]...中间省略[03:19.42] 共和国的旗帜上有我们血染的风采[03:25.51] * * *[03:32.98] ---End--- 我们尝试着让歌词滚动显示 |— 17-showLyric.js 123456789101112131415161718192021222324252627282930313233const fs = require("fs");const path = require("path");const iconv = require("iconv-lite");const filename = path.join(__dirname,"./blood.lrc");fs.readFile(filename,(err,data) =&gt; &#123; if(err) throw err; let lines = iconv.decode(data,"gbk").split("\n"); //[00:32.67] 也许我告别 将不再回来 let regexp = /\[(\d&#123;2&#125;):(\d&#123;2&#125;)\.(\d&#123;2&#125;)]\s(.+)/; let start = new Date().getTime(); //遍历 lines.forEach((line) =&gt; &#123; // [00:32.67] 也许我告别 将不再回来 let matches = regexp.exec(line); if(matches)&#123; let min = matches[0]; let sec = parseFloat(matches[2]); let ms = parseFloat(matches[3]); let lyric = matches[4]; let time = min * 60 * 1000 + sec * 1000 + ms; //当前歌词不是立即执行，由于下达任务的时刻不同我们要设置时间偏移量 let offset = new Date().getTime(); setTimeout(() =&gt; &#123; console.log(lyric) &#125;,time - offset); &#125;else&#123; //不是一句歌词 console.log(line); &#125; &#125;)&#125;) 执行16.showLyric.js 12345678910$ node 17-showLyric.js [ti:血染的风采][ar:黄耀明][al:人山人海][offset:500][00:55.04]中文歌词库 www.CnLyric.com歌曲：血染的风采歌手：黄耀明^C 我们成功了。 我们以上拆分歌词是用split(&quot;\n&quot;)拆分成数组，然后再遍历每一句这样做的。然而node给我们提供了一个模块叫做readline.我们下面用readline模块完成同样的业务。 18-readline.js 12345678910111213141516171819202122232425262728293031//readline实现一行一行读取歌词const fs = require("fs");const path = require("path");const iconv = require("iconv-lite");const readline = require("readline");const filename = path.join(__dirname,"./blood");const readStream = fs.createReadStream(filename) .pipe(iconv.decodeStream("gbk"));let rl = readline.createInterface(&#123;input:readStream&#125;);let regexp = /\[(\d&#123;2&#125;):(\d&#123;2&#125;)\.(\d&#123;2&#125;)]\s(.+)/;let start = new Date().getTime();rl.on("line",(line) =&gt; &#123; if(matches)&#123; let min = parseFloat(matches[1]); let sec = parseFloat(matches[2]); let ms = parseFloat(matches[3]); let lyric = matches[4]; let time = min * 60 * 1000 + sec * 1000 + ms; //当前歌词不是立即执行，由于下达任务的时刻不同我们要设置时间偏移量 let offset = new Date().getTime() - start; setTimeout(() =&gt; &#123; console.log(lyric); &#125;,time - offset); &#125;else&#123; //不是一句歌词 console.log(line); &#125;&#125;) 执行18-readline.js 12345678910$ node 18-readline.js [ti:血染的风采][ar:黄耀明][al:人山人海][offset:500][00:55.04]中文歌词库 www.CnLyric.com歌曲：血染的风采歌手：黄耀明^C ​ ​ 本文结束，感谢阅读。 本文作者：melody0z 本文链接：https://melodyvoid/Node/reads-file-contents-in-a-file-stream.html 欢迎转载，转载请注明文本链接]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>文件流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编码问题]]></title>
    <url>%2FNode%2Fcoding-problem.html</url>
    <content type="text"><![CDATA[fs在读取文件的时候，会把文件读取为buffer，buffer有一个toString()方法，可以把文件转换为字符串，但是默认编码是utf8，读取编码为gbk的文件就会乱码。本文将会读取一个编码为gbk的歌词文件，下面是过程。 目录结构 |— 14-readFileSync.js |— blood.lrc 14-readFileSync.js 123456789101112//同步读取文件的内容//所有的文件操作都是基于fs模块const fs = require("fs");//无论是同步还是异步，文件操作都要使用绝对路径const path = require("path");//将文本读取到一个buffer中const buffer = fs.readFileSync(path.join(__dirname,"./blood.lrc"));//将buffer中的内容读取出来const data = buffer.toString();console.log(data); 执行14-readFileSync.js 12345678910$ node 14-readFileSync.js [ti:ѪȾ�ķ��][ar:��ҫ��][al:��ɽ�˺�][offset:500][00:01.21] ������ѪȾ�ķ��...中间省略[03:19.42] ���͹���������������ѪȾ�ķ��[03:25.51] * * *[03:32.98] ---End--- 读取出来的是乱码，为什么是乱码呢？因为编码问题，.lrc文件是gbk编码，node默认是utf8编码 为了解决编码问题，我们需要引入第三方模块 iconv-lite 在项目目录下创建package.json 1$ npm init -y 1$ npm install iconv-lite --save-dev 好了，模块安装好了之后我们就可以直接引用了 14-readFileSync.js 123456789101112 const fs = require("fs"); const path = require("path"); const buffer = fs.readFileSync(path.join(__dirname,"./blood.lrc")); - const data = buffer.toString();- console.log(data); + //我们需要引入第三方模块+ const iconv = require("iconv-lite");+ const data2 = iconv.decode(buffer,"gbk");+ console.log(data2); 执行14-readFileSync.js 123456$ node 14-readFileSync.js [ti:血染的风采][ar:黄耀明]...中间省略[03:25.51] * * *[03:32.98] ---End--- done,成功读取。 下面我们用异步的方式再来读取一下 15-readFile.js 12345678910const fs = require("fs");const path = require("path");const iconv = require("iconv-lite");const filename = path.join(__dirname,"./blood.lrc");fs.readFile(filename,(err,data) =&gt; &#123; if(err) throw err; console.log(iconv.decode(data,"gbk"));&#125;); 执行15-readFile.js 123456$ node 15-readFile.js [ti:血染的风采][ar:黄耀明]...中间省略[03:25.51] * * *[03:32.98] ---End--- 也一样读取成功。 ​ 本文结束，感谢阅读。 本文作者：melody0z 本文链接：https://melodyvoid/Node/coding-problem.html 欢迎转载，转载请注明文本链接]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>编码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0726]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0726.html</url>
    <content type="text"><![CDATA[必备句型​ This is gonna be the hottest day we’ve had so far this summer. 今夏以来这大概是最热的一天了 You can say that again. 你说的一点也没错 ​ 场景对话​ A: Oh my God. It’s so hot today. This is gonna be the hottest day we’ve had so far this summer. B: You can say that again! I’ve never suffered so much from the heat. ​ 参考译文​ A: 我的天啊，今天好热，今夏以来这大概是最热的一天了。 B: 你说的一点也没错，我还从没有经受过这么炎热的天气。 ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[path模块]]></title>
    <url>%2FNode%2Fpath-module.html</url>
    <content type="text"><![CDATA[path.basename(path[,ext])语法：path.basename(path[,ext]) path:路径 例：/Users/melody0z/github/nodejs/second/a.txt ext: 扩展名 （extension) 例：.txt 返回一个path的最后一部分，也就是文件名。 12345path.basename("/Users/melody0z/github/nodejs/second/a.txt")// a.txtpath.basename("/Users/melody0z/github/nodejs/second/a.txt",".txt");// a path.delimiter提供平台特定的路径分隔符 windows上是; POSIX上是: 12345console.log(process.env.PATH);// /usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbinconsole.log(process.env.PATH.split(path.delimiter));// [ '/usr/local/bin', '/usr/bin', '/bin', '/usr/sbin', '/sbin' ] path.dirname(path)语法：path.dirname(path) path: 路径 例如：/Users/melody0z/github/nodejs/second/a.txt 返回一个path的目录名 12path.dirname("/Users/melody0z/github/nodejs/second/a.txt")// /Users/melody0z/github/nodejs/second path.extname(path)语法：path.extname(path) path: 路径 例如：/Users/melody0z/github/nodejs/second/a.txt 返回path的扩展名，即从 path 的最后一部分中的最后一个 .（句号）字符到字符串结束。 如果 path 的最后一部分没有 . 或 path 的文件名（见 path.basename()）的第一个字符是 .，则返回一个空字符串。 1234567891011121314path.extname('index.html');// 返回: '.html'path.extname('index.coffee.md');// 返回: '.md'path.extname('index.');// 返回: '.'path.extname('index');// 返回: ''path.extname('.index');// 返回: '' path.parse(path)语法：path.parse(path) path.parse() 方法返回一个对象，对象的属性表示 path 的元素。 返回的对象有以下属性： dir root base name ext 在POSIX上： 1234567891011121314path.parse('/home/user/dir/file.txt');// 返回:// &#123; root: '/',// dir: '/home/user/dir',// base: 'file.txt',// ext: '.txt',// name: 'file' &#125;┌─────────────────────┬────────────┐│ dir │ base │├──────┬ ├──────┬─────┤│ root │ │ name │ ext │" / home/user/dir / file .txt "└──────┴──────────────┴──────┴─────┘(请无视以上字符串中的空格，它们只是为了布局) 在 Windows 上： 123456789101112131415path.parse('C:\\path\\dir\\file.txt');// 返回:// &#123; root: 'C:\\',// dir: 'C:\\path\\dir',// base: 'file.txt',// ext: '.txt',// name: 'file' &#125;┌─────────────────────┬────────────┐│ dir │ base │├──────┬ ├──────┬─────┤│ root │ │ name │ ext │" C:\ path\dir \ file .txt "└──────┴──────────────┴──────┴─────┘(请无视以上字符串中的空格，它们只是为了布局) path.format(pathObject) pathObject dir root base name ext 返回一个path字符串 path.format() 方法会从一个对象返回一个路径字符串。 与 path.parse() 相反。 当 pathObject 提供的属性有组合时，有些属性的优先级比其他的高： 如果提供了 pathObject.dir，则 pathObject.root 会被忽略 如果提供了 pathObject.base 存在，则 pathObject.ext 和 pathObject.name 会被忽略 例如，在 POSIX 上： 1234567891011121314151617181920212223242526// 如果提供了 `dir`、`root` 和 `base`，则返回 `$&#123;dir&#125;$&#123;path.sep&#125;$&#123;base&#125;`。// `root` 会被忽略。path.format(&#123; root: '/ignored', dir: '/home/user/dir', base: 'file.txt'&#125;);// 返回: '/home/user/dir/file.txt'// 如果没有指定 `dir`，则 `root` 会被使用。// 如果只提供了 `root` 或 `dir` 等于 `root`，则平台的分隔符不会被包含。// `ext` 会被忽略。path.format(&#123; root: '/', base: 'file.txt', ext: 'ignored'&#125;);// 返回: '/file.txt'// 如果没有指定 `base`，则 `name` + `ext` 会被使用。path.format(&#123; root: '/', name: 'file', ext: '.txt'&#125;);// 返回: '/file.txt' 在 Windows 上： 12345path.format(&#123; dir: 'C:\\path\\dir', base: 'file.txt'&#125;);// 返回: 'C:\\path\\dir\\file.txt' path.isAbsolute(path)path: 路径 返回一个布尔值 path.isAbsolute() 方法会判定 path 是否为一个绝对路径。 如果给定的 path 是一个长度为零的字符串，则返回 false。 例如，在 POSIX 上： 1234path.isAbsolute('/foo/bar'); // truepath.isAbsolute('/baz/..'); // truepath.isAbsolute('qux/'); // falsepath.isAbsolute('.'); // false 在 Windows 上： 1234567path.isAbsolute('//server'); // truepath.isAbsolute('\\\\server'); // truepath.isAbsolute('C:/foo/..'); // truepath.isAbsolute('C:\\foo\\..'); // truepath.isAbsolute('bar\\baz'); // falsepath.isAbsolute('bar/baz'); // falsepath.isAbsolute('.'); // false path.join([…paths])…pahts 一个路径片段的序列 返回一个完整路径字符串 path.join() 方法使用平台特定的分隔符把全部给定的 path 片段连接到一起，并规范化生成的路径。 长度为零的 path 片段会被忽略。 如果连接后的路径字符串是一个长度为零的字符串，则返回 &#39;.&#39;，表示当前工作目录。 例子： 12345path.join('/foo', 'bar', 'baz/asdf', 'quux', '..');// 返回: '/foo/bar/baz/asdf'path.join('foo', &#123;&#125;, 'bar');// 抛出 'TypeError: Path must be a string. Received &#123;&#125;' path.normalize(path)path: 路径 返回一个正常版的路径字符串 path.normalize() 方法会规范化给定的 path，并解析 &#39;..&#39; 和 &#39;.&#39; 片段。 当发现多个连续的路径分隔符时（如 POSIX 上的 / 与 Windows 上的 \ 或 /），它们会被单个的路径分隔符（POSIX 上是 /，Windows 上是 \）替换。 末尾的多个分隔符会被保留。 如果 path 是一个长度为零的字符串，则返回 &#39;.&#39;，表示当前工作目录。 例如，在 POSIX 上： 12path.normalize('/foo/bar//baz/asdf/quux/..');// 返回: '/foo/bar/baz/asdf' 在 Windows 上： 12path.normalize('C:\\temp\\\\foo\\bar\\..\\');// 返回: 'C:\\temp\\foo\\' path.relative(from,to)path.relative() 方法返回从 from 到 to 的相对路径（基于当前工作目录）。 如果 from 和 to 各自解析到同一路径（调用 path.resolve()），则返回一个长度为零的字符串。 如果 from 或 to 传入了一个长度为零的字符串，则当前工作目录会被用于代替长度为零的字符串。 例如，在 POSIX 上： 12path.relative('/data/orandea/test/aaa', '/data/orandea/impl/bbb');// 返回: '../../impl/bbb' 在 Windows 上： 12path.relative('C:\\orandea\\test\\aaa', 'C:\\orandea\\impl\\bbb');// 返回: '..\\..\\impl\\bbb' path.resolve([…paths])…paths 一个路径或路径片段的序列 返回一个绝对路径 path.resolve() 方法会把一个路径或路径片段的序列解析为一个绝对路径。 给定的路径的序列是从右往左被处理的，后面每个 path 被依次解析，直到构造完成一个绝对路径。 例如，给定的路径片段的序列为：/foo、/bar、baz，则调用 path.resolve(&#39;/foo&#39;, &#39;/bar&#39;, &#39;baz&#39;) 会返回 /bar/baz。 如果处理完全部给定的 path 片段后还未生成一个绝对路径，则当前工作目录会被用上。 生成的路径是规范化后的，且末尾的斜杠会被删除，除非路径被解析为根目录。 长度为零的 path 片段会被忽略。 如果没有传入 path 片段，则 path.resolve() 会返回当前工作目录的绝对路径。 例子： 123456789path.resolve('/foo/bar', './baz');// 返回: '/foo/bar/baz'path.resolve('/foo/bar', '/tmp/file/');// 返回: '/tmp/file'path.resolve('wwwroot', 'static_files/png/', '../gif/image.gif');// 如果当前工作目录为 /home/myself/node，// 则返回 '/home/myself/node/wwwroot/static_files/gif/image.gif' path.sep提供了平台特定的路径片段分隔符： Windows 上是 \ POSIX 上是 / 例如，在 POSIX 上： 12'foo/bar/baz'.split(path.sep);// 返回: ['foo', 'bar', 'baz'] 在 Windows 上： 12'foo\\bar\\baz'.split(path.sep);// 返回: ['foo', 'bar', 'baz'] 注意：在 Windows 上，斜杠字符（/）和反斜杠字符（\）都可作为路径分隔符； 但 path 的方法只添加反斜杠（\）。 本文结束，感谢阅读。 参考资料：node官方文档本文作者：melody0z 本文链接：https://melodyvoid/Node/path-module.html 欢迎转载，转载请注明文本链接]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>path模块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0725]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0725.html</url>
    <content type="text"><![CDATA[必备句型​ I think that a good friend should be a good listener. 我觉得一个好朋友应该善于倾听 I’m so lucky to such a friend like you. 有你这样的朋友真是幸运。 ​ 场景对话​ A: I think that a good friend should be a good listener. B: That’s true. I’m so lucky to have such a friend like you. A: Me,too,thank you for all you have done for me. ​ 参考译文​ A: 我觉得一个好朋友应该善于倾听。 B: 确实，有你这样的朋友真是幸运。 A: 我也是，感谢你为我所做的一切。 ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0724]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0724.html</url>
    <content type="text"><![CDATA[必备句型​ It’s hard to imagine what it would be like to have no friends. 真难以想象没有朋友会是什么样子 I totally agree with you. 我完全同意你的看法 ​ 场景对话​ A: I have a lot of close friends. B: You must be pretty happy then? A: Yeah, It’s hard to imagine what it would be like to have no friends. B: I totally agree with you. ​ 参考译文​ A: 我有很多好朋友。 B: 那你一定很快乐吧。 A: 是的，真难以想象没有朋友会是个什么样子。 B: 我完全同意你的看法。 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模块化结构]]></title>
    <url>%2FNode%2Fmodular-structure.html</url>
    <content type="text"><![CDATA[模块化代码结构 Node采用的模块化结构是commonJS规范 模块与文件是一一对应关系，即加载一个模块，实际上就是加载对应的一个模块文件 CommonJS模块的特点 所有代码都运行在模块作用域，不会污染全局作用域。 模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。 模块加载的顺序，按照其在代码中出现的顺序。 模块的分类 文件模块 就是我们自己写的功能模块文件 核心模块 Node平台自带的一套基本的功能模块，也有人称之为Node平台的API 第三方模块 社区或者第三方个人开发好的功能模块，可以直接拿回来用 模块化开发的流程 创建模块（foo.js) 导出成员（module.exports = {}) 载入模块 （let foo = require(“./foo.js”) 使用模块 （foo.bar()) 模块内的（伪）全局环境我们在文件操作中必须使用绝对路径 __dirname 用于获取当前文件所在目录的完整路径； 在REPL环境无效 __filename 用来获取当前文件的完整路径； 在REPL环境无效； module 模块对象 exports 映射到module.exports的别名 require() require.cache require.extensions require.main require.resolve() module对象Node内部提供一个module构建函数。所有模块都是module的实例。有以下属性： module.id 模块的识别符，通常是带有绝对路径的模块文件名。 module.filename 模块定义的文件的绝对路径。 module.loaded返回一个布尔值，表示模块是否已经加载完毕。 module.parent 返回一个对象，表示调用该模块的模块 module.children 返回一个数组，表示该模块要用到的其他模块。 module.exports 表示模块对外输出的值。 载入一个模块就是构建一个module实例 看个例子 |— module |— module.js |— 05-module.js module/module.js 1console.log(module); 05-module.js 1234const foo = require("./module/module");console.log("----------------------------------------");console.log(module); 然后我们执行05-module.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253$ node 05-module.js Module &#123; id: '/Users/melody0z/github/nodejs/second/module/module.js', exports: &#123;&#125;, parent: Module &#123; id: '.', exports: &#123;&#125;, parent: null, filename: '/Users/melody0z/github/nodejs/second/05-module.js', loaded: false, children: [ [Circular] ], paths: [ '/Users/melody0z/github/nodejs/second/node_modules', '/Users/melody0z/github/nodejs/node_modules', '/Users/melody0z/github/node_modules', '/Users/melody0z/node_modules', '/Users/node_modules', '/node_modules' ] &#125;, filename: '/Users/melody0z/github/nodejs/second/module/module.js', loaded: false, children: [], paths: [ '/Users/melody0z/github/nodejs/second/module/node_modules', '/Users/melody0z/github/nodejs/second/node_modules', '/Users/melody0z/github/nodejs/node_modules', '/Users/melody0z/github/node_modules', '/Users/melody0z/node_modules', '/Users/node_modules', '/node_modules' ] &#125;----------------------------------------Module &#123; id: '.', exports: &#123;&#125;, parent: null, filename: '/Users/melody0z/github/nodejs/second/05-module.js', loaded: false, children: [ Module &#123; id: '/Users/melody0z/github/nodejs/second/module/module.js', exports: &#123;&#125;, parent: [Circular], filename: '/Users/melody0z/github/nodejs/second/module/module.js', loaded: true, children: [], paths: [Object] &#125; ], paths: [ '/Users/melody0z/github/nodejs/second/node_modules', '/Users/melody0z/github/nodejs/node_modules', '/Users/melody0z/github/node_modules', '/Users/melody0z/node_modules', '/Users/node_modules', '/node_modules' ] &#125; 模块的定义 一个新的js文件就是一个模块 一个合格的模块应该是有导出成员的，否则模块就失去了定义的价值。 模块内部是一个独立（封闭）的作用域（模块与模块之间不会冲突） 模块之间必须通过导出或导入的方式协同 导出方式： exports.name = value; module.exports = {name:value} module.exports和exports module.exports是用于为模块导出成员的接口 exports是指向module.exports的别名，相当于在模块开始的时候执行：var exports = module.exports; 一旦为module.exports赋值，就会切断之前两者的相关性； 最终模块的导出成员以module.exports为准。 看个例子 |— module |— module.exports.js |— 06-module.exports.js module/module.exports.js 123456789let a = 10;let msg = "hello";function foo() &#123; return "我是函数"&#125;exports.a = a;exports.msg = msg;exports.foo = foo; 06-module.exports.js 1234const bar = require("./module/module.exports");console.log(bar.a);console.log(bar.msg);console.log(bar.foo()); 然后我们执行06-module.exports.js 1234$ node 06-module.exports.js 10hello我是函数 然后我们用module.exports的方式改写一下 123456789101112131415 let a = 10; let msg = "hello"; function foo() &#123; return "我是函数" &#125; - exports.a = a;- exports.msg = msg;- exports.foo = foo; + module.exports = &#123;+ a:a,+ msg:msg,+ foo:foo+ &#125;; 执行06-module.exports.js 1234$ node 06-module.exports.js 10hello我是函数 我们再用ES6的语法简化一下 1234567891011121314151617 let a = 10; let msg = "hello"; function foo() &#123; return "我是函数" &#125; - module.exports = &#123;- a:a,- msg:msg,- foo:foo- &#125;;+ module.exports = &#123;+ a,+ msg,+ foo+ &#125;; 执行结果和上面的一样。 载入模块 Node使用commonJS模块规范，内置的require函数用于加载模块文件。 require的基本功能是，读入并执行一个JavaScript文件，然后返回该模块的exports对象。 如果没有发现执行模块，会报错。 模块的加载机制id：路径的情况就是直接以相对路径的方式找文件 require实现机制 将传入的模块ID通过加载规则找到对应的模块文件 读取这个文件里面的代码 通过拼接的方式为该段代码构建私有空间 执行该代码 拿到module.exports返回 我们手动写一个$require函数 |— module |— module.exports.js |— 07-$require.js 12345678910111213141516171819202122232425262728293031323334//自己写一个require函数，目的是了解require的实现机制function $require(id) &#123; //1.先找到文件，文件不存在报错 //2.读取文件内容，内容是js代码 const fs = require("fs"); const path = require("path"); //要加载js的路径（完整路径） const filename = path.join(__dirname,id); const dirname = path.dirname(filename); let code = fs.readFileSync(filename,"utf8"); //同步读取文件，不会加入到事件队列 //3.执行代码，所要执行的代码需要营造一个私有空间 let module = &#123; id:filename, exports:&#123;&#125; &#125;; let exports = module.exports; code = `(function ($require,module,exports,__dirname,__filename) &#123; $&#123;code&#125; &#125;)($require,module,exports,dirname,filename)` eval(code); //4.返回值 return module.exports;&#125;const bar = $require("./module/module.exports.js");console.log(bar.a);console.log(bar.msg);console.log(bar.foo()); 然后执行 1234$ node 07-\$reqiure.js 10hello我是函数 require扩展名require加载文件时可以省略扩展名： require(&quot;./module&quot;) require(&quot;./module.js&quot;)此时文件按js文件执行 require(&quot;./module.json&quot;)此时文件按JSON文件解析 require(&quot;./module.node&quot;)此时文件预编译好的C++模块执行 优先级是js&gt;json&gt;node require加载文件规则 通过./后../开头：则按照相对路径从当前文件所在文件夹开始寻找模块； require(&quot;../file.js&quot;) 上级目录下找file.js文件 通过/开头：则以系统根目录开始寻找模块； require(&quot;/Users/melody0z/github/nodejs/second/module/file.js&quot;) 以绝对路径的方式寻找 如果参数字符串不以”./“或”/“开头，则表示加载的是一个默认提供的核心模块（位于node的系统安装目录中） require(&quot;fs&quot;) 加载核心模块中的文件系统（file system)模块 或者从当前目录向上搜索node_modules目录中的文件： require(&quot;my_module&quot;); 各级node_modules文件夹中搜索my_module.js文件； require加载目录规则 如果require传入的是一个目录的路径，会自动查看该目录的package.json文件，然后加载main字段指定的入口文件 如果package.json文件没有main字段，或者根本就没有package.json文件，则默认找目录下的index.js文件作为模块 require(&quot;./module&quot;);当前目录下找module文件夹中的index.js文件 模块的缓存 第一次加载某个模块时，Node会缓存该模块。以后再加载该模块，就直接冲缓存取出该模块的module.exports属性（不会再次执行该模块） 如果需要多次执行模块中的代码，一般可以让模块暴露行为（函数） 模块的缓存可以通过require.cache拿到，同样也可以删除 验证模块有缓存 目录结构 |— date.js |— 08.cache.js date.js 1module.exports = new Date(); 08-cache.js 12345const date = require("./date");setInterval(() =&gt; &#123; console.log(date.getTime());&#125;,1000); 执行08-cache.js 1234567$ node 08-cache.js 15009326952781500932695278150093269527815009326952781500932695278^C 看，每次输出的时间戳一样，说明结果被缓存起来了。 我们再来看 目录结构 |— date.js |— 09.cache2.js 09-cache2.js 1234567let last;setInterval(() =&gt; &#123; const date = require("./date"); console.log(last === date); last = date; console.log(date.getTime());&#125;,1000); 执行 12345678910$ node 09-cache2.js false1500933712763true1500933712763true1500933712763true1500933712763^C 同样证明有缓存 缓存长什么样？ 目录结构 |— date.js |— 10.cache3.js 10-cache3.js 12const date = require("./date")console.log(require.cache); 我们打印一下缓存看看 1234567891011121314151617181920212223242526272829303132333435363738&#123; '/Users/melody0z/github/nodejs/second/10-cache3.js': Module &#123; id: '.', exports: &#123;&#125;, parent: null, filename: '/Users/melody0z/github/nodejs/second/10-cache3.js', loaded: false, children: [ [Object] ], paths: [ '/Users/melody0z/github/nodejs/second/node_modules', '/Users/melody0z/github/nodejs/node_modules', '/Users/melody0z/github/node_modules', '/Users/melody0z/node_modules', '/Users/node_modules', '/node_modules' ] &#125;, '/Users/melody0z/github/nodejs/second/date.js': Module &#123; id: '/Users/melody0z/github/nodejs/second/date.js', exports: 2017-07-24T22:09:00.024Z, parent: Module &#123; id: '.', exports: &#123;&#125;, parent: null, filename: '/Users/melody0z/github/nodejs/second/10-cache3.js', loaded: false, children: [Object], paths: [Object] &#125;, filename: '/Users/melody0z/github/nodejs/second/date.js', loaded: true, children: [], paths: [ '/Users/melody0z/github/nodejs/second/node_modules', '/Users/melody0z/github/nodejs/node_modules', '/Users/melody0z/github/node_modules', '/Users/melody0z/node_modules', '/Users/node_modules', '/node_modules' ] &#125; &#125; 我们发现，缓存和module对象类似 了解了缓存之后，我们就知道如何清除缓存了 目录结构 |— date.js |— 11-swipecache.js 11-swipecache.js 1234567setInterval(() =&gt; &#123; Object.keys(require.cache).forEach((key) =&gt; &#123; delete require.cache[key]; &#125;); const date = require("./date"); console.log(date.getTime());&#125;,1000); 执行11-swipecache.js 123456$ node 11-swipecache.js 1500935467664150093546869215009354696991500935470701^C 注意： 先清除缓存，再require。 下面我们将自己写的$require加上缓存 123456789101112131415161718192021222324252627282930313233343536function $require(id) &#123; const fs = require("fs"); const path = require("path"); const filename = path.join(__dirname, id); $require.cache = $require.cache || &#123;&#125;; if ($require.cache[filename]) &#123; return $require.cache[filename].exports; &#125; //第一次没有缓存 const dirname = path.dirname(filename); let code = fs.readFileSync(filename, "utf8"); //定义一个数据容器，用容器去装模块导出的成员 let module = &#123; id: filename, exports: &#123;&#125; &#125;; let exports = module.exports; code = ` (function($require, module, exports, __dirname, __filename) &#123; $&#123;code&#125; &#125;)($require, module, exports, dirname, filename);`; eval(code); //缓存起来 $require.cache[filename] = module; return module.exports;&#125;setInterval(() =&gt; &#123; const date = $require("./date.js"); console.log(date.getTime());&#125;,1000); 执行 12345$ node 12-\$require-cache.js 150093764976915009376497691500937649769^C 本文结束，感谢阅读。 本文作者：melody0z 本文链接：https://melodyvoid.github.io/Node/modular-structure.html 欢迎转载，转载请注明文本链接]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[路径问题]]></title>
    <url>%2FNode%2Frouting-problem.html</url>
    <content type="text"><![CDATA[目录结构 |— /module ​ |— path.js |— index.js |— a.txt module/path.js 123456789const fs = require("fs");fs.readFile("../a.txt",(err,data) =&gt; &#123; if(err) &#123; console.log(err); &#125;else&#123; console.log(data); &#125;&#125;); index.js 1const foo = require("./module/path"); 然后我们执行index.js 12$ node 04-path.js &#123; Error: ENOENT: no such file or directory, open '../a.txt' errno: -2, code: 'ENOENT', syscall: 'open', path: '../a.txt' &#125; 原因是没有找到。咦？路径没有错啊，path.js上级目录下面的a.txt。 其实原因是这样的。在node执行的时候，是会以入口文件为基准，去找文件。我们的入口文件是index.js。那么a.txt是和它平级，在module/path.js中写成./a.txt就可以了，我们试一下。 12345678910 const fs = require("fs"); - fs.readFile("../a.txt",(err,data) =&gt; &#123;+ fs.readFile("./a.txt",(err,data) =&gt; &#123; if(err) &#123; console.log(err); &#125;else&#123; console.log(data); &#125; &#125;); 在执行一下index.js 12$ node index.js &lt;Buffer 53 75 6e 20 4a 75 6c 20 32 33 20 32 30 31 37 20 32 31 3a 30 34 3a 31 38 20 47 4d 54 2b 30 38 30 30 20 28 43 53 54 29&gt; 可以读出来了，但是是buffer，我们需要toString一下 12345678910 const fs = require("fs"); fs.readFile("./a.txt",(err,data) =&gt; &#123; if(err) &#123; console.log(err); &#125;else&#123;- console.log(data);+ console.log(data.toString()); &#125; &#125;); 再执行一下index.js 12$ node index.js Sun Jul 23 2017 21:04:18 GMT+0800 (CST) 我们成功了！but，有一个问题，我们试着想一下，我们在阅读module/path.js的代码时，看到./a.txt会误以为在module文件夹下有a.txt(实际上没有)。所以我们要引出下面的东西 __dirname 获取当前脚本所在路径 __filename 获取文件路径 module/path.js 1234567891011121314+ //获取当前脚本所在路径+ console.log(__dirname);+ //获取文件路径+ console.log(__filename); const fs = require("fs"); fs.readFile("./a.txt",(err,data) =&gt; &#123; if(err) &#123; console.log(err); &#125;else&#123; console.log(data.toString()); &#125; &#125;); 执行index.js 1234$ node index.js /Users/melody0z/github/nodejs/second/module/Users/melody0z/github/nodejs/second/module/path.jsSun Jul 23 2017 21:04:18 GMT+0800 (CST) 我们发现上面的两个东西可以获取绝对路径 所以我们在文件操作的时候路径都必须是绝对路径（物理路径） 123456789 const fs = require("fs");- fs.readFile("./a.txt",(err,data) =&gt; &#123;+ fs.readFile(__dirname + "/../a.txt",(err,data) =&gt; &#123; if(err) &#123; console.log(err); &#125;else&#123; console.log(data.toString()); &#125; &#125;); 这样看起来是不是舒服多了 注意点： __dirname可以获取当前文件所在目录的完整路径；在模块全局环境有效，但在REPL环境无效 __filename可以用来获取当前文件的完整路径；在模块全局环境有效，但在REPL环境无效 本文结束，感谢阅读。 本文作者：melody0z 本文链接：https://melodyvoid.github.io/Node/routing-problem.html 欢迎转载，转载请注明文本链接]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[验证node单线程]]></title>
    <url>%2FNode%2Fverify-node-single-thread.html</url>
    <content type="text"><![CDATA[现象我们由一段代码入手(文件名：02.js); 123456789101112131415const http = require("http");let count = 0;const server = http.createServer((req,res) =&gt; &#123; res.writeHead(200,&#123;"Content-Type":"text/html;charset=UTF-8"&#125;); res.write(`你是第$&#123;count++&#125;个访问用户`); res.end();&#125;);server.listen(3000,(err) =&gt; &#123; //出现错误的情况就是端口被占用 if(err) throw err; console.log("server is running at http://localhost:3000/")&#125;); 然后我们执行它 12$ node 02.js server is running at http://localhost:3000/ 打开浏览器 我们能看到“你是第0个访问用户”，当我们刷新的时候，我们发现… 问题1：count并没有重新归零 问题2：count直接由0变到了2 我们来看下问题1，count并没有重新归零，说明我们在刷新页面的时候并不是重新执行了整个脚本，而是只执行了server里的代码 12345const server = http.createServer((req,res) =&gt; &#123; res.writeHead(200,&#123;"Content-Type":"text/html;charset=UTF-8"&#125;); res.write(`你是第$&#123;count++&#125;个访问用户`); res.end();&#125;); 所以count不会重新归零，而是执行里面的count++，但是…应该由0变为1啊。 好了，我们来看第二个问题，为什么直接从0变为2，我们打开调试工具 我们发现，刷新页面的时候会发送两个请求，一个是localhost，一个是favicon.ico，所以 1res.write(`你是第$&#123;count++&#125;个访问用户`); 会执行两次，然后我们就会看见0，2，4，6… 解决办法 做一个判断 if(req.url === &quot;/favicon.ico&quot;) return; 12345678910111213141516const http = require("http");let count = 0;const server = http.createServer((req,res) =&gt; &#123; if(req.url === "/favicon.ico") return; //如果请求的是favicon.ico我们就return掉 res.writeHead(200,&#123;"Content-Type":"text/html;charset=UTF-8"&#125;); res.write(`你是第$&#123;count++&#125;个访问用户`); res.end();&#125;);server.listen(3000,(err) =&gt; &#123; //出现错误的情况就是端口被占用 if(err) throw err; console.log("server is running at http://localhost:3000/")&#125;); 单线程我们再把代码修改一下 1234567891011121314151617181920 const http = require("http"); let count = 0; const server = http.createServer((req,res) =&gt; &#123; if(req.url === "/favicon.ico") return; res.writeHead(200,&#123;"Content-Type":"text/html;charset=UTF-8"&#125;); res.write(`你是第$&#123;count++&#125;个访问用户`);+ //如果count计数到5的话，我们就让它阻塞+ if(count === 5)&#123;+ while(true) &#123; &#125;+ &#125; res.end(); &#125;); server.listen(3000,(err) =&gt; &#123; //出现错误的情况就是端口被占用 if(err) throw err; console.log("server is running at http://localhost:3000/") &#125;); 我们再来执行它，然后刷新刷新，count计数到5的时候就会阻塞，我们看 这是，我们重新开一个页面，输入http://localhost:3000 我们发现新开的页面也是阻塞的，为什么呢？就是因为node是单线程，一个地方阻塞了，就都阻塞了。 本文结束，感谢阅读。 本文作者：melody0z 本文链接：https://melodyvoid.github.io/Node/verify-node-single-thread.html 欢迎转载，转载请注明文本链接]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0723]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0723.html</url>
    <content type="text"><![CDATA[必备句型​ Oh,boy! 天哪 I think I have a crush on her. 我觉得我是喜欢上她了 ​ 场景对话​ A: Oh,boy! Look at the girl over there, she’s gorgeous. B: Hey,are you okay? A: I think I have a cruse on her. B: Excuse me? A: I guess that’s love at first sight. ​ 参考译文​ A: 天哪！快看那边的那个女孩，太漂亮了。 B: 嗯，你还好吧？ A: 我觉得我是喜欢上她了。 B: 什么？ A: 我想这就是一见钟情吧。 ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node事件驱动模型]]></title>
    <url>%2FNode%2Fnode-event-driven-model.html</url>
    <content type="text"><![CDATA[Event driven（事件驱动）Node采用的是事件驱动的方式，通过事件驱动的方式处理请求时无需为每一个请求创建额外的线程。在事件驱动模型中，每一个I/O操作都会被添加到事件队列中，主线程循环地处理队列上的工作任务，当执行过程中遇到阻塞（读取文件、查询数据库）时，线程不会停下来等待结果，而是留下一个处理结果的回调函数，转而继续执行队列中的下一个任务。这个传递到队列中的回调函数在阻塞任务运行结束后才被线程调用。 主线程的代码执行完毕就会从事件队列中读取事件，如果有就取出事件并执行相关的回调函数。事件队列事件全部执行完毕，node应用就会终止。Node对于阻塞I/O的处理在幕后使用线程池来确保工作的执行。Node从线程池中取得一个线程来执行复杂任务，而不占用主循环线程。这样就防止阻塞I/O占用空闲资源。当阻塞任务执行完毕通过添加到事件队列中的回调函数来处理接下来的工作。 Node基于事件的工作调度能很自然地将主要的调度工作限制到了一个线程，应用能很高效地处理多任务。程序每一时刻也只需管理一个工作中的任务。当必须处理阻塞I/O时，通过将这个部分的I/O控制权交给线程池中的线程，能最小地影响到应用处理事件，快速地反应web请求。 123456789101112131415161718192021222324252627const fs = require("fs");console.time("timer");//判断是否存在a.txt文件fs.stat("./a.txt",(err,stats) =&gt; &#123; if(err)&#123; console.log("文件不存在"); //不存在的话，我们就创建 fs.writeFile("./a.txt",new Date(),(err) =&gt; &#123; if(err) throw err; console.log("文件创建成功") &#125;) &#125;else &#123; //如果存在的话，先删除 fs.unlink("./a.txt",(err) =&gt; &#123; if(err) throw err; //创建 fs.writeFile("./a.txt",new Date(),(err) =&gt; &#123; if(err) throw err; console.log("文件删除后创建成功"); &#125;) &#125;) &#125;&#125;);console.timeEnd("timer"); 1234567$ node 01-event-driven.js timer: 0.444ms文件不存在文件创建成功$ node 01-event-driven.js timer: 0.427ms文件删除后创建成功 我们来看一下具体过程 本文结束，感谢阅读。 本文作者：melody0z 本文链接：https://melodyvoid.github.io/Node/node-learning-notes-01.html 欢迎转载，转载请注明文本链接]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>事件驱动模型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0722]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-072.html</url>
    <content type="text"><![CDATA[必备句型​ Let’s have a get-together tonight. 我们今晚聚会吧 How about a rain check? 换个时间行吗？ ​ 场景对话​ A: Let’s have a get-together tonight.Would you come? B: I’d love to, but I have a class at that time and I have to finish my homework.How about a rain check? ​ 参考译文​ A: 我们今晚聚会吧，你能来吗？ B: 我很想啊，但是今晚有课，还有作业要完成，换个时间行吗？ ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0721]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0721.html</url>
    <content type="text"><![CDATA[必备句型​ She had a quarrel with Tom. 她跟Tom吵架了 The course of true love never did run smoothly. 爱情路上多波折 ​ 场景对话​ A: Zoe is so upset. B: Yes, but I don’t know what’s going on with her. A: She had a quarrel with Tom. B: People say “The course of true love never did run smoothly”. ​ 参考译文​ A: Zoe心情不是很好。 B: 是的，不知道她怎么了。 A: 她跟Tom吵架了。 B: 人们说：“爱情路上多波折”。 ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node学习笔记01]]></title>
    <url>%2FNode%2Fnode-learning-notes-01.html</url>
    <content type="text"><![CDATA[Node简介什么是Node Node 就是 JavaScript 语言在服务器端的运行环境 所谓“运行环境（平台）”有两层意思： 首先，JavaScript 语言通过 Node 在服务器运行，在这个意义上，Node 有点像 JavaScript 虚拟机； 其次，Node 提供大量工具库，使得 JavaScript 语言与操作系统互动（比如读写文件、新建子进程），在这个意义上， Node 又是 JavaScript 的工具库。 重点理解 Node是一个JavaScript的运行环境（平台），不是一门语言，也不是JavaScript的框架； Node的实现结构； Node可以用来开发服务端应用程序，Web系统； 基于Node的前端工具集 Node.js的特点 Node.js® is a JavaScript runtime built on Chrome’s V8 JavaScript engine. Node.js uses an event-driven, non-blocking I/O model that makes it lightweight and efficient. Node.js’ package ecosystem, npm, is the largest ecosystem of open source libraries in the world. 单线程 事件驱动（event-driven) 非阻塞I/O（non-blocking I/O) Node命令的基本用法进入REPL(Read Eval Print Loop:交互解释器) Read：读取用户输入，解析输入了JavaScript数据结构并存储在内存中。 Eval：执行输入的数据结构 Print：输出结果 Loop：循环操作以上步骤直到用户退出 12$ node&gt; 简单的表达式运算 123$ node&gt; 2 + 46 使用变量 12345678910$ node&gt; x = 1010&gt; var y = 20undefined&gt; x + y30&gt; console.log("Hello World")Hello Worldundefined 多行表达式 123456789&gt; for(let i = 0;i &lt; 5;i++)&#123;... console.log("i:" + i);... &#125;i:0i:1i:2i:3i:4undefined ...三个点的符号是系统自动生成的，回车换行后即可，Node会自动检测是否为连续的表达式。 下划线变量 1234567891011&gt; let a = 10undefined&gt; let b = 10undefined&gt; a + b20&gt; let sum = _undefined&gt; console.log(sum)20undefined REPL命令 ctrl + c 退出当前终端 ctrl + c 按下两次 退出Node REPL .exit 退出Node REPL process.exit() 退出REPL ctrl + d 退出Node REPL up/down键 查看输入的历史命令 tab键 列出当前命令 .help 列出使用命令 .break 退出多行表达式 .clear 退出多行表达式 .save filename 保存当前的Node REPL会话到指定文件 .load filename 载入当前Node REPL会话的文件内容 执行脚本字符串1$ node -e "console.log('Hello World')" 执行脚本文件123$ node index.js$ node path/index.js$ node path/index 查看帮助1$ node --help 全局作用域成员全局对象 global： 类似于客户端JavaScript运行环境中的window process：用于获取当前的Node进程信息，一般用于获取变量之类的信息 console：Node中内置的console模块，提供操作控制台的输入输出功能，常见使用方法与客户端类似。 全局函数 setInterval(callback,millisecond) clearInterval(timer) setTimeout(callback,millisecond) clearTimeout(timer) Buffer:Class 用于操作二进制数据 异步编程异步操作 Node采用Chrome V8引擎处理JavaScript脚本，V8最大特点就是单线程运行，一次只能运行一个任务。 Node大量采用异步操作(asynchonous operation),即任务不是马上执行，而而是插在任务队列的尾部，等到前面的任务运行完后再执行。 提高代码的响应能力 回调函数的设计 对于一个函数如果需要定义回调函数： 回调函数一定作为参数的最后一个参数出现： 12function foo (name,age,callback) &#123;&#125;function bar (value,callback1,callback2)&#123;&#125; 回调函数的第一个参数默认接收错误信息，第二个参数采食真正的回调数据（便于外界获取调用的错误情况）： 1234foo("Jack",18,(error,data) =&gt; &#123; if(error) throw error; console.log(data);&#125;) Node统一约定：强调错误优先 因为之后的操作大多数都是异步的方式，无法通过try…catch捕获异常。 错误优先的回调函数，第一个参数为上一步的错误信息。 什么是异步比如说：setTimeout()、$.ajax() 异步操作回调 由于系统永远不知道用户什么时候会输入内容，所以代码不能永远停在一个地方 Node中的操作方式就是以异步回调的方式解决无状态的问题。 异步回调的问题callback hell 123456789foo1(function()&#123; foo2(function()&#123; foo3(function()&#123; foo4(function()&#123; foo5() &#125;) &#125;) &#125;)&#125;) 相比较与传统的代码： 异步事件驱动的代码不容易阅读 不容易调试 不容易维护 非阻塞I/O什么是I/O I/O：input/output 可以理解为输入到输出之间的转化过程 敲击键盘（输入）看到编辑器中多出字符（输出） 移动鼠标（输入）看到光标移动（输出） 事件驱动和非阻塞机制 Node平台将一个任务连同该任务的回调函数放到一个事件循环系统中 事件循环高效地管理系统线程池同时高效执行每一个任务 当任务执行完成过后自动执行回调函数 Node中的异步I/O 非阻塞的优势 提高代码的响应效率 充分利用单核CPU的优势 改善I/O的不可预测带来的问题 进程与线程什么是进程 每一个正在运行的应用程序都称之为进程 每一个应用程序至少有一个进程 进程是用来给应用程序提供一个运行的环境 进程是操作系统为应用程序分配资源的一个单位 什么是线程 用来执行应用程序中的代码 在一个进程内部，可以有很多线程 在一个线程内部，同时只可以干一件事 而且传统的开发方式大部分是I/O阻塞的 所以需要多线程来更好地利用硬件资源 给人带来的一种错觉：线程越多越好 本文结束，感谢阅读。 本文作者：melody0z 本文链接：https://melodyvoid.github.io/Node/node-learning-notes-01.html 欢迎转载，转载请注明文本链接]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0720]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0720.html</url>
    <content type="text"><![CDATA[必备句型​ I’ve been worried sick about you. 我担心死你了 I am totally fine. 我很好啊 ​ 场景对话​ A: I’ve been worried sick about you, where have you been? B: I am totally fine,I just went shopping with my friends. A: Well, at least you should’ve told me. B: Mom,please. I am not a kid anymore. ​ 参考译文​ A: 我担心死你了，你去哪里了？ B: 我没事啊，跟朋友出去购物了。 A: 嗯，你至少应该告诉我啊。 B: 拜托了，妈，我又不是小孩子。 ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[包装对象]]></title>
    <url>%2FJavaScript%2Fpackage-object.html</url>
    <content type="text"><![CDATA[什么是包装对象？JavaScript中只要引用了字符串（数字、布尔值也是一样的）的属性，JS就会将字符串通过调用new String(s)的方式转换成对象，这个对象继承了字符串的方法，并被用来处理属性的引用。一旦属性引用结束，这个新创建的对象就会销毁（真实实现并不一定是这样，但整个过程看起来是这样）。这个过程就叫包装对象。 我们来看段代码： 123var str = "hello";console.log(typeof str); //stringconsole.log(str.charAt(0)); //h 以上代码平淡无奇，但是我们仔细想一下，str是字符串，字符串类型的变量怎么会有方法呢？同理像number和boolean也一样，为什么基本类型的变量会有方法呢？ 原因就是包装对象，这是我们再阅读一下什么是包装对象。 1234567var str1 = new String("hello");console.log(typeof str1); //object//因为str1是object所以有方法很正常str1.charAt(0);//charAt是怎么来的呢？String.prototype.String = function()&#123;...&#125;; //当然我们如果这么写了会覆盖原生的charAt方法，这里只演示原理。console.log(str1.charAt(0)); //h 我们发现：基本类型（string、number、boolean)z这三个有对应的包装对象。null和undefined也是基本类型，但是没有对应的包装对象。 我们回过头来再看上面第一个例子： 1234var str = "hello"; //这里确实是字符串console.log(typeof str); //stringstr.charAt(0); //当字符串调用方法的时候，基本类型会找到对应的包装对象类型，然后包装对象把所有的属性和方法给了基本类型。然后包装对象消失。console.log(str.charAt(0)); //h 那么我么想要给字符串添加一个方法怎么办呢？ 1234567var str = "hello";//在原型里面添加String.prototype.lastValue = function()&#123; return this.charAt(this.length-1);&#125;;//这样我们就可以调用我们写的新方法了str.lastValue(); //o 我们再往下看 123var str = "hello";str.number = 10;console.log(str.number); //undefined; 咦？怎么是undefined？ 答案还是因为包装对象。 str是我们隐式地创建的包装对象，在使用完之后就被抛弃了。 str.number=10这时候创建一个包装对象，赋值。 执行到console.log(str.number)这句话的时候，之前的包装对象已经被抛弃，我们打点调用num的时候，又重新创建一个包装对象，所以此时这个包装对象一定没有num属性，故输出undefined。 那么我们一定要输出str.num呢？ 123var str = "hello";String.prototype.number = 10;console.log(str.number); //10 我们再看一个现象 1234var str = "hello";var str1 = new String("hello");console.log(str == str1); //trueconsole.log(str === str1); //false 不严格相等，一个是字符串类型，一个是对象类型，必然不全等 本文结束，感谢阅读。 本文作者：melody0z 本文链接：https://melodyvoid/JavaScript/package-object.html 欢迎转载，转载请注明文本链接]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0719]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0719.html</url>
    <content type="text"><![CDATA[必备句型​ May I speak to Zoe, please? 可以请Zoe接听电话吗？ She’s tied up at the moment. 她现在走不开 ​ 场景对话​ A: May I speak to Zoe, please? B: I’m sorry, she’s tied up at the moment. Would you like to leave a message? A: No, Thank you. I’ll call her later. ​ 参考译文​ A: 可以请Zoe接听电话吗？ B: 抱歉，她现在走不开。你要留个口信吗？ A: 不用了，谢谢。我待会儿再打给她。 ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0718]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0718.html</url>
    <content type="text"><![CDATA[必备句型​ You look restless. 看你一副坐立不安的样子 I’d like to stay and talk longer, but I really do have to run. 我很想再多聊一会儿，不过我真的很赶时间。 ​ 场景对话​ A: You look restless. Do you have to be somewhere, or am I just boring you? B: I’d like to stay and talk longer, but I really do have to run. I have to be at a meeting at around noon. ​ 参考译文​ A: 看你一副坐立不安的样子，是不是还要去别处，或者是我让你觉得无聊了呢？ B: 我很想再多聊一会儿，不过我真的很赶时间，中午时候还要参加一个会议。 ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[创建对象的几种方式的优缺点对比]]></title>
    <url>%2FJavaScript%2Fcontrast-the-advantages-and-disadvantages-of-several-ways-of-creating-objects.html</url>
    <content type="text"><![CDATA[工厂模式1234567891011function createObj(name, gender)&#123; var obj = new Object(); obj.name = name; obj.gender = gender; obj.sayName = function()&#123; alert(this.name); &#125; return obj;&#125;var person = createObj("Jack", "female"); 缺点： 无法无法确定对象的类型（因为都是Object） 创建的多个对象之间没有关联。 构造函数模式123456789function createObj(name, gender)&#123; this.name = name; this.gender = gender; this.sayName = function()&#123; alert(this.name); &#125;&#125;var person = new createObj("Jack", "female"); 缺点： 多个实例重复创建方法，无法共享。 多个实例都有sayName方法，但均不是同一个Function的实例。 原型方法123456789function createObj()&#123;&#125;createObj.prototype.name = "Jack";createObj.prototype.gender = "female";createObj.prototype.sayName = function()&#123; alert(this.name);&#125;var person = new createObj(); 缺点： 无法传入参数，不能初始化属性值。 如果包含引用类型的值时，改变其中一个实例的值，则会在所有实例中体现。 组合式（构造函数+原型方法）推荐使用1234567891011function createObj(name, gender)&#123; this.name = name; this.gender = gender; if(typeof this.sayName != 'function')&#123; createObj.prototype.sayName = function()&#123; alert(this.name); &#125; &#125;&#125;var person = new createObj("Jack", "female"); 说明： if语句中只会调用一次，就是在碰到第一个实例调用方法时会执。此后所有实例都会共享该方法。在动态原型方法下，不能使用对象字面量重写原型。 寄生构造函数寄生构造函数,其实就是工厂模式+构造函数模式,这种模式比较通用,但不能确定对象关系,所以,在可以使用之前所说的模式时,不建议使用此模式 ​ 在什么情况下使用寄生构造函数比较合适呢?假设要创建一个具有额外方法的引用类型,例如直接String.prototype.addstring,可以通过寄生构造的方式来添加. 123456789function myString(string)&#123; var str = new String(string); str.addstring = function () &#123; return this + ",被添加了"; &#125;; return str;&#125;var box = new myString("lee");alert(box.addstring()); 稳妥构造函数在一些安全环境中,比如禁止使用this和new,这里的this是构造函数里不使用this,这里的new是在外部实例化构造函数时不使用new,这种创建方式叫做稳妥构造函数. 123456789function A(name,age)&#123; var obj = new Object(); obj.showName = function () &#123; return name; &#125;; return obj;&#125;var a = A("Jack",18);alert(a.showName()); 本文结束，感谢阅读。 本文作者：melody0z 本文链接：https://melodyvoid.github.io/JavaScript/contrast-the-advantages-and-disadvantages-of-several-ways-of-creating-objects.html 欢迎转载，转载请注明文本链接]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0717]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0717.html</url>
    <content type="text"><![CDATA[必备句型​ I feel dizzy. 我感到晕晕的 Poor thing. 好可怜啊 ​ 场景对话​ A: I feel dizzy. I have a fever of 38℃ B: Poor thing! Go back to bed and get some rest. I’ll make some soup for you. A: That’s sweet of you. ​ 参考译文​ A: 我感到晕晕的，发烧了，38度。 B: 好可怜啊，回床上睡一会儿吧，我给你做点儿汤。 A: 谢谢你。 ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0716]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0716.html</url>
    <content type="text"><![CDATA[必备句型​ It seems that everybody likes her. 好像每个人都很喜欢她 She really turns me off. 她真的使我厌恶 ​ 场景对话​ A: That girl is so pretty, it seems that everybody likes her. B: I don’t really think so. A: How come? B: She’s too chatty, and she really turns me off. ​ 参考译文​ A: 那个女孩真好看，好像每个人都很喜欢她。 B: 我不这么想。 A: 为什么？ B: 她太啰嗦了，真的让我很讨厌。 ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0715]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0715.html</url>
    <content type="text"><![CDATA[必备句型​ I got stuck in traffic. 我遇上堵车了 Don’t beat around the bush. 别拐弯抹角 ​ 场景对话​ A: I’ve been waiting for an hour, where have you been? B: Sorry, I’m late. I got stuck in traffic. A: Okay, tell me exactly what Tom said. Don’t beat around the bush.Get to the point. ​ 参考译文​ A: 我已经等上一个小时了，你去哪里了？ B: 不好意思，遇上堵车了。 A: 好吧，告诉我Tom说什么了。不要拐弯抹角，直接说重点吧。 ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0714]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0714.html</url>
    <content type="text"><![CDATA[必备句型​ Don’t get me wrong. 请不要误会我的意思 You have to admit that he is not very responsible. 你也得承认他不是很负责任 ​ 场景对话​ A: Don’t get me wrong. I think Tom is a very nice person, but you have to admit that he is not very responsible. B: I guess you are right. He’s got a lot of growing up to do. ​ 参考译文​ A: 请不要误会我的意思。我任务Tom是个很好的人，不过你也得承认他不是很负责任。 B: 你说的不错，他要长大还得学习很多东西。 ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0713]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0713.html</url>
    <content type="text"><![CDATA[必备句型​ Got it ? 明白了吗？ Let me explain this one more time. 让我再解释一次 ​ 场景对话​ A: Got it ? B: Sorry, I still don’t understand. A: Okay, let me explain this one more time. I don’t wanna go out because I don’t like hanging out with Tom. B: Alright, I got it. ​ 参考译文​ A: 明白了吗？ B: 不好意思，我还是不理解。 A: 好吧，我再解释一下，wo’bu’xiang我不想出去，因为我不想跟Tom一起出去逛。 B: 好吧，知道了。 ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0712]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0712.html</url>
    <content type="text"><![CDATA[必备句型​ I’ll never forgive myself. 我永远不能原谅我自己 How can I make it up to you. 我要怎样才能补偿 ​ 场景对话​ A: It’s all my fault. I’ll never forgive myself. B: Don’t say that. We wouldn’t have known that. A: How can I make it up to you? B: You can’t have to do that. ​ 参考译文​ A: 都是我的错，我永远不能原谅自己。 B: 别那么说，我们都无法未卜先知。 A: 我要怎样才能补偿你？ B: 不用啦。 ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0711]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-071.html</url>
    <content type="text"><![CDATA[必备句型​ Are you fond of reading? 你喜欢读书吗？ I like to read all kinds of books. 什么书我都喜欢看 ​ 场景对话​ A: Are you fond of reading? B: Yes, I am. Books can enrich your mind. A: Exactly, what kind of books do you like to read most? B: I like to read all kinds of books. ​ 参考译文​ A: 你喜欢读书吗？ B: 喜欢啊，书籍能丰富你的思想。 A: 确实，你最喜欢读哪种书？ B: 什么书我都喜欢看。 ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0710]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0710.html</url>
    <content type="text"><![CDATA[必备句型​ I dreamed to be a pliot, but I didn’t make it come true. 我曾梦想做一名飞行员，不过我没有实现儿时的梦想 I’m trying my best to learn English. 现在我努力学英文 ​ 场景对话​ A: Hey, did you have a dream when you were a little boy ? B: Of course I did. I dreamed to be a pliot, but I didn’t make it come true. A: Okay, so. How about now? B: Now I’m trying my best to learn English, and I want to be an interpreter some day. ​ 参考译文​ A: 嘿，你小的时候有过什么梦想吗？ B: 当然有啦，我曾梦想过当一名飞行员，不过我没有实现儿时的梦想。 A: 嗯，那现在呢？ B: 现在我在努力学英文，我想成文一名翻译。 ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0708]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0708.html</url>
    <content type="text"><![CDATA[必备句型​ let me explain one more time. 再让我解释一回 I am out of patience. 我忍无可忍了 ​ 场景对话​ A: Please, let me explain one more time. B: Sorry, I am out of patience. A: Why are you so angry? B: I don’t wanna talk to you, I’ve had enough! ​ 参考译文​ A: 求求你，再让我解释一回。 B: 对不起，我忍无可忍了。 A: 你干嘛这么生气？ B: 我不想跟你讲话，我真的受够了。 ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0707]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0707.html</url>
    <content type="text"><![CDATA[必备句型​ Are you satisfied? 你满意吗？ I have to say I am not photogenic at all. 我不得不说，我确实一点儿也不上相啊。 ​ 场景对话​ A: Say cheese. B: Cheese.Okay? A: Yes, have a look. Are you satisfied? B: Oh, I have to say I am not photogentic at al. I just don’t know how to smile. A: Would you like another one? ​ 参考译文​ A: 说“茄子”。 B: 茄子，照好了吗？ A: 是的，来看一眼吧。你满意吗？ B: 哦，我不得不说，我确定一点儿也不上相啊，我就是不知道该怎么微笑。 A: 还想要再照一张吗？ ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0706]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0706.html</url>
    <content type="text"><![CDATA[必备句型​ I don’t like horror movies at all. 我一点儿都不喜欢恐怖片 I am really into his British accent. 我太喜欢他的英国口音了 ​ 场景对话​ A: You like horror movies, don’t you ? B: No, I don’t. I don’t like horror movies at all. I like comedy movies. A: Who is your favorite actor? B: Hugh Grant, I am really into his British accent. 参考译文​ A: 你喜欢恐怖片，是吗？ B: 不，我不喜欢，我一点儿都不喜欢恐怖片，我喜欢喜剧片。 A: 你最喜欢的男演员是谁？ B：休 格兰特。我太喜欢他的英国口音了。 ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0705]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0705.html</url>
    <content type="text"><![CDATA[必备句型​ Are you good at singing ? 你唱歌拿手吗？ I’m a tone-deaf, but I like singing. 我五音不全，但是我喜欢唱歌 ​ 场景对话​ A: Are you good at singing ? B: No, I’m a tone-deaf, but I like singing. A: Okay! Let’s go to karaoke. B: My singing is out of tune. A: Oh, come on. It’s just entertainment. ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0704]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0704.html</url>
    <content type="text"><![CDATA[必备句型​ You are not supposed to smoke here. 你不能在这里吸烟 I am a heavy smoker. 我是个老烟民 ​ 场景对话​ A: Excuse me sir. You are not supposed to smoke here. B: Why not? A: Your seat is in the non-smoking section. So, you can’t smoke here. B: I am a heavy smoker, may I change my seat? ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0703]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0703.html</url>
    <content type="text"><![CDATA[必备句型​ Honesty is very important to me. 诚实对我很重要 The problem is that… 问题是… ​ 场景对话​ A:I don’t like to make friends with people who aren’t honest.Honesty is very important to me. B:I think it’s important to most people. The problem is that you can usually only find out if someone is honest by getting to know them. ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0701]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0701.html</url>
    <content type="text"><![CDATA[必备句型 How come? 为什么？ Don’t judge a book by it’s cover. 不要以貌取人 场景对话​ A:Hey,Look at the man over there,he’s definitely not a good person. B:How come? you don’t even know him. A:I just feel that way. B:Hey!Don’t judeg a book by it’s cover. ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0630]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0630.html</url>
    <content type="text"><![CDATA[必备句型​ I shouldn’t have yelled at you in front of everyone. 我不该在大家面前对你大吼 I don’t know what happened to me. 我不知道我昨天是怎么了 ​ 场景对话​ A:Hey,Bob.I’m so sorry about yesterday.I shouldn’t have yelled at you in front of everyone. B:Don’t worry about it. A:I don’t know what happened to me.I just lost it. B:It’s okay. ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0629]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0629.html</url>
    <content type="text"><![CDATA[必备句型​ You have to finish your dinner before you leave the table. 你离开饭桌之前必须把饭吃完 I’m stuffed. 我吃得太饱了 ​ 场景对话​ A:You have to finish your dinner before you leave the table. B:But,mom.I can’t eat anymore. A:What’s the matter? B:I ate some cookies before we had dinner.I’m stuffed. 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0628]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0628.html</url>
    <content type="text"><![CDATA[必备句型​ You’d better get up or you’ll be late. 你最好起床，否则你要迟到了 Rise and shine,sleepyhead. 贪睡鬼，起床啦 ​ 场景对话​ A:Hey,Bob.Weak up! B:Do I have to get up now? A:You’d better get up or you’ll be late. B:What are you talking about?The alarm hasn’t even gone off yet. A:It went off 30 minutes ago.Rise and shine,sleepyhead. 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0627]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0627.html</url>
    <content type="text"><![CDATA[必备句型​ Can I talk to you for a minute? 我能跟你谈一会儿吗？ It’s out of the question. 不可能 ​ 场景对话​ A:Mom,can I talk to you for a minute? B:Sure,what’s wrong? A:My best friend is going to throw a party tonight,can I stay out all night with my friends? B:No way. A:We’ll be careful. B:It’s out of the question. 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0625]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0625.html</url>
    <content type="text"><![CDATA[必备句型​ I’ve been so stressed these days. 我这几天压力很大 I have no idea what I should major in. 我不知道学什么专业 ​ 场景对话​ A:I’ve been so stressed these days. B:What’s wrong?Are you okay? A:I haven’t decided which college I should go to.I have no idea whta I should major in. B:Don’t worry.You still have time to decide. ## 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0624]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0624.html</url>
    <content type="text"><![CDATA[必备句型​ My back is sore and my meck hurts. 我的背很酸，脖子也疼 I was always absent-minded in the class. 我在课上走神儿了 ​ 场景对话​ A:Finally the class is over. B:Oh,I am so tired.My back is sore and my neck hurts. A:That’s normal.You have been sitting for three hours,with your attention highly concontrated. B:That’s not true.I was always absent-minded in the class. 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0623]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0623.html</url>
    <content type="text"><![CDATA[必备句型​ Why are you asking me this strange question? 你干嘛问我这么奇怪的问题？ I think IQ matters more. 我觉得智商更重要一点 #### 场景对话​ A:Hey,Bob,In your opinion,which one is more important,IQ or EQ? B:Why are you asking me this strange question? A:Just asking. B:Well,I Think IQ matters more,but it won’t work without EQ. ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0622]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-062.html</url>
    <content type="text"><![CDATA[必备句型​ I really wish I hadn’t done it. 我真希望我没那么做 What on earth are you talking about? 你究竟在说什么？ ​ 场景对话​ A:Hey,Bob.You look unhappy.What’s wrong? B:Oh,Alex,I mad e a big mistake A:What happened? B:I really wish I hadn’t done it. A:What on earth are you talking about? B:I got caught cheating.I feel so ashamed.The teacher saw me and told me I failed. ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0621]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0621.html</url>
    <content type="text"><![CDATA[必备句型​ Why on earth are you waning to learn a new language now? 你到底为什么学习一门新语言？ It’s never too late to learn. 活到老，学到老。 ​ 场景对话​ A:Hey,What are you up to? B:I’m learning English. A:Why on earth are you wanting to learn a new language now? B:It’s never too late to learn,you never know when these things will come into use. 黑体表示连读 ​斜体表示弱读 Why on earth did you do?你到底做了什么？ ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
</search>