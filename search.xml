<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[文件写入]]></title>
    <url>%2FNode%2Ffile-write.html</url>
    <content type="text"><![CDATA[我们来看一下如何写一个文件。 创建19-writeFile.js 首先，先引入fs模块和path模块 12const fs = require("fs");const path = require("path"); 写入文件一共有三种方式， 异步写入 fs.writeFile() 同步写入 fs.writeFileSync() 以流的方式写入 fs.createWriteStream() ​ 一、fs.writeFile() 123456789101112const fs = require("fs");const path = require("path");const filename = path.join(__dirname,"./demo.txt");fs.writeFile(filename,&#123;name:"Jack"&#125;,(err) =&gt; &#123; if(err)&#123; console.log("error"); &#125;else&#123; console.log("success"); &#125;&#125;); fs.writeFile()的第二个参数是类型值，可以是any，我们刚写入了一个对象，看看会是什么结果。我们执行一下 12$ node 19-writeFile.js success 写入成功，我们看看demo.txt里是什么 1[object Object] 我们可以发现，写入的内容就是object.toString()过后的结果。 那么怎么才能达到我们想要的结果呢？ 答案是用JSON.stringify()把对象转换为JSON（序列化） JSON.stringify() =&gt; 序列化 JSON.parse() =&gt; 反序列化 我们修改一下上面的代码 123456789101112const fs = require("fs");const path = require("path");const filename = path.join(__dirname,"./demo.txt");fs.writeFile(filename,JSON.stringify(&#123;name:"Jack"&#125;),(err) =&gt; &#123; if(err)&#123; console.log("error"); &#125;else&#123; console.log("success"); &#125;&#125;); 再来执行一下。我们看到demo.txt是如下结果 1&#123;&quot;name&quot;:&quot;Jack&quot;&#125; 什么情况会出现写文件错误呢？ 意外错误 文件权限问题 文件夹找不到（不会自动创建文件夹） 二、fs.writeFileSync() 123456789const fs = require("fs");const path = require("path");const filename = path.join(__dirname,"./demo.txt");try&#123; fs.writeFileSync(filename,JSON.stringify(&#123;name:"Mary"&#125;));&#125;catch (e)&#123; console.log(e)&#125; 执行过后，demo.txt里的内容变为 1&#123;&quot;name&quot;:&quot;Mary&quot;&#125; 三、fs.createWriteStream() 12345678910const fs = require("fs");const path = require("path");const filename = path.join(__dirname,"./demo.txt");let writeStream = fs.createWriteStream(filename);writeStream.write("Hello",(err) =&gt; &#123; if (err) throw err; console.log("写入成功")&#125;); 执行过后，demo.txt里的内容变为 1Hello 以上就是写入文件的三种方式。 but，我们发现了一个问题，就是文件写入默认是会覆盖之前的内容的，那么怎么才能不覆盖呢？好，我们引出下面的API，fs.appendFile(),用法和上面的一样。 123456789101112const fs = require("fs");const path = require("path");const filename = path.join(__dirname,"./demo.txt");fs.appendFile(filename,&#123;name:"Jack"&#125;,(err) =&gt; &#123; if(err)&#123; console.log("error"); &#125;else&#123; console.log("success"); &#125;&#125;); 执行本代码过后，demo.txt里的内容变为了 1Hello&#123;&quot;name&quot;:&quot;Jack&quot;&#125; 本文结束，感谢阅读。 本文作者：melody0z 本文链接：https://melodyvoid/Node/file-write.html 欢迎转载，转载请注明文本链接]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>文件写入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node学习笔记02]]></title>
    <url>%2FNode%2Fnode-learning-notes-02.html</url>
    <content type="text"><![CDATA[核心模块和对象核心模块的意义 如果只是在服务器运行JavaScript代码，意义并不大，因为无法实现任何功能（读写文件，访问网络）。 Node的用处在于它本身还提供的一系列功能模块，用于与操作系统互动。 这些核心的功能模块在Node中内置。 内置模块： path: 处理文件路径 fs: 操作（CRUD）文件系统 CRUD—增加（Create）、读取查询（Retrieve)、更新（Update）和删除（Delete） child_process: 新建子进程 util: 提供一系列实用小工具 http: 提供HTTP服务器功能 url: 用于解析URL querystring: 解析URL中的查询字符串 crypto: 提供加密和解密功能 …… 包的概念什么是包 由于Node是一套轻内核的平台，虽然提供了一系列的内置模块，但是不足以满足开发者的需求，于是乎出现了包（package）的概念。 与核心模块类似，就是将一些预先设计好的功能或者API封装到一个文件夹，提供给开发者使用 包的加载机制 id：包名的情况：require(“http”) 现在系统核心（优先级最高）的模块中找（以后不要创建一些和现有的包重名的包） 然后再到当前项目中node_modules目录中找 如何管理那么多的包 由于Node本身并没有太多的功能性API，所以市面上涌现出大量的第三方人员开发出来的Package 包的生态圈一旦繁荣起来，就必须有工具去代替人脑或者文档的方式管理 NPMNPM概述Node Package Manager 随着时间的发展，NPM出现了两层概念： 一层含义是Node的开放式模块登记和管理系统，也可以说是一个生态圈，一个社区 另一层含义是Node默认的模块管理器，是一个命令行下的软件，用来安装和管理Node模块 安装NPM NPM不需要单独安装，默认在安装Node的时候，会连带一起安装NPM。 但是，Node附带的NPM可能不是最新版本，最好用下面的命令，更新到最新版本 npm install npm -g 默认安装到当前系统Node所在目录下。 常用NPM命令 npm config npm init npm search npm info npm install npm uninstall npm list npm outdated npm update npm run npm cache 文件系统操作相关模块 fs：基础的文件操作API path：提供和路径相关的操作API readline：用于读取大文本文件，一行一行读 fs-extra(第三方) https://www.npmjs.com/package/fs-extra 路径操作模块（path) 在文件操作的过程中，都“必须”使用物理路径（绝对路径） path模块提供了一系列一系列与路径相关的API path.join([p1][,p2]…) =&gt;连接多个路径 path.basename(p,ext) =&gt;获取文件名 path.dirname(p) =&gt;获取文件夹路径 path.extname(p) =&gt;获取文件扩展名 path.format(obj) 和path.parse(p) 一个是格式化对象为字符串，一个是将字符串解析为对象 path.relative(from,to) =&gt; 获取从from到to的相对路径。 同步或异步调用 fs模块对文件的几乎所有操作都有同步和异步两种形式 例如：readFile() 和readFileSync() 区别： 同步调用会阻塞代码的执行，异步则不会 异步调用会将读取任务下达到任务队列，知道任务执行完成才会回调 异常处理方面，同步必须使用try…catch方式，异步可以通过回调函数的第一个参数（错误优先） 文件读取 异步文件读取 fs.readFile(file[,option],callback(err,data)) 同步文件读取 fs.readFileSync(file[,option]) 文件流的方式读取 fs.createReadStream(path[,options]) readline模块逐行读取文本12345678const readline = require("readline");const fs = require("fs");const rl = readline.createInterface(&#123;input:fs.createReadStream("sample.txt")&#125;);rl.on("line",(line) =&gt; &#123; console.log("Line from file:",line);&#125;); 文件写入 确保操作没有额外的问题，一定使用绝对路径的方式 异步文件写入 fs.writeFile(file,data[,option],callback(err)) 同步文件写入 fs.writeFileSync(file,data[,option]) 流式文件写入 fs.createWriteStream(path[,option]) 默认写入操作是覆盖源文件 异步追加 fs.appendFile(file,data[,option],callback(err)) 同步追加 fs.appendFileSync(file,data[,options]) 其他文件操作 获取文件信息 fs.stat(path,callback(err,stats)) fs.statSync(path) =&gt;返回一个fs.stats实例 移动文件 fs.rename(oldPath,newPath) 重命名文件或目录 fs.rename(oldPath,newPath,callback) fs.renameSync(oldPath,newPath) 删除文件 fs.unlink(path,callback(err)) fs.unlinkSync(path) 目录操作 创建一个目录 fs.mkdir(path[,model],callback) fs.mkdirSync(path[,model]) 删除一个空目录 fs.rmdir(path,callback) fs.rmdirSync(path) 读取一个目录 fs.readdir(path,callback(err,files)) fs.readdirSync(path) =&gt; 返回files 监视文件 监视文件变化 fs.watchFile(filename[,options],listener(curr,prev)) options:{persistent,interval} fs.watch(filename[,options][,listener]) 本文结束，感谢阅读。 本文作者：melody0z 本文链接：https://melodyvoid/Node/node-learning-notes-02.html 欢迎转载，转载请注明文本链接]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0727]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0727.html</url>
    <content type="text"><![CDATA[必备句型​ Mind your own business. 管好你自己的事 What do you mean by saying so? 你这样说是什么意思？ ​ 场景对话​ A: I still don’t understand, why did you do that? B: It’s not what you think. Mind your own business. A: What do you mean by saying so? I was just trying to help. ​ 参考译文​ A: 我还是不明白，你为什么要那样做？ B: 不是你想的那样，管好你自己的事。 A: 你这样说是什么意思？我只是想帮忙。 ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[以文件流的方式读取文件内容]]></title>
    <url>%2FNode%2Freads-file-contents-in-a-file-stream.html</url>
    <content type="text"><![CDATA[目录结构 |— 16.createStream.js |— blood.lrc 12345678910111213141516171819const fs = require("fs");const path = require("path");const iconv = require("iconv-lite");const filename = path.join(__dirname,"./blood.lrc");//创建一个文件读取流let stream = fs.createReadStream(filename);//让文件流通过iconv过滤编码stream = stream.pipe(iconv.decodeStream("gbk"));let content = "";stream.on("data",(chunk) =&gt; &#123; content += chunk;&#125;);//读取结束stream.on("end",() =&gt; &#123; console.log(content);&#125;) 我们来执行一下它 1234567$ node 16-createStream.js [ti:血染的风采][ar:黄耀明]...中间省略[03:19.42] 共和国的旗帜上有我们血染的风采[03:25.51] * * *[03:32.98] ---End--- 我们尝试着让歌词滚动显示 |— 17-showLyric.js 123456789101112131415161718192021222324252627282930313233const fs = require("fs");const path = require("path");const iconv = require("iconv-lite");const filename = path.join(__dirname,"./blood.lrc");fs.readFile(filename,(err,data) =&gt; &#123; if(err) throw err; let lines = iconv.decode(data,"gbk").split("\n"); //[00:32.67] 也许我告别 将不再回来 let regexp = /\[(\d&#123;2&#125;):(\d&#123;2&#125;)\.(\d&#123;2&#125;)]\s(.+)/; let start = new Date().getTime(); //遍历 lines.forEach((line) =&gt; &#123; // [00:32.67] 也许我告别 将不再回来 let matches = regexp.exec(line); if(matches)&#123; let min = matches[0]; let sec = parseFloat(matches[2]); let ms = parseFloat(matches[3]); let lyric = matches[4]; let time = min * 60 * 1000 + sec * 1000 + ms; //当前歌词不是立即执行，由于下达任务的时刻不同我们要设置时间偏移量 let offset = new Date().getTime(); setTimeout(() =&gt; &#123; console.log(lyric) &#125;,time - offset); &#125;else&#123; //不是一句歌词 console.log(line); &#125; &#125;)&#125;) 执行16.showLyric.js 12345678910$ node 17-showLyric.js [ti:血染的风采][ar:黄耀明][al:人山人海][offset:500][00:55.04]中文歌词库 www.CnLyric.com歌曲：血染的风采歌手：黄耀明^C 我们成功了。 我们以上拆分歌词是用split(&quot;\n&quot;)拆分成数组，然后再遍历每一句这样做的。然而node给我们提供了一个模块叫做readline.我们下面用readline模块完成同样的业务。 18-readline.js 12345678910111213141516171819202122232425262728293031//readline实现一行一行读取歌词const fs = require("fs");const path = require("path");const iconv = require("iconv-lite");const readline = require("readline");const filename = path.join(__dirname,"./blood");const readStream = fs.createReadStream(filename) .pipe(iconv.decodeStream("gbk"));let rl = readline.createInterface(&#123;input:readStream&#125;);let regexp = /\[(\d&#123;2&#125;):(\d&#123;2&#125;)\.(\d&#123;2&#125;)]\s(.+)/;let start = new Date().getTime();rl.on("line",(line) =&gt; &#123; if(matches)&#123; let min = parseFloat(matches[1]); let sec = parseFloat(matches[2]); let ms = parseFloat(matches[3]); let lyric = matches[4]; let time = min * 60 * 1000 + sec * 1000 + ms; //当前歌词不是立即执行，由于下达任务的时刻不同我们要设置时间偏移量 let offset = new Date().getTime() - start; setTimeout(() =&gt; &#123; console.log(lyric); &#125;,time - offset); &#125;else&#123; //不是一句歌词 console.log(line); &#125;&#125;) 执行18-readline.js 12345678910$ node 18-readline.js [ti:血染的风采][ar:黄耀明][al:人山人海][offset:500][00:55.04]中文歌词库 www.CnLyric.com歌曲：血染的风采歌手：黄耀明^C ​ ​ 本文结束，感谢阅读。 本文作者：melody0z 本文链接：https://melodyvoid/Node/reads-file-contents-in-a-file-stream.html 欢迎转载，转载请注明文本链接]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>文件流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编码问题]]></title>
    <url>%2FNode%2Fcoding-problem.html</url>
    <content type="text"><![CDATA[fs在读取文件的时候，会把文件读取为buffer，buffer有一个toString()方法，可以把文件转换为字符串，但是默认编码是utf8，读取编码为gbk的文件就会乱码。本文将会读取一个编码为gbk的歌词文件，下面是过程。 目录结构 |— 14-readFileSync.js |— blood.lrc 14-readFileSync.js 123456789101112//同步读取文件的内容//所有的文件操作都是基于fs模块const fs = require("fs");//无论是同步还是异步，文件操作都要使用绝对路径const path = require("path");//将文本读取到一个buffer中const buffer = fs.readFileSync(path.join(__dirname,"./blood.lrc"));//将buffer中的内容读取出来const data = buffer.toString();console.log(data); 执行14-readFileSync.js 12345678910$ node 14-readFileSync.js [ti:ѪȾ�ķ��][ar:��ҫ��][al:��ɽ�˺�][offset:500][00:01.21] ������ѪȾ�ķ��...中间省略[03:19.42] ���͹���������������ѪȾ�ķ��[03:25.51] * * *[03:32.98] ---End--- 读取出来的是乱码，为什么是乱码呢？因为编码问题，.lrc文件是gbk编码，node默认是utf8编码 为了解决编码问题，我们需要引入第三方模块 iconv-lite 在项目目录下创建package.json 1$ npm init -y 1$ npm install iconv-lite --save-dev 好了，模块安装好了之后我们就可以直接引用了 14-readFileSync.js 123456789101112 const fs = require("fs"); const path = require("path"); const buffer = fs.readFileSync(path.join(__dirname,"./blood.lrc")); - const data = buffer.toString();- console.log(data); + //我们需要引入第三方模块+ const iconv = require("iconv-lite");+ const data2 = iconv.decode(buffer,"gbk");+ console.log(data2); 执行14-readFileSync.js 123456$ node 14-readFileSync.js [ti:血染的风采][ar:黄耀明]...中间省略[03:25.51] * * *[03:32.98] ---End--- done,成功读取。 下面我们用异步的方式再来读取一下 15-readFile.js 12345678910const fs = require("fs");const path = require("path");const iconv = require("iconv-lite");const filename = path.join(__dirname,"./blood.lrc");fs.readFile(filename,(err,data) =&gt; &#123; if(err) throw err; console.log(iconv.decode(data,"gbk"));&#125;); 执行15-readFile.js 123456$ node 15-readFile.js [ti:血染的风采][ar:黄耀明]...中间省略[03:25.51] * * *[03:32.98] ---End--- 也一样读取成功。 ​ 本文结束，感谢阅读。 本文作者：melody0z 本文链接：https://melodyvoid/Node/coding-problem.html 欢迎转载，转载请注明文本链接]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>编码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0726]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0726.html</url>
    <content type="text"><![CDATA[必备句型​ This is gonna be the hottest day we’ve had so far this summer. 今夏以来这大概是最热的一天了 You can say that again. 你说的一点也没错 ​ 场景对话​ A: Oh my God. It’s so hot today. This is gonna be the hottest day we’ve had so far this summer. B: You can say that again! I’ve never suffered so much from the heat. ​ 参考译文​ A: 我的天啊，今天好热，今夏以来这大概是最热的一天了。 B: 你说的一点也没错，我还从没有经受过这么炎热的天气。 ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[path模块]]></title>
    <url>%2FNode%2Fpath-module.html</url>
    <content type="text"><![CDATA[path.basename(path[,ext])语法：path.basename(path[,ext]) path:路径 例：/Users/melody0z/github/nodejs/second/a.txt ext: 扩展名 （extension) 例：.txt 返回一个path的最后一部分，也就是文件名。 12345path.basename("/Users/melody0z/github/nodejs/second/a.txt")// a.txtpath.basename("/Users/melody0z/github/nodejs/second/a.txt",".txt");// a path.delimiter提供平台特定的路径分隔符 windows上是; POSIX上是: 12345console.log(process.env.PATH);// /usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbinconsole.log(process.env.PATH.split(path.delimiter));// [ '/usr/local/bin', '/usr/bin', '/bin', '/usr/sbin', '/sbin' ] path.dirname(path)语法：path.dirname(path) path: 路径 例如：/Users/melody0z/github/nodejs/second/a.txt 返回一个path的目录名 12path.dirname("/Users/melody0z/github/nodejs/second/a.txt")// /Users/melody0z/github/nodejs/second path.extname(path)语法：path.extname(path) path: 路径 例如：/Users/melody0z/github/nodejs/second/a.txt 返回path的扩展名，即从 path 的最后一部分中的最后一个 .（句号）字符到字符串结束。 如果 path 的最后一部分没有 . 或 path 的文件名（见 path.basename()）的第一个字符是 .，则返回一个空字符串。 1234567891011121314path.extname('index.html');// 返回: '.html'path.extname('index.coffee.md');// 返回: '.md'path.extname('index.');// 返回: '.'path.extname('index');// 返回: ''path.extname('.index');// 返回: '' path.parse(path)语法：path.parse(path) path.parse() 方法返回一个对象，对象的属性表示 path 的元素。 返回的对象有以下属性： dir root base name ext 在POSIX上： 1234567891011121314path.parse('/home/user/dir/file.txt');// 返回:// &#123; root: '/',// dir: '/home/user/dir',// base: 'file.txt',// ext: '.txt',// name: 'file' &#125;┌─────────────────────┬────────────┐│ dir │ base │├──────┬ ├──────┬─────┤│ root │ │ name │ ext │" / home/user/dir / file .txt "└──────┴──────────────┴──────┴─────┘(请无视以上字符串中的空格，它们只是为了布局) 在 Windows 上： 123456789101112131415path.parse('C:\\path\\dir\\file.txt');// 返回:// &#123; root: 'C:\\',// dir: 'C:\\path\\dir',// base: 'file.txt',// ext: '.txt',// name: 'file' &#125;┌─────────────────────┬────────────┐│ dir │ base │├──────┬ ├──────┬─────┤│ root │ │ name │ ext │" C:\ path\dir \ file .txt "└──────┴──────────────┴──────┴─────┘(请无视以上字符串中的空格，它们只是为了布局) path.format(pathObject) pathObject dir root base name ext 返回一个path字符串 path.format() 方法会从一个对象返回一个路径字符串。 与 path.parse() 相反。 当 pathObject 提供的属性有组合时，有些属性的优先级比其他的高： 如果提供了 pathObject.dir，则 pathObject.root 会被忽略 如果提供了 pathObject.base 存在，则 pathObject.ext 和 pathObject.name 会被忽略 例如，在 POSIX 上： 1234567891011121314151617181920212223242526// 如果提供了 `dir`、`root` 和 `base`，则返回 `$&#123;dir&#125;$&#123;path.sep&#125;$&#123;base&#125;`。// `root` 会被忽略。path.format(&#123; root: '/ignored', dir: '/home/user/dir', base: 'file.txt'&#125;);// 返回: '/home/user/dir/file.txt'// 如果没有指定 `dir`，则 `root` 会被使用。// 如果只提供了 `root` 或 `dir` 等于 `root`，则平台的分隔符不会被包含。// `ext` 会被忽略。path.format(&#123; root: '/', base: 'file.txt', ext: 'ignored'&#125;);// 返回: '/file.txt'// 如果没有指定 `base`，则 `name` + `ext` 会被使用。path.format(&#123; root: '/', name: 'file', ext: '.txt'&#125;);// 返回: '/file.txt' 在 Windows 上： 12345path.format(&#123; dir: 'C:\\path\\dir', base: 'file.txt'&#125;);// 返回: 'C:\\path\\dir\\file.txt' path.isAbsolute(path)path: 路径 返回一个布尔值 path.isAbsolute() 方法会判定 path 是否为一个绝对路径。 如果给定的 path 是一个长度为零的字符串，则返回 false。 例如，在 POSIX 上： 1234path.isAbsolute('/foo/bar'); // truepath.isAbsolute('/baz/..'); // truepath.isAbsolute('qux/'); // falsepath.isAbsolute('.'); // false 在 Windows 上： 1234567path.isAbsolute('//server'); // truepath.isAbsolute('\\\\server'); // truepath.isAbsolute('C:/foo/..'); // truepath.isAbsolute('C:\\foo\\..'); // truepath.isAbsolute('bar\\baz'); // falsepath.isAbsolute('bar/baz'); // falsepath.isAbsolute('.'); // false path.join([…paths])…pahts 一个路径片段的序列 返回一个完整路径字符串 path.join() 方法使用平台特定的分隔符把全部给定的 path 片段连接到一起，并规范化生成的路径。 长度为零的 path 片段会被忽略。 如果连接后的路径字符串是一个长度为零的字符串，则返回 &#39;.&#39;，表示当前工作目录。 例子： 12345path.join('/foo', 'bar', 'baz/asdf', 'quux', '..');// 返回: '/foo/bar/baz/asdf'path.join('foo', &#123;&#125;, 'bar');// 抛出 'TypeError: Path must be a string. Received &#123;&#125;' path.normalize(path)path: 路径 返回一个正常版的路径字符串 path.normalize() 方法会规范化给定的 path，并解析 &#39;..&#39; 和 &#39;.&#39; 片段。 当发现多个连续的路径分隔符时（如 POSIX 上的 / 与 Windows 上的 \ 或 /），它们会被单个的路径分隔符（POSIX 上是 /，Windows 上是 \）替换。 末尾的多个分隔符会被保留。 如果 path 是一个长度为零的字符串，则返回 &#39;.&#39;，表示当前工作目录。 例如，在 POSIX 上： 12path.normalize('/foo/bar//baz/asdf/quux/..');// 返回: '/foo/bar/baz/asdf' 在 Windows 上： 12path.normalize('C:\\temp\\\\foo\\bar\\..\\');// 返回: 'C:\\temp\\foo\\' path.relative(from,to)path.relative() 方法返回从 from 到 to 的相对路径（基于当前工作目录）。 如果 from 和 to 各自解析到同一路径（调用 path.resolve()），则返回一个长度为零的字符串。 如果 from 或 to 传入了一个长度为零的字符串，则当前工作目录会被用于代替长度为零的字符串。 例如，在 POSIX 上： 12path.relative('/data/orandea/test/aaa', '/data/orandea/impl/bbb');// 返回: '../../impl/bbb' 在 Windows 上： 12path.relative('C:\\orandea\\test\\aaa', 'C:\\orandea\\impl\\bbb');// 返回: '..\\..\\impl\\bbb' path.resolve([…paths])…paths 一个路径或路径片段的序列 返回一个绝对路径 path.resolve() 方法会把一个路径或路径片段的序列解析为一个绝对路径。 给定的路径的序列是从右往左被处理的，后面每个 path 被依次解析，直到构造完成一个绝对路径。 例如，给定的路径片段的序列为：/foo、/bar、baz，则调用 path.resolve(&#39;/foo&#39;, &#39;/bar&#39;, &#39;baz&#39;) 会返回 /bar/baz。 如果处理完全部给定的 path 片段后还未生成一个绝对路径，则当前工作目录会被用上。 生成的路径是规范化后的，且末尾的斜杠会被删除，除非路径被解析为根目录。 长度为零的 path 片段会被忽略。 如果没有传入 path 片段，则 path.resolve() 会返回当前工作目录的绝对路径。 例子： 123456789path.resolve('/foo/bar', './baz');// 返回: '/foo/bar/baz'path.resolve('/foo/bar', '/tmp/file/');// 返回: '/tmp/file'path.resolve('wwwroot', 'static_files/png/', '../gif/image.gif');// 如果当前工作目录为 /home/myself/node，// 则返回 '/home/myself/node/wwwroot/static_files/gif/image.gif' path.sep提供了平台特定的路径片段分隔符： Windows 上是 \ POSIX 上是 / 例如，在 POSIX 上： 12'foo/bar/baz'.split(path.sep);// 返回: ['foo', 'bar', 'baz'] 在 Windows 上： 12'foo\\bar\\baz'.split(path.sep);// 返回: ['foo', 'bar', 'baz'] 注意：在 Windows 上，斜杠字符（/）和反斜杠字符（\）都可作为路径分隔符； 但 path 的方法只添加反斜杠（\）。 本文结束，感谢阅读。 参考资料：node官方文档本文作者：melody0z 本文链接：https://melodyvoid/Node/path-module.html 欢迎转载，转载请注明文本链接]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>path模块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0725]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0725.html</url>
    <content type="text"><![CDATA[必备句型​ I think that a good friend should be a good listener. 我觉得一个好朋友应该善于倾听 I’m so lucky to such a friend like you. 有你这样的朋友真是幸运。 ​ 场景对话​ A: I think that a good friend should be a good listener. B: That’s true. I’m so lucky to have such a friend like you. A: Me,too,thank you for all you have done for me. ​ 参考译文​ A: 我觉得一个好朋友应该善于倾听。 B: 确实，有你这样的朋友真是幸运。 A: 我也是，感谢你为我所做的一切。 ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0724]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0724.html</url>
    <content type="text"><![CDATA[必备句型​ It’s hard to imagine what it would be like to have no friends. 真难以想象没有朋友会是什么样子 I totally agree with you. 我完全同意你的看法 ​ 场景对话​ A: I have a lot of close friends. B: You must be pretty happy then? A: Yeah, It’s hard to imagine what it would be like to have no friends. B: I totally agree with you. ​ 参考译文​ A: 我有很多好朋友。 B: 那你一定很快乐吧。 A: 是的，真难以想象没有朋友会是个什么样子。 B: 我完全同意你的看法。 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模块化结构]]></title>
    <url>%2FNode%2Fmodular-structure.html</url>
    <content type="text"><![CDATA[模块化代码结构 Node采用的模块化结构是commonJS规范 模块与文件是一一对应关系，即加载一个模块，实际上就是加载对应的一个模块文件 CommonJS模块的特点 所有代码都运行在模块作用域，不会污染全局作用域。 模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。 模块加载的顺序，按照其在代码中出现的顺序。 模块的分类 文件模块 就是我们自己写的功能模块文件 核心模块 Node平台自带的一套基本的功能模块，也有人称之为Node平台的API 第三方模块 社区或者第三方个人开发好的功能模块，可以直接拿回来用 模块化开发的流程 创建模块（foo.js) 导出成员（module.exports = {}) 载入模块 （let foo = require(“./foo.js”) 使用模块 （foo.bar()) 模块内的（伪）全局环境我们在文件操作中必须使用绝对路径 __dirname 用于获取当前文件所在目录的完整路径； 在REPL环境无效 __filename 用来获取当前文件的完整路径； 在REPL环境无效； module 模块对象 exports 映射到module.exports的别名 require() require.cache require.extensions require.main require.resolve() module对象Node内部提供一个module构建函数。所有模块都是module的实例。有以下属性： module.id 模块的识别符，通常是带有绝对路径的模块文件名。 module.filename 模块定义的文件的绝对路径。 module.loaded返回一个布尔值，表示模块是否已经加载完毕。 module.parent 返回一个对象，表示调用该模块的模块 module.children 返回一个数组，表示该模块要用到的其他模块。 module.exports 表示模块对外输出的值。 载入一个模块就是构建一个module实例 看个例子 |— module |— module.js |— 05-module.js module/module.js 1console.log(module); 05-module.js 1234const foo = require("./module/module");console.log("----------------------------------------");console.log(module); 然后我们执行05-module.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253$ node 05-module.js Module &#123; id: '/Users/melody0z/github/nodejs/second/module/module.js', exports: &#123;&#125;, parent: Module &#123; id: '.', exports: &#123;&#125;, parent: null, filename: '/Users/melody0z/github/nodejs/second/05-module.js', loaded: false, children: [ [Circular] ], paths: [ '/Users/melody0z/github/nodejs/second/node_modules', '/Users/melody0z/github/nodejs/node_modules', '/Users/melody0z/github/node_modules', '/Users/melody0z/node_modules', '/Users/node_modules', '/node_modules' ] &#125;, filename: '/Users/melody0z/github/nodejs/second/module/module.js', loaded: false, children: [], paths: [ '/Users/melody0z/github/nodejs/second/module/node_modules', '/Users/melody0z/github/nodejs/second/node_modules', '/Users/melody0z/github/nodejs/node_modules', '/Users/melody0z/github/node_modules', '/Users/melody0z/node_modules', '/Users/node_modules', '/node_modules' ] &#125;----------------------------------------Module &#123; id: '.', exports: &#123;&#125;, parent: null, filename: '/Users/melody0z/github/nodejs/second/05-module.js', loaded: false, children: [ Module &#123; id: '/Users/melody0z/github/nodejs/second/module/module.js', exports: &#123;&#125;, parent: [Circular], filename: '/Users/melody0z/github/nodejs/second/module/module.js', loaded: true, children: [], paths: [Object] &#125; ], paths: [ '/Users/melody0z/github/nodejs/second/node_modules', '/Users/melody0z/github/nodejs/node_modules', '/Users/melody0z/github/node_modules', '/Users/melody0z/node_modules', '/Users/node_modules', '/node_modules' ] &#125; 模块的定义 一个新的js文件就是一个模块 一个合格的模块应该是有导出成员的，否则模块就失去了定义的价值。 模块内部是一个独立（封闭）的作用域（模块与模块之间不会冲突） 模块之间必须通过导出或导入的方式协同 导出方式： exports.name = value; module.exports = {name:value} module.exports和exports module.exports是用于为模块导出成员的接口 exports是指向module.exports的别名，相当于在模块开始的时候执行：var exports = module.exports; 一旦为module.exports赋值，就会切断之前两者的相关性； 最终模块的导出成员以module.exports为准。 看个例子 |— module |— module.exports.js |— 06-module.exports.js module/module.exports.js 123456789let a = 10;let msg = "hello";function foo() &#123; return "我是函数"&#125;exports.a = a;exports.msg = msg;exports.foo = foo; 06-module.exports.js 1234const bar = require("./module/module.exports");console.log(bar.a);console.log(bar.msg);console.log(bar.foo()); 然后我们执行06-module.exports.js 1234$ node 06-module.exports.js 10hello我是函数 然后我们用module.exports的方式改写一下 123456789101112131415 let a = 10; let msg = "hello"; function foo() &#123; return "我是函数" &#125; - exports.a = a;- exports.msg = msg;- exports.foo = foo; + module.exports = &#123;+ a:a,+ msg:msg,+ foo:foo+ &#125;; 执行06-module.exports.js 1234$ node 06-module.exports.js 10hello我是函数 我们再用ES6的语法简化一下 1234567891011121314151617 let a = 10; let msg = "hello"; function foo() &#123; return "我是函数" &#125; - module.exports = &#123;- a:a,- msg:msg,- foo:foo- &#125;;+ module.exports = &#123;+ a,+ msg,+ foo+ &#125;; 执行结果和上面的一样。 载入模块 Node使用commonJS模块规范，内置的require函数用于加载模块文件。 require的基本功能是，读入并执行一个JavaScript文件，然后返回该模块的exports对象。 如果没有发现执行模块，会报错。 模块的加载机制id：路径的情况就是直接以相对路径的方式找文件 require实现机制 将传入的模块ID通过加载规则找到对应的模块文件 读取这个文件里面的代码 通过拼接的方式为该段代码构建私有空间 执行该代码 拿到module.exports返回 我们手动写一个$require函数 |— module |— module.exports.js |— 07-$require.js 12345678910111213141516171819202122232425262728293031323334//自己写一个require函数，目的是了解require的实现机制function $require(id) &#123; //1.先找到文件，文件不存在报错 //2.读取文件内容，内容是js代码 const fs = require("fs"); const path = require("path"); //要加载js的路径（完整路径） const filename = path.join(__dirname,id); const dirname = path.dirname(filename); let code = fs.readFileSync(filename,"utf8"); //同步读取文件，不会加入到事件队列 //3.执行代码，所要执行的代码需要营造一个私有空间 let module = &#123; id:filename, exports:&#123;&#125; &#125;; let exports = module.exports; code = `(function ($require,module,exports,__dirname,__filename) &#123; $&#123;code&#125; &#125;)($require,module,exports,dirname,filename)` eval(code); //4.返回值 return module.exports;&#125;const bar = $require("./module/module.exports.js");console.log(bar.a);console.log(bar.msg);console.log(bar.foo()); 然后执行 1234$ node 07-\$reqiure.js 10hello我是函数 require扩展名require加载文件时可以省略扩展名： require(&quot;./module&quot;) require(&quot;./module.js&quot;)此时文件按js文件执行 require(&quot;./module.json&quot;)此时文件按JSON文件解析 require(&quot;./module.node&quot;)此时文件预编译好的C++模块执行 优先级是js&gt;json&gt;node require加载文件规则 通过./后../开头：则按照相对路径从当前文件所在文件夹开始寻找模块； require(&quot;../file.js&quot;) 上级目录下找file.js文件 通过/开头：则以系统根目录开始寻找模块； require(&quot;/Users/melody0z/github/nodejs/second/module/file.js&quot;) 以绝对路径的方式寻找 如果参数字符串不以”./“或”/“开头，则表示加载的是一个默认提供的核心模块（位于node的系统安装目录中） require(&quot;fs&quot;) 加载核心模块中的文件系统（file system)模块 或者从当前目录向上搜索node_modules目录中的文件： require(&quot;my_module&quot;); 各级node_modules文件夹中搜索my_module.js文件； require加载目录规则 如果require传入的是一个目录的路径，会自动查看该目录的package.json文件，然后加载main字段指定的入口文件 如果package.json文件没有main字段，或者根本就没有package.json文件，则默认找目录下的index.js文件作为模块 require(&quot;./module&quot;);当前目录下找module文件夹中的index.js文件 模块的缓存 第一次加载某个模块时，Node会缓存该模块。以后再加载该模块，就直接冲缓存取出该模块的module.exports属性（不会再次执行该模块） 如果需要多次执行模块中的代码，一般可以让模块暴露行为（函数） 模块的缓存可以通过require.cache拿到，同样也可以删除 验证模块有缓存 目录结构 |— date.js |— 08.cache.js date.js 1module.exports = new Date(); 08-cache.js 12345const date = require("./date");setInterval(() =&gt; &#123; console.log(date.getTime());&#125;,1000); 执行08-cache.js 1234567$ node 08-cache.js 15009326952781500932695278150093269527815009326952781500932695278^C 看，每次输出的时间戳一样，说明结果被缓存起来了。 我们再来看 目录结构 |— date.js |— 09.cache2.js 09-cache2.js 1234567let last;setInterval(() =&gt; &#123; const date = require("./date"); console.log(last === date); last = date; console.log(date.getTime());&#125;,1000); 执行 12345678910$ node 09-cache2.js false1500933712763true1500933712763true1500933712763true1500933712763^C 同样证明有缓存 缓存长什么样？ 目录结构 |— date.js |— 10.cache3.js 10-cache3.js 12const date = require("./date")console.log(require.cache); 我们打印一下缓存看看 1234567891011121314151617181920212223242526272829303132333435363738&#123; '/Users/melody0z/github/nodejs/second/10-cache3.js': Module &#123; id: '.', exports: &#123;&#125;, parent: null, filename: '/Users/melody0z/github/nodejs/second/10-cache3.js', loaded: false, children: [ [Object] ], paths: [ '/Users/melody0z/github/nodejs/second/node_modules', '/Users/melody0z/github/nodejs/node_modules', '/Users/melody0z/github/node_modules', '/Users/melody0z/node_modules', '/Users/node_modules', '/node_modules' ] &#125;, '/Users/melody0z/github/nodejs/second/date.js': Module &#123; id: '/Users/melody0z/github/nodejs/second/date.js', exports: 2017-07-24T22:09:00.024Z, parent: Module &#123; id: '.', exports: &#123;&#125;, parent: null, filename: '/Users/melody0z/github/nodejs/second/10-cache3.js', loaded: false, children: [Object], paths: [Object] &#125;, filename: '/Users/melody0z/github/nodejs/second/date.js', loaded: true, children: [], paths: [ '/Users/melody0z/github/nodejs/second/node_modules', '/Users/melody0z/github/nodejs/node_modules', '/Users/melody0z/github/node_modules', '/Users/melody0z/node_modules', '/Users/node_modules', '/node_modules' ] &#125; &#125; 我们发现，缓存和module对象类似 了解了缓存之后，我们就知道如何清除缓存了 目录结构 |— date.js |— 11-swipecache.js 11-swipecache.js 1234567setInterval(() =&gt; &#123; Object.keys(require.cache).forEach((key) =&gt; &#123; delete require.cache[key]; &#125;); const date = require("./date"); console.log(date.getTime());&#125;,1000); 执行11-swipecache.js 123456$ node 11-swipecache.js 1500935467664150093546869215009354696991500935470701^C 注意： 先清除缓存，再require。 下面我们将自己写的$require加上缓存 123456789101112131415161718192021222324252627282930313233343536function $require(id) &#123; const fs = require("fs"); const path = require("path"); const filename = path.join(__dirname, id); $require.cache = $require.cache || &#123;&#125;; if ($require.cache[filename]) &#123; return $require.cache[filename].exports; &#125; //第一次没有缓存 const dirname = path.dirname(filename); let code = fs.readFileSync(filename, "utf8"); //定义一个数据容器，用容器去装模块导出的成员 let module = &#123; id: filename, exports: &#123;&#125; &#125;; let exports = module.exports; code = ` (function($require, module, exports, __dirname, __filename) &#123; $&#123;code&#125; &#125;)($require, module, exports, dirname, filename);`; eval(code); //缓存起来 $require.cache[filename] = module; return module.exports;&#125;setInterval(() =&gt; &#123; const date = $require("./date.js"); console.log(date.getTime());&#125;,1000); 执行 12345$ node 12-\$require-cache.js 150093764976915009376497691500937649769^C 本文结束，感谢阅读。 本文作者：melody0z 本文链接：https://melodyvoid.github.io/Node/modular-structure.html 欢迎转载，转载请注明文本链接]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[路径问题]]></title>
    <url>%2FNode%2Frouting-problem.html</url>
    <content type="text"><![CDATA[目录结构 |— /module ​ |— path.js |— index.js |— a.txt module/path.js 123456789const fs = require("fs");fs.readFile("../a.txt",(err,data) =&gt; &#123; if(err) &#123; console.log(err); &#125;else&#123; console.log(data); &#125;&#125;); index.js 1const foo = require("./module/path"); 然后我们执行index.js 12$ node 04-path.js &#123; Error: ENOENT: no such file or directory, open '../a.txt' errno: -2, code: 'ENOENT', syscall: 'open', path: '../a.txt' &#125; 原因是没有找到。咦？路径没有错啊，path.js上级目录下面的a.txt。 其实原因是这样的。在node执行的时候，是会以入口文件为基准，去找文件。我们的入口文件是index.js。那么a.txt是和它平级，在module/path.js中写成./a.txt就可以了，我们试一下。 12345678910 const fs = require("fs"); - fs.readFile("../a.txt",(err,data) =&gt; &#123;+ fs.readFile("./a.txt",(err,data) =&gt; &#123; if(err) &#123; console.log(err); &#125;else&#123; console.log(data); &#125; &#125;); 在执行一下index.js 12$ node index.js &lt;Buffer 53 75 6e 20 4a 75 6c 20 32 33 20 32 30 31 37 20 32 31 3a 30 34 3a 31 38 20 47 4d 54 2b 30 38 30 30 20 28 43 53 54 29&gt; 可以读出来了，但是是buffer，我们需要toString一下 12345678910 const fs = require("fs"); fs.readFile("./a.txt",(err,data) =&gt; &#123; if(err) &#123; console.log(err); &#125;else&#123;- console.log(data);+ console.log(data.toString()); &#125; &#125;); 再执行一下index.js 12$ node index.js Sun Jul 23 2017 21:04:18 GMT+0800 (CST) 我们成功了！but，有一个问题，我们试着想一下，我们在阅读module/path.js的代码时，看到./a.txt会误以为在module文件夹下有a.txt(实际上没有)。所以我们要引出下面的东西 __dirname 获取当前脚本所在路径 __filename 获取文件路径 module/path.js 1234567891011121314+ //获取当前脚本所在路径+ console.log(__dirname);+ //获取文件路径+ console.log(__filename); const fs = require("fs"); fs.readFile("./a.txt",(err,data) =&gt; &#123; if(err) &#123; console.log(err); &#125;else&#123; console.log(data.toString()); &#125; &#125;); 执行index.js 1234$ node index.js /Users/melody0z/github/nodejs/second/module/Users/melody0z/github/nodejs/second/module/path.jsSun Jul 23 2017 21:04:18 GMT+0800 (CST) 我们发现上面的两个东西可以获取绝对路径 所以我们在文件操作的时候路径都必须是绝对路径（物理路径） 123456789 const fs = require("fs");- fs.readFile("./a.txt",(err,data) =&gt; &#123;+ fs.readFile(__dirname + "/../a.txt",(err,data) =&gt; &#123; if(err) &#123; console.log(err); &#125;else&#123; console.log(data.toString()); &#125; &#125;); 这样看起来是不是舒服多了 注意点： __dirname可以获取当前文件所在目录的完整路径；在模块全局环境有效，但在REPL环境无效 __filename可以用来获取当前文件的完整路径；在模块全局环境有效，但在REPL环境无效 本文结束，感谢阅读。 本文作者：melody0z 本文链接：https://melodyvoid.github.io/Node/routing-problem.html 欢迎转载，转载请注明文本链接]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[验证node单线程]]></title>
    <url>%2FNode%2Fverify-node-single-thread.html</url>
    <content type="text"><![CDATA[现象我们由一段代码入手(文件名：02.js); 123456789101112131415const http = require("http");let count = 0;const server = http.createServer((req,res) =&gt; &#123; res.writeHead(200,&#123;"Content-Type":"text/html;charset=UTF-8"&#125;); res.write(`你是第$&#123;count++&#125;个访问用户`); res.end();&#125;);server.listen(3000,(err) =&gt; &#123; //出现错误的情况就是端口被占用 if(err) throw err; console.log("server is running at http://localhost:3000/")&#125;); 然后我们执行它 12$ node 02.js server is running at http://localhost:3000/ 打开浏览器 我们能看到“你是第0个访问用户”，当我们刷新的时候，我们发现… 问题1：count并没有重新归零 问题2：count直接由0变到了2 我们来看下问题1，count并没有重新归零，说明我们在刷新页面的时候并不是重新执行了整个脚本，而是只执行了server里的代码 12345const server = http.createServer((req,res) =&gt; &#123; res.writeHead(200,&#123;"Content-Type":"text/html;charset=UTF-8"&#125;); res.write(`你是第$&#123;count++&#125;个访问用户`); res.end();&#125;); 所以count不会重新归零，而是执行里面的count++，但是…应该由0变为1啊。 好了，我们来看第二个问题，为什么直接从0变为2，我们打开调试工具 我们发现，刷新页面的时候会发送两个请求，一个是localhost，一个是favicon.ico，所以 1res.write(`你是第$&#123;count++&#125;个访问用户`); 会执行两次，然后我们就会看见0，2，4，6… 解决办法 做一个判断 if(req.url === &quot;/favicon.ico&quot;) return; 12345678910111213141516const http = require("http");let count = 0;const server = http.createServer((req,res) =&gt; &#123; if(req.url === "/favicon.ico") return; //如果请求的是favicon.ico我们就return掉 res.writeHead(200,&#123;"Content-Type":"text/html;charset=UTF-8"&#125;); res.write(`你是第$&#123;count++&#125;个访问用户`); res.end();&#125;);server.listen(3000,(err) =&gt; &#123; //出现错误的情况就是端口被占用 if(err) throw err; console.log("server is running at http://localhost:3000/")&#125;); 单线程我们再把代码修改一下 1234567891011121314151617181920 const http = require("http"); let count = 0; const server = http.createServer((req,res) =&gt; &#123; if(req.url === "/favicon.ico") return; res.writeHead(200,&#123;"Content-Type":"text/html;charset=UTF-8"&#125;); res.write(`你是第$&#123;count++&#125;个访问用户`);+ //如果count计数到5的话，我们就让它阻塞+ if(count === 5)&#123;+ while(true) &#123; &#125;+ &#125; res.end(); &#125;); server.listen(3000,(err) =&gt; &#123; //出现错误的情况就是端口被占用 if(err) throw err; console.log("server is running at http://localhost:3000/") &#125;); 我们再来执行它，然后刷新刷新，count计数到5的时候就会阻塞，我们看 这是，我们重新开一个页面，输入http://localhost:3000 我们发现新开的页面也是阻塞的，为什么呢？就是因为node是单线程，一个地方阻塞了，就都阻塞了。 本文结束，感谢阅读。 本文作者：melody0z 本文链接：https://melodyvoid.github.io/Node/verify-node-single-thread.html 欢迎转载，转载请注明文本链接]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0723]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0723.html</url>
    <content type="text"><![CDATA[必备句型​ Oh,boy! 天哪 I think I have a crush on her. 我觉得我是喜欢上她了 ​ 场景对话​ A: Oh,boy! Look at the girl over there, she’s gorgeous. B: Hey,are you okay? A: I think I have a cruse on her. B: Excuse me? A: I guess that’s love at first sight. ​ 参考译文​ A: 天哪！快看那边的那个女孩，太漂亮了。 B: 嗯，你还好吧？ A: 我觉得我是喜欢上她了。 B: 什么？ A: 我想这就是一见钟情吧。 ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node事件驱动模型]]></title>
    <url>%2FNode%2Fnode-event-driven-model.html</url>
    <content type="text"><![CDATA[Event driven（事件驱动）Node采用的是事件驱动的方式，通过事件驱动的方式处理请求时无需为每一个请求创建额外的线程。在事件驱动模型中，每一个I/O操作都会被添加到事件队列中，主线程循环地处理队列上的工作任务，当执行过程中遇到阻塞（读取文件、查询数据库）时，线程不会停下来等待结果，而是留下一个处理结果的回调函数，转而继续执行队列中的下一个任务。这个传递到队列中的回调函数在阻塞任务运行结束后才被线程调用。 主线程的代码执行完毕就会从事件队列中读取事件，如果有就取出事件并执行相关的回调函数。事件队列事件全部执行完毕，node应用就会终止。Node对于阻塞I/O的处理在幕后使用线程池来确保工作的执行。Node从线程池中取得一个线程来执行复杂任务，而不占用主循环线程。这样就防止阻塞I/O占用空闲资源。当阻塞任务执行完毕通过添加到事件队列中的回调函数来处理接下来的工作。 Node基于事件的工作调度能很自然地将主要的调度工作限制到了一个线程，应用能很高效地处理多任务。程序每一时刻也只需管理一个工作中的任务。当必须处理阻塞I/O时，通过将这个部分的I/O控制权交给线程池中的线程，能最小地影响到应用处理事件，快速地反应web请求。 123456789101112131415161718192021222324252627const fs = require("fs");console.time("timer");//判断是否存在a.txt文件fs.stat("./a.txt",(err,stats) =&gt; &#123; if(err)&#123; console.log("文件不存在"); //不存在的话，我们就创建 fs.writeFile("./a.txt",new Date(),(err) =&gt; &#123; if(err) throw err; console.log("文件创建成功") &#125;) &#125;else &#123; //如果存在的话，先删除 fs.unlink("./a.txt",(err) =&gt; &#123; if(err) throw err; //创建 fs.writeFile("./a.txt",new Date(),(err) =&gt; &#123; if(err) throw err; console.log("文件删除后创建成功"); &#125;) &#125;) &#125;&#125;);console.timeEnd("timer"); 1234567$ node 01-event-driven.js timer: 0.444ms文件不存在文件创建成功$ node 01-event-driven.js timer: 0.427ms文件删除后创建成功 我们来看一下具体过程 本文结束，感谢阅读。 本文作者：melody0z 本文链接：https://melodyvoid.github.io/Node/node-learning-notes-01.html 欢迎转载，转载请注明文本链接]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>事件驱动模型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0722]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-072.html</url>
    <content type="text"><![CDATA[必备句型​ Let’s have a get-together tonight. 我们今晚聚会吧 How about a rain check? 换个时间行吗？ ​ 场景对话​ A: Let’s have a get-together tonight.Would you come? B: I’d love to, but I have a class at that time and I have to finish my homework.How about a rain check? ​ 参考译文​ A: 我们今晚聚会吧，你能来吗？ B: 我很想啊，但是今晚有课，还有作业要完成，换个时间行吗？ ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0721]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0721.html</url>
    <content type="text"><![CDATA[必备句型​ She had a quarrel with Tom. 她跟Tom吵架了 The course of true love never did run smoothly. 爱情路上多波折 ​ 场景对话​ A: Zoe is so upset. B: Yes, but I don’t know what’s going on with her. A: She had a quarrel with Tom. B: People say “The course of true love never did run smoothly”. ​ 参考译文​ A: Zoe心情不是很好。 B: 是的，不知道她怎么了。 A: 她跟Tom吵架了。 B: 人们说：“爱情路上多波折”。 ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node学习笔记01]]></title>
    <url>%2FNode%2Fnode-learning-notes-01.html</url>
    <content type="text"><![CDATA[Node简介什么是Node Node 就是 JavaScript 语言在服务器端的运行环境 所谓“运行环境（平台）”有两层意思： 首先，JavaScript 语言通过 Node 在服务器运行，在这个意义上，Node 有点像 JavaScript 虚拟机； 其次，Node 提供大量工具库，使得 JavaScript 语言与操作系统互动（比如读写文件、新建子进程），在这个意义上， Node 又是 JavaScript 的工具库。 重点理解 Node是一个JavaScript的运行环境（平台），不是一门语言，也不是JavaScript的框架； Node的实现结构； Node可以用来开发服务端应用程序，Web系统； 基于Node的前端工具集 Node.js的特点 Node.js® is a JavaScript runtime built on Chrome’s V8 JavaScript engine. Node.js uses an event-driven, non-blocking I/O model that makes it lightweight and efficient. Node.js’ package ecosystem, npm, is the largest ecosystem of open source libraries in the world. 单线程 事件驱动（event-driven) 非阻塞I/O（non-blocking I/O) Node命令的基本用法进入REPL(Read Eval Print Loop:交互解释器) Read：读取用户输入，解析输入了JavaScript数据结构并存储在内存中。 Eval：执行输入的数据结构 Print：输出结果 Loop：循环操作以上步骤直到用户退出 12$ node&gt; 简单的表达式运算 123$ node&gt; 2 + 46 使用变量 12345678910$ node&gt; x = 1010&gt; var y = 20undefined&gt; x + y30&gt; console.log("Hello World")Hello Worldundefined 多行表达式 123456789&gt; for(let i = 0;i &lt; 5;i++)&#123;... console.log("i:" + i);... &#125;i:0i:1i:2i:3i:4undefined ...三个点的符号是系统自动生成的，回车换行后即可，Node会自动检测是否为连续的表达式。 下划线变量 1234567891011&gt; let a = 10undefined&gt; let b = 10undefined&gt; a + b20&gt; let sum = _undefined&gt; console.log(sum)20undefined REPL命令 ctrl + c 退出当前终端 ctrl + c 按下两次 退出Node REPL .exit 退出Node REPL process.exit() 退出REPL ctrl + d 退出Node REPL up/down键 查看输入的历史命令 tab键 列出当前命令 .help 列出使用命令 .break 退出多行表达式 .clear 退出多行表达式 .save filename 保存当前的Node REPL会话到指定文件 .load filename 载入当前Node REPL会话的文件内容 执行脚本字符串1$ node -e "console.log('Hello World')" 执行脚本文件123$ node index.js$ node path/index.js$ node path/index 查看帮助1$ node --help 全局作用域成员全局对象 global： 类似于客户端JavaScript运行环境中的window process：用于获取当前的Node进程信息，一般用于获取变量之类的信息 console：Node中内置的console模块，提供操作控制台的输入输出功能，常见使用方法与客户端类似。 全局函数 setInterval(callback,millisecond) clearInterval(timer) setTimeout(callback,millisecond) clearTimeout(timer) Buffer:Class 用于操作二进制数据 异步编程异步操作 Node采用Chrome V8引擎处理JavaScript脚本，V8最大特点就是单线程运行，一次只能运行一个任务。 Node大量采用异步操作(asynchonous operation),即任务不是马上执行，而而是插在任务队列的尾部，等到前面的任务运行完后再执行。 提高代码的响应能力 回调函数的设计 对于一个函数如果需要定义回调函数： 回调函数一定作为参数的最后一个参数出现： 12function foo (name,age,callback) &#123;&#125;function bar (value,callback1,callback2)&#123;&#125; 回调函数的第一个参数默认接收错误信息，第二个参数采食真正的回调数据（便于外界获取调用的错误情况）： 1234foo("Jack",18,(error,data) =&gt; &#123; if(error) throw error; console.log(data);&#125;) Node统一约定：强调错误优先 因为之后的操作大多数都是异步的方式，无法通过try…catch捕获异常。 错误优先的回调函数，第一个参数为上一步的错误信息。 什么是异步比如说：setTimeout()、$.ajax() 异步操作回调 由于系统永远不知道用户什么时候会输入内容，所以代码不能永远停在一个地方 Node中的操作方式就是以异步回调的方式解决无状态的问题。 异步回调的问题callback hell 123456789foo1(function()&#123; foo2(function()&#123; foo3(function()&#123; foo4(function()&#123; foo5() &#125;) &#125;) &#125;)&#125;) 相比较与传统的代码： 异步事件驱动的代码不容易阅读 不容易调试 不容易维护 非阻塞I/O什么是I/O I/O：input/output 可以理解为输入到输出之间的转化过程 敲击键盘（输入）看到编辑器中多出字符（输出） 移动鼠标（输入）看到光标移动（输出） 事件驱动和非阻塞机制 Node平台将一个任务连同该任务的回调函数放到一个事件循环系统中 事件循环高效地管理系统线程池同时高效执行每一个任务 当任务执行完成过后自动执行回调函数 Node中的异步I/O 非阻塞的优势 提高代码的响应效率 充分利用单核CPU的优势 改善I/O的不可预测带来的问题 进程与线程什么是进程 每一个正在运行的应用程序都称之为进程 每一个应用程序至少有一个进程 进程是用来给应用程序提供一个运行的环境 进程是操作系统为应用程序分配资源的一个单位 什么是线程 用来执行应用程序中的代码 在一个进程内部，可以有很多线程 在一个线程内部，同时只可以干一件事 而且传统的开发方式大部分是I/O阻塞的 所以需要多线程来更好地利用硬件资源 给人带来的一种错觉：线程越多越好 本文结束，感谢阅读。 本文作者：melody0z 本文链接：https://melodyvoid.github.io/Node/node-learning-notes-01.html 欢迎转载，转载请注明文本链接]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0720]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0720.html</url>
    <content type="text"><![CDATA[必备句型​ I’ve been worried sick about you. 我担心死你了 I am totally fine. 我很好啊 ​ 场景对话​ A: I’ve been worried sick about you, where have you been? B: I am totally fine,I just went shopping with my friends. A: Well, at least you should’ve told me. B: Mom,please. I am not a kid anymore. ​ 参考译文​ A: 我担心死你了，你去哪里了？ B: 我没事啊，跟朋友出去购物了。 A: 嗯，你至少应该告诉我啊。 B: 拜托了，妈，我又不是小孩子。 ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[包装对象]]></title>
    <url>%2FJavaScript%2Fpackage-object.html</url>
    <content type="text"><![CDATA[什么是包装对象？JavaScript中只要引用了字符串（数字、布尔值也是一样的）的属性，JS就会将字符串通过调用new String(s)的方式转换成对象，这个对象继承了字符串的方法，并被用来处理属性的引用。一旦属性引用结束，这个新创建的对象就会销毁（真实实现并不一定是这样，但整个过程看起来是这样）。这个过程就叫包装对象。 我们来看段代码： 123var str = "hello";console.log(typeof str); //stringconsole.log(str.charAt(0)); //h 以上代码平淡无奇，但是我们仔细想一下，str是字符串，字符串类型的变量怎么会有方法呢？同理像number和boolean也一样，为什么基本类型的变量会有方法呢？ 原因就是包装对象，这是我们再阅读一下什么是包装对象。 1234567var str1 = new String("hello");console.log(typeof str1); //object//因为str1是object所以有方法很正常str1.charAt(0);//charAt是怎么来的呢？String.prototype.String = function()&#123;...&#125;; //当然我们如果这么写了会覆盖原生的charAt方法，这里只演示原理。console.log(str1.charAt(0)); //h 我们发现：基本类型（string、number、boolean)z这三个有对应的包装对象。null和undefined也是基本类型，但是没有对应的包装对象。 我们回过头来再看上面第一个例子： 1234var str = "hello"; //这里确实是字符串console.log(typeof str); //stringstr.charAt(0); //当字符串调用方法的时候，基本类型会找到对应的包装对象类型，然后包装对象把所有的属性和方法给了基本类型。然后包装对象消失。console.log(str.charAt(0)); //h 那么我么想要给字符串添加一个方法怎么办呢？ 1234567var str = "hello";//在原型里面添加String.prototype.lastValue = function()&#123; return this.charAt(this.length-1);&#125;;//这样我们就可以调用我们写的新方法了str.lastValue(); //o 我们再往下看 123var str = "hello";str.number = 10;console.log(str.number); //undefined; 咦？怎么是undefined？ 答案还是因为包装对象。 str是我们隐式地创建的包装对象，在使用完之后就被抛弃了。 str.number=10这时候创建一个包装对象，赋值。 执行到console.log(str.number)这句话的时候，之前的包装对象已经被抛弃，我们打点调用num的时候，又重新创建一个包装对象，所以此时这个包装对象一定没有num属性，故输出undefined。 那么我们一定要输出str.num呢？ 123var str = "hello";String.prototype.number = 10;console.log(str.number); //10 我们再看一个现象 1234var str = "hello";var str1 = new String("hello");console.log(str == str1); //trueconsole.log(str === str1); //false 不严格相等，一个是字符串类型，一个是对象类型，必然不全等 本文结束，感谢阅读。 本文作者：melody0z 本文链接：https://melodyvoid/JavaScript/package-object.html 欢迎转载，转载请注明文本链接]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0719]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0719.html</url>
    <content type="text"><![CDATA[必备句型​ May I speak to Zoe, please? 可以请Zoe接听电话吗？ She’s tied up at the moment. 她现在走不开 ​ 场景对话​ A: May I speak to Zoe, please? B: I’m sorry, she’s tied up at the moment. Would you like to leave a message? A: No, Thank you. I’ll call her later. ​ 参考译文​ A: 可以请Zoe接听电话吗？ B: 抱歉，她现在走不开。你要留个口信吗？ A: 不用了，谢谢。我待会儿再打给她。 ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0718]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0718.html</url>
    <content type="text"><![CDATA[必备句型​ You look restless. 看你一副坐立不安的样子 I’d like to stay and talk longer, but I really do have to run. 我很想再多聊一会儿，不过我真的很赶时间。 ​ 场景对话​ A: You look restless. Do you have to be somewhere, or am I just boring you? B: I’d like to stay and talk longer, but I really do have to run. I have to be at a meeting at around noon. ​ 参考译文​ A: 看你一副坐立不安的样子，是不是还要去别处，或者是我让你觉得无聊了呢？ B: 我很想再多聊一会儿，不过我真的很赶时间，中午时候还要参加一个会议。 ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[创建对象的几种方式的优缺点对比]]></title>
    <url>%2FJavaScript%2Fcontrast-the-advantages-and-disadvantages-of-several-ways-of-creating-objects.html</url>
    <content type="text"><![CDATA[工厂模式1234567891011function createObj(name, gender)&#123; var obj = new Object(); obj.name = name; obj.gender = gender; obj.sayName = function()&#123; alert(this.name); &#125; return obj;&#125;var person = createObj("Jack", "female"); 缺点： 无法无法确定对象的类型（因为都是Object） 创建的多个对象之间没有关联。 构造函数模式123456789function createObj(name, gender)&#123; this.name = name; this.gender = gender; this.sayName = function()&#123; alert(this.name); &#125;&#125;var person = new createObj("Jack", "female"); 缺点： 多个实例重复创建方法，无法共享。 多个实例都有sayName方法，但均不是同一个Function的实例。 原型方法123456789function createObj()&#123;&#125;createObj.prototype.name = "Jack";createObj.prototype.gender = "female";createObj.prototype.sayName = function()&#123; alert(this.name);&#125;var person = new createObj(); 缺点： 无法传入参数，不能初始化属性值。 如果包含引用类型的值时，改变其中一个实例的值，则会在所有实例中体现。 组合式（构造函数+原型方法）推荐使用1234567891011function createObj(name, gender)&#123; this.name = name; this.gender = gender; if(typeof this.sayName != 'function')&#123; createObj.prototype.sayName = function()&#123; alert(this.name); &#125; &#125;&#125;var person = new createObj("Jack", "female"); 说明： if语句中只会调用一次，就是在碰到第一个实例调用方法时会执。此后所有实例都会共享该方法。在动态原型方法下，不能使用对象字面量重写原型。 寄生构造函数寄生构造函数,其实就是工厂模式+构造函数模式,这种模式比较通用,但不能确定对象关系,所以,在可以使用之前所说的模式时,不建议使用此模式 ​ 在什么情况下使用寄生构造函数比较合适呢?假设要创建一个具有额外方法的引用类型,例如直接String.prototype.addstring,可以通过寄生构造的方式来添加. 123456789function myString(string)&#123; var str = new String(string); str.addstring = function () &#123; return this + ",被添加了"; &#125;; return str;&#125;var box = new myString("lee");alert(box.addstring()); 稳妥构造函数在一些安全环境中,比如禁止使用this和new,这里的this是构造函数里不使用this,这里的new是在外部实例化构造函数时不使用new,这种创建方式叫做稳妥构造函数. 123456789function A(name,age)&#123; var obj = new Object(); obj.showName = function () &#123; return name; &#125;; return obj;&#125;var a = A("Jack",18);alert(a.showName()); 本文结束，感谢阅读。 本文作者：melody0z 本文链接：https://melodyvoid.github.io/JavaScript/contrast-the-advantages-and-disadvantages-of-several-ways-of-creating-objects.html 欢迎转载，转载请注明文本链接]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0717]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0717.html</url>
    <content type="text"><![CDATA[必备句型​ I feel dizzy. 我感到晕晕的 Poor thing. 好可怜啊 ​ 场景对话​ A: I feel dizzy. I have a fever of 38℃ B: Poor thing! Go back to bed and get some rest. I’ll make some soup for you. A: That’s sweet of you. ​ 参考译文​ A: 我感到晕晕的，发烧了，38度。 B: 好可怜啊，回床上睡一会儿吧，我给你做点儿汤。 A: 谢谢你。 ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0716]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0716.html</url>
    <content type="text"><![CDATA[必备句型​ It seems that everybody likes her. 好像每个人都很喜欢她 She really turns me off. 她真的使我厌恶 ​ 场景对话​ A: That girl is so pretty, it seems that everybody likes her. B: I don’t really think so. A: How come? B: She’s too chatty, and she really turns me off. ​ 参考译文​ A: 那个女孩真好看，好像每个人都很喜欢她。 B: 我不这么想。 A: 为什么？ B: 她太啰嗦了，真的让我很讨厌。 ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0715]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0715.html</url>
    <content type="text"><![CDATA[必备句型​ I got stuck in traffic. 我遇上堵车了 Don’t beat around the bush. 别拐弯抹角 ​ 场景对话​ A: I’ve been waiting for an hour, where have you been? B: Sorry, I’m late. I got stuck in traffic. A: Okay, tell me exactly what Tom said. Don’t beat around the bush.Get to the point. ​ 参考译文​ A: 我已经等上一个小时了，你去哪里了？ B: 不好意思，遇上堵车了。 A: 好吧，告诉我Tom说什么了。不要拐弯抹角，直接说重点吧。 ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0714]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0714.html</url>
    <content type="text"><![CDATA[必备句型​ Don’t get me wrong. 请不要误会我的意思 You have to admit that he is not very responsible. 你也得承认他不是很负责任 ​ 场景对话​ A: Don’t get me wrong. I think Tom is a very nice person, but you have to admit that he is not very responsible. B: I guess you are right. He’s got a lot of growing up to do. ​ 参考译文​ A: 请不要误会我的意思。我任务Tom是个很好的人，不过你也得承认他不是很负责任。 B: 你说的不错，他要长大还得学习很多东西。 ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0713]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0713.html</url>
    <content type="text"><![CDATA[必备句型​ Got it ? 明白了吗？ Let me explain this one more time. 让我再解释一次 ​ 场景对话​ A: Got it ? B: Sorry, I still don’t understand. A: Okay, let me explain this one more time. I don’t wanna go out because I don’t like hanging out with Tom. B: Alright, I got it. ​ 参考译文​ A: 明白了吗？ B: 不好意思，我还是不理解。 A: 好吧，我再解释一下，wo’bu’xiang我不想出去，因为我不想跟Tom一起出去逛。 B: 好吧，知道了。 ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0712]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0712.html</url>
    <content type="text"><![CDATA[必备句型​ I’ll never forgive myself. 我永远不能原谅我自己 How can I make it up to you. 我要怎样才能补偿 ​ 场景对话​ A: It’s all my fault. I’ll never forgive myself. B: Don’t say that. We wouldn’t have known that. A: How can I make it up to you? B: You can’t have to do that. ​ 参考译文​ A: 都是我的错，我永远不能原谅自己。 B: 别那么说，我们都无法未卜先知。 A: 我要怎样才能补偿你？ B: 不用啦。 ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0711]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-071.html</url>
    <content type="text"><![CDATA[必备句型​ Are you fond of reading? 你喜欢读书吗？ I like to read all kinds of books. 什么书我都喜欢看 ​ 场景对话​ A: Are you fond of reading? B: Yes, I am. Books can enrich your mind. A: Exactly, what kind of books do you like to read most? B: I like to read all kinds of books. ​ 参考译文​ A: 你喜欢读书吗？ B: 喜欢啊，书籍能丰富你的思想。 A: 确实，你最喜欢读哪种书？ B: 什么书我都喜欢看。 ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0710]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0710.html</url>
    <content type="text"><![CDATA[必备句型​ I dreamed to be a pliot, but I didn’t make it come true. 我曾梦想做一名飞行员，不过我没有实现儿时的梦想 I’m trying my best to learn English. 现在我努力学英文 ​ 场景对话​ A: Hey, did you have a dream when you were a little boy ? B: Of course I did. I dreamed to be a pliot, but I didn’t make it come true. A: Okay, so. How about now? B: Now I’m trying my best to learn English, and I want to be an interpreter some day. ​ 参考译文​ A: 嘿，你小的时候有过什么梦想吗？ B: 当然有啦，我曾梦想过当一名飞行员，不过我没有实现儿时的梦想。 A: 嗯，那现在呢？ B: 现在我在努力学英文，我想成文一名翻译。 ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0708]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0708.html</url>
    <content type="text"><![CDATA[必备句型​ let me explain one more time. 再让我解释一回 I am out of patience. 我忍无可忍了 ​ 场景对话​ A: Please, let me explain one more time. B: Sorry, I am out of patience. A: Why are you so angry? B: I don’t wanna talk to you, I’ve had enough! ​ 参考译文​ A: 求求你，再让我解释一回。 B: 对不起，我忍无可忍了。 A: 你干嘛这么生气？ B: 我不想跟你讲话，我真的受够了。 ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0707]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0707.html</url>
    <content type="text"><![CDATA[必备句型​ Are you satisfied? 你满意吗？ I have to say I am not photogenic at all. 我不得不说，我确实一点儿也不上相啊。 ​ 场景对话​ A: Say cheese. B: Cheese.Okay? A: Yes, have a look. Are you satisfied? B: Oh, I have to say I am not photogentic at al. I just don’t know how to smile. A: Would you like another one? ​ 参考译文​ A: 说“茄子”。 B: 茄子，照好了吗？ A: 是的，来看一眼吧。你满意吗？ B: 哦，我不得不说，我确定一点儿也不上相啊，我就是不知道该怎么微笑。 A: 还想要再照一张吗？ ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0706]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0706.html</url>
    <content type="text"><![CDATA[必备句型​ I don’t like horror movies at all. 我一点儿都不喜欢恐怖片 I am really into his British accent. 我太喜欢他的英国口音了 ​ 场景对话​ A: You like horror movies, don’t you ? B: No, I don’t. I don’t like horror movies at all. I like comedy movies. A: Who is your favorite actor? B: Hugh Grant, I am really into his British accent. 参考译文​ A: 你喜欢恐怖片，是吗？ B: 不，我不喜欢，我一点儿都不喜欢恐怖片，我喜欢喜剧片。 A: 你最喜欢的男演员是谁？ B：休 格兰特。我太喜欢他的英国口音了。 ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0705]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0705.html</url>
    <content type="text"><![CDATA[必备句型​ Are you good at singing ? 你唱歌拿手吗？ I’m a tone-deaf, but I like singing. 我五音不全，但是我喜欢唱歌 ​ 场景对话​ A: Are you good at singing ? B: No, I’m a tone-deaf, but I like singing. A: Okay! Let’s go to karaoke. B: My singing is out of tune. A: Oh, come on. It’s just entertainment. ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0704]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0704.html</url>
    <content type="text"><![CDATA[必备句型​ You are not supposed to smoke here. 你不能在这里吸烟 I am a heavy smoker. 我是个老烟民 ​ 场景对话​ A: Excuse me sir. You are not supposed to smoke here. B: Why not? A: Your seat is in the non-smoking section. So, you can’t smoke here. B: I am a heavy smoker, may I change my seat? ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0703]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0703.html</url>
    <content type="text"><![CDATA[必备句型​ Honesty is very important to me. 诚实对我很重要 The problem is that… 问题是… ​ 场景对话​ A:I don’t like to make friends with people who aren’t honest.Honesty is very important to me. B:I think it’s important to most people. The problem is that you can usually only find out if someone is honest by getting to know them. ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0701]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0701.html</url>
    <content type="text"><![CDATA[必备句型 How come? 为什么？ Don’t judge a book by it’s cover. 不要以貌取人 场景对话​ A:Hey,Look at the man over there,he’s definitely not a good person. B:How come? you don’t even know him. A:I just feel that way. B:Hey!Don’t judeg a book by it’s cover. ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0630]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0630.html</url>
    <content type="text"><![CDATA[必备句型​ I shouldn’t have yelled at you in front of everyone. 我不该在大家面前对你大吼 I don’t know what happened to me. 我不知道我昨天是怎么了 ​ 场景对话​ A:Hey,Bob.I’m so sorry about yesterday.I shouldn’t have yelled at you in front of everyone. B:Don’t worry about it. A:I don’t know what happened to me.I just lost it. B:It’s okay. ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0629]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0629.html</url>
    <content type="text"><![CDATA[必备句型​ You have to finish your dinner before you leave the table. 你离开饭桌之前必须把饭吃完 I’m stuffed. 我吃得太饱了 ​ 场景对话​ A:You have to finish your dinner before you leave the table. B:But,mom.I can’t eat anymore. A:What’s the matter? B:I ate some cookies before we had dinner.I’m stuffed. 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0628]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0628.html</url>
    <content type="text"><![CDATA[必备句型​ You’d better get up or you’ll be late. 你最好起床，否则你要迟到了 Rise and shine,sleepyhead. 贪睡鬼，起床啦 ​ 场景对话​ A:Hey,Bob.Weak up! B:Do I have to get up now? A:You’d better get up or you’ll be late. B:What are you talking about?The alarm hasn’t even gone off yet. A:It went off 30 minutes ago.Rise and shine,sleepyhead. 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0627]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0627.html</url>
    <content type="text"><![CDATA[必备句型​ Can I talk to you for a minute? 我能跟你谈一会儿吗？ It’s out of the question. 不可能 ​ 场景对话​ A:Mom,can I talk to you for a minute? B:Sure,what’s wrong? A:My best friend is going to throw a party tonight,can I stay out all night with my friends? B:No way. A:We’ll be careful. B:It’s out of the question. 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0625]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0625.html</url>
    <content type="text"><![CDATA[必备句型​ I’ve been so stressed these days. 我这几天压力很大 I have no idea what I should major in. 我不知道学什么专业 ​ 场景对话​ A:I’ve been so stressed these days. B:What’s wrong?Are you okay? A:I haven’t decided which college I should go to.I have no idea whta I should major in. B:Don’t worry.You still have time to decide. ## 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0624]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0624.html</url>
    <content type="text"><![CDATA[必备句型​ My back is sore and my meck hurts. 我的背很酸，脖子也疼 I was always absent-minded in the class. 我在课上走神儿了 ​ 场景对话​ A:Finally the class is over. B:Oh,I am so tired.My back is sore and my neck hurts. A:That’s normal.You have been sitting for three hours,with your attention highly concontrated. B:That’s not true.I was always absent-minded in the class. 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0623]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0623.html</url>
    <content type="text"><![CDATA[必备句型​ Why are you asking me this strange question? 你干嘛问我这么奇怪的问题？ I think IQ matters more. 我觉得智商更重要一点 #### 场景对话​ A:Hey,Bob,In your opinion,which one is more important,IQ or EQ? B:Why are you asking me this strange question? A:Just asking. B:Well,I Think IQ matters more,but it won’t work without EQ. ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0622]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-062.html</url>
    <content type="text"><![CDATA[必备句型​ I really wish I hadn’t done it. 我真希望我没那么做 What on earth are you talking about? 你究竟在说什么？ ​ 场景对话​ A:Hey,Bob.You look unhappy.What’s wrong? B:Oh,Alex,I mad e a big mistake A:What happened? B:I really wish I hadn’t done it. A:What on earth are you talking about? B:I got caught cheating.I feel so ashamed.The teacher saw me and told me I failed. ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0621]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0621.html</url>
    <content type="text"><![CDATA[必备句型​ Why on earth are you waning to learn a new language now? 你到底为什么学习一门新语言？ It’s never too late to learn. 活到老，学到老。 ​ 场景对话​ A:Hey,What are you up to? B:I’m learning English. A:Why on earth are you wanting to learn a new language now? B:It’s never too late to learn,you never know when these things will come into use. 黑体表示连读 ​斜体表示弱读 Why on earth did you do?你到底做了什么？ ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
</search>