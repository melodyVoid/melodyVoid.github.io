<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[理解Iterable、Iterator、Generator]]></title>
    <url>%2FJavaScript%2F%E7%90%86%E8%A7%A3Iterable%E3%80%81Iterator%E3%80%81Generator.html</url>
    <content type="text"><![CDATA[什么是迭代器(Iterator)?迭代器协议 当一个对象被认为是一个迭代器时，它实现了一个 next()的方法并且拥有以下含义：对象的next方法是一个无参函数，它返回一个对象，该对象拥有done和value两个属性： done: 布尔值 如果迭代器已经经过了被迭代序列时为true。这时value可能描述了该迭代器的返回值。 如果迭代器可以产生序列中的下一个值，则为false。这等效于连同done属性也不指定。 value:迭代器返回的任何JavaScript值。done为true时可省略 手写一个简单迭代器 12345678910111213let i = 0const iterator = &#123; next() &#123; return &#123; value: i++, done: false, &#125; &#125;&#125;console.log(iterator.next()) // &#123; value: 0, done: false&#125;console.log(iterator.next()) // &#123; value: 1, done: false&#125;console.log(iterator.next()) // &#123; value: 2, done: false&#125; 一些迭代器是转换自可迭代对象: 123456789101112const arr = [1, 2, 3]const arrEntries = arr.entries()const arrKeys = arr.keys()const arrVal = arr[Symbol.iterator]()console.log(arrEntries) // Array Iteratorconsole.log(arrKeys) // Array Iteratorconsole.log(arrVal) // Array Iteratorconsole.log(arrEntries.next()) // &#123; value: [0, 1], done: false&#125;console.log(arrEntries.next()) // &#123; value: [1, 2], done: false&#125;console.log(arrEntries.next()) // &#123; value: [2, 3], done: false&#125;console.log(arrEntries.next()) // &#123; value: undefined, done: true&#125; next()迭代让我们来看一个数组，它是一个可迭代对象，可以生成一个迭代器来消费它的值： 12345678const arr = [1, 2, 3]const it = arr[Symbol.iterator]() // 生成迭代器// next()迭代it.next(); // &#123; value: 1, done: false &#125;it.next(); // &#123; value: 2, done: false &#125;it.next(); // &#123; value: 3, done: false &#125;it.next(); // &#123; value: undefined, done: true &#125; 每一次定位在[Symbol.iterator]上的方法在值arr上被调用时，它都将生成一个全新的迭代器。 1234const arr = [1, 2, 3]const it = arr[Symbol.iterator]() // 生成迭代器const it2 = arr[Symbol.iterator]() // 生成迭代器2console.log(it === it2) // false 基本类型的字符串值也默认地是可迭代对象 1234const str = 'hello'const it = str[Symbol.iterator]()console.log(it.next()) // &#123; value: 'h', done: false &#125;console.log(it.next()) // &#123; value: 'e', done: false &#125; 一个迭代器的next(…)方法能够可选地接收一个或多个参数 大多数内建的迭代器不可以 Generator的迭代器可以 根据一般的惯例，包括所有的内建迭代器，在一个已经被耗尽的迭代器上调用next(…)不是一个错误，而是简单地持续返回结果{ value: undefined, done: true }。 可选的return(..)return(..)被定义为向一个迭代器发送一个信号，告知它消费者代码已经完成而且不会再从它那里抽取更多的值。这个信号可以用于通知生产者（应答next(..)调用的迭代器）去实施一些可能的清理作业，比如释放/关闭网络，数据库，或者文件引用资源。 如果一个迭代器拥有return(..)，而且发生了可以自动被解释为非正常或者提前终止消费迭代器的任何情况，return(..)就将会被自动调用。你也可以手动调用return(..)。 可选的throw(..)throw(..)被用于向一个迭代器发送一个异常/错误信号，与return(..)隐含的完成信号相比，它可能会被迭代器用于不同的目的。它不一定像return(..)一样暗示着迭代器的完全停止。 例如，在generator迭代器中，throw(..)实际上会将一个被抛出的异常注射到generator暂停的执行环境中，这个异常可以用try..catch捕获。一个未捕获的throw(..)异常将会导致generator的迭代器异常中止。 注意 在迭代器接口上的可选方法 —— return(..)和throw(..) —— 在大多数内建的迭代器上都没有被实现。但是，它们在generator的上下文环境中会用到。 根据一般的惯例，在return(..)或throw(..)被调用之后，一个迭代器就不应该在产生任何结果了。 什么是可迭代对象(Iterable)？满足可迭代协议的对象是可迭代对象。可迭代协议: 对象的[Symbol.iterator]值是一个无参函数，该函数返回一个迭代器。 在ES6中，所有的集合对象（Array、 Set 与 Map）以及String、arguments都是可迭代对象，它们都有默认的迭代器。 内建迭代器(iterator)也是可迭代对象(iterable) 123456789const arr = [1, 2, 3]// 调用arr的[Symbol.iterator]()返回一个迭代器const it = arr[Symbol.iterator]()// 满足可迭代协议的对象是可迭代对象// it仍然有[Symbol.iterator]()方法,它返回的结果是一个迭代器(它自己)console.log(it[Symbol.iterator]() === it) // trueconsole.log(arr[Symbol.iterator]() === arr) // false 因为arr不是迭代器，而是可迭代对象console.log(...it) // 1 2 3 自定义迭代器可以通过给予迭代器一个简单地返回它自身的[Symbol.iterator]方法，就可以使它成为一个可迭代对象 12345678910111213141516171819let i = 0const iterator = &#123; // 使迭代器iterator成为一个可迭代对象 [Symbol.iterator]() &#123; return this &#125;, next() &#123; return &#123; value: i++, done: false, &#125; &#125;&#125;console.log(iterator.next())console.log(iterator.next())console.log(iterator.next())console.log(iterator[Symbol.iterator]() === iterator) // truefor (const val of iterator) &#123; if (val &gt; 10) break console.log(val)&#125; 可迭代对象可以在以下语句中使用： for…of循环123456for (let value of ['a', 'b', 'c']) &#123; console.log(value);&#125;// "a"// "b"// "c" 理解for...of循环for...of接受一个可迭代对象（Iterable），或者能被强制转换/包装成一个可迭代对象的值（如’abc’）。遍历时，for...of会获取可迭代对象的[Symbol.iterator]()，对该迭代器逐次调用next()，直到迭代器返回对象的done属性为true时，遍历结束，不对该value处理。 1234567const arr = ['a', 'b', 'c']for (let value of arr) &#123; console.log(value);&#125;// "a"// "b"// "c" 12345678const arr = ['a', 'b', 'c']for (let val, res, it = arr[Symbol.iterator]();(res = it.next() &amp;&amp; !res.done;)) &#123; val = res.value console.log(val)&#125;// "a"// "b"// "c" 扩展运算符12345678// restconst [a, b, ...c] = [1, 2, 3, 4, 5]console.log(a, b, c) // 1, 2, [3, 4, 5]// spreadconsole.log([a, ...c, b]) // [1, 3, 4, 5, 2][...'abc']; // ['a', 'b', 'c']console.log(...['a', 'b', 'c']); // 'a', 'b', 'c' 解构赋值123456789101112const a = [1, 2, 3, 4, 5]const it = a[Symbol.iterator]()const [x, y] = it // 仅从`it`中取前两个元素const [z,...w] = it // 取第三个，然后一次取得剩下所有的// `it`被完全耗尽了吗？是的console.log(it.next()) // &#123; value: undefined, done: true &#125;console.log(x) // 1console.log(y) // 2console.log(z) // 3console.log(w) // [4,5] yield*12345function* gen() &#123; yield* ['a', 'b', 'c'];&#125;gen().next(); // &#123; value: "a", done: false &#125; 什么是生成器(Generator)?生成器对象是由一个生成器函数（ generator function ）返回的,并且它符合可迭代协议和迭代器协议。 生成器函数生成器函数是能返回一个生成器的函数。生成器函数由放在function关键字之后的一个星号*来表示，并能使用新的yield关键字。 生成器函数简单地说就是可以暂停的函数 123456789function *fn() &#123; let x = 0 while(true) &#123; yield 2 * x + 1 x++ &#125;&#125;const gen = fn()console.log(gen.next().value) 语法123function *foo() &#123; //...&#125; 执行一个Generator虽然一个generator使用*进行声明，但是你依然可以像一个普通函数那样执行它： 1foo(); 你依然可以传给它参数值，就像： 12345function *foo(x,y) &#123; // ..&#125;foo( 5, 10 ); 主要区别在于，执行一个generator，比如foo(5,10)，并不实际运行generator中的代码。取而代之的是，它生成一个迭代器来控制generator执行它的代码。 yield暂停Generator还有一个你可以在它们内部使用的新关键字，用来表示暂停点：yield。考虑如下代码： 12345678function *foo() &#123; console.log(1) yield // 暂停 console.log(2)&#125;const gen = foo()console.log(gen.next())console.log(gen.next()) 输入和输出yield不只是暂停点，还可以在暂停generator时向外输出 12345678910function *foo() &#123; yield // 不带值的yield默认yield undefined yield 1 yield 2&#125;const gen = foo()console.log(gen.next()) // &#123;value: undefined, done: false&#125;console.log(gen.next()) // &#123;value: 1, done: false&#125;console.log(gen.next()) // &#123;value: 2, done: false&#125;console.log(gen.next()) // &#123;value: undefined, done: true&#125; yield不只是暂停点，还可以在暂停generator时等待一个输入值， 这个值稍后被用于各个表达式环境中 123456789function *foo() &#123; const x = yield console.log(x)&#125;const gen = foo()gen.next(12) // 第一个next()调用的作用仅仅是开始这个generator，只是为了后面的输入做准备gen.next(5) // 5 坑：yield优先级问题 12345678function *foo() &#123; const x = yield 2 + 1 // 等同于yield (2 + 1) console.log(x)&#125;const gen = foo()gen.next()gen.next(5) // 5 12345678function *foo() &#123; const x = (yield 2) + 1 // 首先yield 2, 然后 + 1 console.log(x)&#125;const gen = foo()gen.next()gen.next(5) // 6 生成器对象生成器对象既是迭代器，有是可迭代对象1234567891011121314151617function *foo() &#123; yield 1 yield 2 yield 3&#125;const gen = foo()console.log(gen)// gen有next()方法，满足迭代器协议，是迭代器gen.next() // &#123; value: 1, done: false &#125;gen.next() // &#123; value: 2, done: false &#125;gen.next() // &#123; value: 3, done: false &#125;gen.next() // &#123; value: undefined, done: true &#125;// gen实现了[Symbol.iterator]接口，并返回一个迭代器，满足可迭代协议，所以是可迭代对象gen[Symbol.iterator]() === gen // trueconst gen1 = foo()[...gen1] // 1, 2, 3 在生成器中return遍历器返回对象的done值为true时迭代器即结束，不对该value处理。 123456789function *foo() &#123; yield 1 return 2 yield 3&#125;const gen = foo()gen.next() // &#123;value: 1, done: false&#125;gen.next() // &#123;value: 2, done: true&#125; gen.next() // &#123;value: undefined, done: true&#125; done值为true时迭代即结束，迭代不对该value处理。所以对这个迭代器遍历，不会对值2处理。 1234567function *foo() &#123; yield 1 return 2 yield 3&#125;const gen = foo()console.log(...gen) // 1 1234567891011function *foo() &#123; yield 1 return 2 yield 3&#125;function *bar() &#123; yield 0 yield *foo()&#125;const gen = bar()console.log(...gen) // 0 1 123456789101112function *foo() &#123; yield 1 return 2 yield 3&#125;function *bar() &#123; yield 0 yield yield *foo() &#125;const gen = bar()console.log(...gen) // 0 1 2 在这里拿到了return的2 在生成器中throw123456789function *foo() &#123; yield 1 throw new Error('error') yield 2&#125;const gen = foo()console.log(gen.next()) // &#123; value: 1, done: false &#125;console.log(gen.next()) // errorconsole.log(gen.next()) // 小结：通过上面我们可以看出，next()可以产生三种类型的值 对于可迭代序列中的一项a, 它返回{ value: a, done: false} 对于可迭代序列的最后一项，明确是return返回的是b, 它返回{ value: b, done: true } 对于异常，它抛出这个异常。 生成器委托yield*1234567891011121314function* g1() &#123; yield 1; yield 2;&#125;function *g2() &#123; yield *g1(); yield *[3, 4]; yield *"56"; yield *arguments;&#125;var generator = g2(7, 8);console.log(...generator); // 1 2 3 4 "5" "6" 7 8 yield*考虑可迭代对象的最后一个值 123456789101112function *foo() &#123; yield 'a' yield 'b' return 'c'&#125;function *bar() &#123; const x = yield *foo() console.log(x)&#125;console.log([...bar()]) // c// ['a', 'b'] generator能扮演的角色1. generator作为迭代器(数据生产者)每一个yield可以通过next()返回一个值，这意味着generator可以通过循环或递归生产一系列的值，因为generator对象实现了Iterable接口。 generators同时实现了接口Iterable 和 Iterator，这意味着，generator函数返回的对象是一个迭代器也是一个可迭代的对象。 12345678910111213function *fibonacci() &#123; let a = 0 let b = 1 while (true) &#123; yield a; [a, b] = [b, a + b] &#125;&#125;const gen = fibonacci()for (const val of gen) &#123; if (val &gt; 100) break console.log(val) // 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89&#125; 2. generator作为观察者(数据消费者)yield可以通过next()接受一个值，这意味着generator变成了一个暂停执行的数据消费者直到通过next()给generator传递了一个新值。 作为观察者，生成器暂停，直到它接收到输入。有三种输入，通过接口指定的方法传输： next() 发送正常输入。 return() 终止生成器。 throw() 发出错误信号。 2.1next()发送正常输入12345678910function *foo() &#123; const [x, y, z] = [yield, yield, yield] console.log(x, y, z)&#125;const gen = foo()gen.next()gen.next('1')gen.next('2')gen.next('3')// 1 2 3 2.2return()终止generatorreturn()在生成器里的yield的位置执行return 123456789function *foo() &#123; yield 1 yield 2 yield 3&#125;const gen = foo()gen.next() // &#123; value: 1, done: false &#125;gen.return('end') // &#123; value: 'end', done: true &#125;gen.next() // &#123; value: undefined, done: true &#125; 组织终止 我们可以阻止return()终止generator如果yield是在finally块内（或者在finally中使用return语句） 1234567891011121314function *foo() &#123; try &#123; yield 1 yield 2 &#125; finally &#123; yield 3 yield 4 &#125;&#125;const gen = foo()gen.next() // &#123; value: 1, done: false &#125;gen.return('not end') // &#123; value: 3, done: false &#125;gen.next() // &#123; value: 4, done: false &#125;gen.next() // &#123; value: "not end", done: true &#125; 2.3throw()一个错误12345678function *foo() &#123; yield 1 yield 2 yield 3&#125;const gen = foo()gen.next() // &#123; value: 1, done: false &#125;gen.throw(new Error('error')) // Uncaught Error: error 捕获一下 1234567891011function *foo() &#123; try &#123; yield 1 yield 2 &#125; catch (e) &#123; console.log('捕获到' + e) &#125;&#125;const gen = foo()gen.next() // &#123; value: 1, done: false &#125;gen.throw(new Error('error')) // 捕获到Error: error 3. 协作程序(协同多任务)考虑到generator是可以暂停的并且可以同时作为数据生产者和消费者，不会做太多的工作就可以把generator转变成协作程序(合作进行的多任务) To be continued…参考文档你不知道的JavaScript:ES6与未来–第三章:组织 Genertaors [你不知道的JavaScript:异步与性能–第四章:Generator 本文结束，感谢阅读。 本文作者：melody0z 本文链接：https://melodyvoid.github.io/JavaScript/理解Iterable、Iterator、Generator.html 欢迎转载，转载请注明文本链接]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Generator</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Share-meeting--Promise]]></title>
    <url>%2FJavaScript%2FShare-meeting--Promise.html</url>
    <content type="text"><![CDATA[什么是PromisePromise在英语里的意思是：“承诺”，它表示如A调用一个长时间的任务B的时候，B将返回一个“承诺”给A,A不用关心整个实施过程，继续做自己的任务；当B实施完成的时候，会通过A，并将执行A之间的预先约定的回调。 Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件监听——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了Promise对象。 所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。 Promise是一种封装和组合未来值的易于复用的机制 既然是对象，那么就有属性和方法 属性Promise.length：长度属性，其值总是为 1 (构造器参数的数目). Promise.prototype：表示 Promise 构造器的原型. 方法 Promise.all(iterable) Promise.race(iterable) Promise.reject(reason) Promise.resolve(value) 基本用法1234new Promise((resolve, reject) =&gt; &#123; // 待处理的异步逻辑 // 处理结束后，调用resolve或reject方法&#125;) 新建一个promise很简单，只需要new一个Promise对象即可。所以Promise本质上就是一个函数，它接受一个函数作为参数，并且会返回promise对象，这就给链式调用提供了基础。 三种状态其实Promise函数的使命，就是构建出它的实例，并且负责帮我们管理这些实例。而这些实例有以下三种状态： pending: 初始状态，位履行或拒绝 fulfilled: 意味着操作成功完成 rejected: 意味着操作失败 Promise StatesA promise must be in one of three states: pending, fulfilled, or rejected. When pending, a promise: may transition to either the fulfilled or rejected state. When fulfilled, a promise: must not transition to any other state. must have a value, which must not change. When rejected, a promise: must not transition to any other state. must have a reason, which must not change. pending 状态的 Promise对象可能以 fulfilled状态返回了一个值，也可能被某种理由（异常信息）拒绝（reject）了。当其中任一种情况出现时，Promise 对象的 then 方法绑定的处理方法（handlers）就会被调用，then方法分别指定了resolve方法和reject方法的回调函数 简单的示例: 12345678910111213const promise = new Promise((resolve, reject) =&gt; &#123; if (/* 异步操作成功 */)&#123; resolve(value); &#125; else &#123; reject(error); &#125;&#125;)promise.then(value =&gt; &#123; // 如果调用了resolve方法，执行此函数&#125;, error =&gt; &#123; // 如果调用了reject方法，执行此函数&#125;) 用Promise封装ajax 1234567891011121314151617const request = (url) =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; const xhr = new XMLHttpRequest() xhr.open('GET', url, true) xhr.send() xhr.onload = () =&gt; resolve(JSON.parse(xhr.responseText)) xhr.onerror = () =&gt; reject(new Error(xhr.responseText)) &#125;)&#125;request('http://update.babyeye.com/releases/upgrade.json') .then(response =&gt; &#123; console.log(response) &#125;) .catch(err =&gt; &#123; console.log(err) &#125;) then每一个 promise 都会提供给你一个 then() 函数 (或是 catch()，实际上只是 then(null, ...) 的语法糖)。它接收两个函数作为参数，then(onFilfulled, onRejected)。onFilfulled是成功的操作，onRejected是失败的操作。我们在 then() 函数内部可以做三种事情： return 另一个promise return 一个同步的值（或者undefined） throw一个同步异常 return另一个promise123456789101112request('1.txt') .then(() =&gt; &#123; return request('2.txt') &#125;) .then(response =&gt; &#123; console.log(response) // 2222222222 &#125;) .catch(err =&gt; &#123; console.log(err) &#125;)// 这里这里是return第二个promise,这个return非常重要。如果没有写return,那么request('2.txt')将会出问题，并且下一个函数将会接收到undefined,而不是2222222222，请看下面的例子 12345678910request('1.txt') .then(() =&gt; &#123; request('2.txt') // 这里没有return &#125;) .then(response =&gt; &#123; console.log(response) // 这里的值将是undefined &#125;) .catch(err =&gt; &#123; console.log(err) &#125;) 返回一个同步值（或者undefined）12345678910111213request('1.txt') .then(() =&gt; &#123; return 100 // 返回一个同步值 &#125;) .then(response =&gt; &#123; console.log(response) // 100 &#125;) .catch(err =&gt; &#123; console.log(err) &#125;)// 返回同步值相当于用Promise包裹了一层// 上面的return 100 相当于 return Promise.resolve(100) 抛出同步异常12345678910111213141516171819202122request('1.txt') .then(() =&gt; &#123; a() // a未定义 return 100 &#125;) .then( response =&gt; &#123; console.log('then0000', response) &#125;, err =&gt; &#123; return err &#125;) .then( response =&gt; &#123; console.log('then1111', response) // then1111 ReferenceError: a is not defined &#125;, err =&gt; &#123; console.log('then2222', err) &#125;) .catch(err =&gt; &#123; console.log('catch3333', err) &#125;) 12345678910111213141516171819202122request('1.txt') .then(() =&gt; &#123; a() return 100 &#125;) .then( response =&gt; &#123; console.log('then0000', response) &#125;, err =&gt; &#123; throw err &#125;) .then( response =&gt; &#123; console.log('then1111', response) &#125;, err =&gt; &#123; console.log('then2222', err) // then2222 ReferenceError: a is not defined &#125;) .catch(err =&gt; &#123; console.log('catch3333', err) &#125;) 为什么使用Promise异步不能使用try…catchtry…catch当然很好，但是无法跨异步操作工作。 12345678910111213function foo() &#123; request('1.txt') // 异步操作 .then(response =&gt; &#123; a() // 因为a没有定义 console.log(response) &#125;)&#125;try &#123; foo() // 所以执行到foo()的时候从a()抛出全局错误&#125; catch (err) &#123; console.log(err) // 永远不会到达这里&#125; error-first 12345678910111213141516171819202122function b() &#123; c() // c未定义，报错 return 'b'&#125;function foo(callback) &#123; request('1.txt') .then(response =&gt; &#123; try &#123; callback(null, b()) // b里面是同步代码，所以错误会被捕捉到 &#125; catch (err) &#123; callback(err) &#125; &#125;)&#125;foo((err, data) =&gt; &#123; if (err) &#123; console.log('错误', err) // 错误 ReferenceError: c is not defined &#125; else &#123; console.log('成功', data) &#125;&#125;) 捕获成功了! 但是我们接着往下看 1234567891011121314151617181920212223242526function b() &#123; return request('2.txt')&#125;function foo(callback) &#123; request('1.txt') .then(response =&gt; &#123; try &#123; b().then(response =&gt; &#123; c() // c没有定义，会报错，但是不会被捕捉到 callback(null, response) &#125;) &#125; catch (err) &#123; callback(err) &#125; &#125;)&#125;foo((err, data) =&gt; &#123; if (err) &#123; console.log('错误', err) &#125; else &#123; console.log('成功', data) &#125;&#125;)// Uncaught (in promise) ReferenceError: c is not defined 上面的代码有什么问题呢？ 很明显，错误没有被捕获到 只有在try里面调用同步的立即成功或失败的情况下，这里的try…catch才会工作。如果try里面还有异步完成函数，其中的任何异步错误都无法捕捉到。 多级error-first回调交织在一起，再加上这些无所不在的if检查语句，都不可避免地导致了回调地狱的风险。 callback hell 链式调用123456789101112// request为封装好的Promiserequest('http://update.babyeye.com/releases/upgrade.json') .then(response =&gt; &#123; console.log('获取第一个数据', response) request('http://update.babyeye.com/releases/upgrade.json') .then(response =&gt; &#123; console.log('获取第二个数据', response) &#125;) &#125;) .catch(err =&gt; &#123; console.log(err) &#125;) 问题：Promise回调地狱 正确的姿势 1234567891011request('http://update.babyeye.com/releases/upgrade.json') .then(response =&gt; &#123; console.log('获取第一个数据', response) return request('http://update.babyeye.com/releases/upgrade.json') &#125;) .then(response =&gt; &#123; console.log('获取第二个数据', response) &#125;) .catch(err =&gt; &#123; console.log(err) &#125;) Promise.prototype.then方法返回的是一个新的Promise对象，因此可以采用链式写法。 123456789101112const p = new Promise((resolve, reject) =&gt; &#123; resolve(100)&#125;)p .then(response =&gt; &#123; console.log(response) // 100 return response * 2 &#125;) .then(response =&gt; &#123; console.log(response) // 200 &#125;) 错误处理12345678910111213141516171819// 写法一const promise = new Promise((resolve, reject) =&gt; &#123; try &#123; throw new Error('test') &#125; catch(e) &#123; reject(e) &#125;&#125;)promise.catch(error =&gt; &#123; console.log(error)&#125;)// 写法二const promise = new Promise((resolve, reject) =&gt; &#123; reject(new Error('test'))&#125;)promise.catch(error =&gt; &#123; console.log(error)&#125;) 比较上面两种写法，可以发现reject方法的作用，等同于抛出错误。 如果 Promise 状态已经变成resolved，再抛出错误是无效的。 1234567const promise = new Promise((resolve, reject) =&gt;&#123; resolve('ok') throw new Error('test') // 错误不会被抛出，因为Promise的状态一旦改变就永久保持该状态不会再变了&#125;)promise .then(value =&gt; console.log(value)) // ok .catch(error =&gt; console.log(error)) catchPromise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个catch语句捕获。 一般来说，不要在then方法里面定义 Reject 状态的回调函数（即then的第二个参数），总是使用catch方法。 123456789101112131415// badpromise.then(data =&gt; &#123; // success&#125;, err =&gt; &#123; // error&#125;)// goodpromise .then(data =&gt; &#123; // success &#125;) .catch(err =&gt; &#123; // error &#125;) 吃掉错误先看一段同步代码 123console.log(a) // 会报错，因为a没有定义setTimeout(() =&gt; console.log('123'), 100)// 第一行代码报错，程序退出进程，终止脚本，所以不会输出 ”123“ 再看Promise 12345const p = new Promise((resolve, reject) =&gt; &#123; resolve(a) // 会报错，因为a没有定义&#125;)setTimeout(() =&gt; console.log('123'), 100) // 依然打印出”123“// 内部有语法错误。浏览器运行到错误的这一行，会打印出错误提示ReferenceError: a is not defined，但是不会退出进程、终止脚本执行，200 毫秒之后还是会输出123。这就是说，Promise 内部的错误不会影响到 Promise 外部的代码，通俗的说法就是“Promise 会吃掉错误”。 一般总是建议，Promise 对象后面要跟catch方法，这样可以处理 Promise 内部发生的错误。catch方法返回的还是一个 Promise 对象，因此后面还可以接着调用then方法。 Promise.resolve如果我们经常写下面这样的代码 123new Promise((resolve, reject) =&gt; &#123; resolve(同步值);&#125;).then(/* ... */); 那么我用Promise.resolve会更加简洁 1Promise.resolve(同步值).then(/* ... */) Promise.resolve()常用于创建一个已完成的Promise,但是Promise.resolve(...)也会展开thenable值。在这种情况下，返回的Promise采用传入的这个thenable的最终决议值，可能是完成，也可能是拒绝。 1234567891011121314151617const fulfilled = &#123; then(cb) &#123; cb(42) &#125; &#125; const rejected = &#123; then(cb, errCb) &#123; errCb('err') &#125; &#125; const p1 = Promise.resolve(fulfilled) // p1是完成的promise const p2 = Promise.resolve(rejected) // p2是拒绝的promise console.log(p1) // [[PromiseStatus]]: "resolved" [[PromiseValue]]: 42 console.log(p2) // [[PromiseStatus]]: "rejected" [[PromiseValue]]: "err" 如果向Promise.resolve(…)传递一个非Promise、非thenable的立即值，就会得到一个用这个值填充的promise。 123456const p1 = new Promise(resolve =&gt; &#123; resolve(100)&#125;)const p2 = Promise.resolve(100)// 以上两种情况， promise p1和promise p2的行为是完全一样的 如果向Promise.resolve(...)传递一个真正的Promise，就只会返回同一个promise 1234const p1 = Promise.resolve(100)const p2 = Promise.resolve(p1)p1 === p2 // true Promise.reject创建一个已被拒绝的Promise的快捷方式是使用Promise.reject(),所以以下两个promise是等价的： 1234const p1 = new Promise((resolve, reject) =&gt; &#123; reject('err')&#125;)const p2 = Promsie.reject('err') Promise.all1234567891011121314151617181920Promise.resolve([1, 2, 3]) .then(list =&gt; &#123; list.forEach(item =&gt; &#123; Promise.resolve(item) .then(val =&gt; &#123; console.log('forEach' + val) // 同步 &#125;) &#125;) &#125;) .then(result =&gt; &#123; console.log('遍历完了', result) &#125;) .catch(err =&gt; &#123; console.log(err) &#125;)// forEach1// forEach2// forEach3// 遍历完了undefined 异步 123456789101112131415161718192021Promise.resolve([1, 2, 3]) .then(list =&gt; &#123; list.forEach(item =&gt; &#123; Promise.resolve(item) .then(n =&gt; &#123; request(`$&#123;n&#125;.txt`) .then(response =&gt; console.log(response)) // 异步 &#125;) &#125;) &#125;) .then(result =&gt; &#123; console.log('遍历完了' + result) &#125;) .catch(err =&gt; &#123; console.log(err) &#125;)// 遍历完了undefined// forEach1// forEach2// forEach3 那么我们怎么在Promise中使用forEach呢？ 12345678910111213141516Promise.resolve([1, 2, 3]) .then(list =&gt; &#123; return Promise.all(list.map(item =&gt; request(item + '.txt'))) &#125;) .then(([data1, data2, data3]) =&gt; &#123; console.log('全部请求完毕', data1) console.log('全部请求完毕', data2) console.log('全部请求完毕', data3) &#125;) .catch(err =&gt; &#123; console.log(err) &#125;)// 全部请求完毕 111111111111// 全部请求完毕 222222222222// 全部请求完毕 333333333333 对Promise.all([...])来说，只有传入的所有promise都完成，返回promise才能完成。如果有任何promise被拒绝，返回的主promise就立即会被拒绝。如果完成的话，我们会得到一个数组，其中包含传入的所有promise完成值。对于拒绝的情况，我们只会得到一个拒绝promise的理由。 1234567891011// 需求：在请求1.txt和2.txt之后再请求3.txtconst p1 = request('1.txt')const p2 = request('2.txt')Promise.all([p1, p2]) .then(([result1, result2]) =&gt; &#123; // 这里可以把p1,和p2完成后的值传入 return request('3.txt') &#125;) .then(result3 =&gt; &#123; console.log(result3) &#125;) Promise.all([...])需要一个参数，是一个数组通常由Promise实例组成。从Promise.all[(...)]调用返回的promise会收到一个完成消息，这是一个由所有传入promise的完成消息组成的数组，与指定的顺序一致（与完成顺序无关） 严格来说，传给Promise.all([...])的数组中的值可以是Promise、thenable、甚至是立即值。就本质而言，列表中的每个值都会通过Promise.resolve(...)过滤，以确保要等待的是一个真正的Promise,所以立即值会被规范化为这个值构建的Promise。如果数组是空的，主Promise就会立即完成。 Promise.race对于Promise.race(...)来说，一旦有任何一个Promise决议完成，Promise,race([...])就会完成，一旦有任何一个Promise决议为拒绝，它就会拒绝。 123456789101112131415161718192021const p1 = Promise.resolve(42)const p2 = Promise.resolve('完成')const p3 = Promise.reject('err')Promise.race([p1, p2, p3]) .then(result =&gt; &#123; console.log(result) // 42 &#125;)Promise.all([p1, p2]) .then(result =&gt; &#123; console.log(result) // [42, "完成"] &#125;)Promise.all([p1, p2, p3]) .then(result =&gt; &#123; console.log(result) &#125;) .catch(err =&gt; &#123; console.log('错误', err) // 错误 err &#125;) 12345678910111213141516171819202122const timeoutResolve = (time, value) =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(resolve, time, value) &#125;) &#125; const timeoutReject = (time, reason) =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(reject, time, reason) &#125;) &#125;console.log(timeoutResolve()) Promise.race([ timeoutResolve(1000, '1000毫秒resolve'), timeoutResolve(40, '40毫秒resolve'), timeoutReject(50, '50毫秒reject') ]) .then( value =&gt; console.log('resolve', value), reason =&gt; console.log('reject', reason) )// resolve 40毫秒resolve 注意：如果向Promise.all([...])传入空数组，它会立即完成，但Promise.race([...])会挂住，且永远不会决议。 穿透1234567Promise.resolve('foo') .then(Promise.resolve('bar')) .then(result =&gt; &#123; console.log(result) &#125;)// foo 我们以为会输出&#39;bar&#39;,实际上却输出&#39;foo&#39;，这是为什么呢？上面我们说到then函数接收两个函数作为参数，但是如果我们不传函数作为参数会怎么样呢？ 它实际上会将其解释为 then(null)，这就会导致前一个 promise 的结果会穿透下面。 1234567Promise.resolve('foo') .then(null) .then(result =&gt; &#123; console.log(result) &#125;)// 这段代码和上一段效果是一样的// foo 添加任意数量的 then(null)，它依然会打印 foo。 正确姿势 123456Promise.resolve('foo') .then(() =&gt; Promise.resolve('bar')) .then(result =&gt; &#123; console.log(result) &#125;)// bar 记住: 永远在then()中传递函数 期待async/await更加语义化 参考文档MDN Promise/A+规范 ECMAScript 6 入门 – 阮一峰 你不知道的JavaScript:异步与性能 第三章-Promise 本文结束，感谢阅读。 本文作者：melody0z 本文链接：https://melodyvoid/JavaScript/Share-meeting--Promise.html 欢迎转载，转载请注明文本链接]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Promise</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0930]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0930.html</url>
    <content type="text"><![CDATA[必备句型​ I spent three hours cooking this meal. 我花了三小时做这顿饭 How’s the food today? 今天的饭菜怎么样 ​ 场景对话​ A: How’s the food today? B: It’s okay. A: It’s okay? I spent three hours cooking this meal. How do you think it makes me feel when you say “it’s okay” in that sullen tone? ​ 参考译文​ A: 今天的饭菜怎么样？ B: 还可以。 A: 只是还可以？我花了三小时做这顿饭，但别人却随口敷衍一句“还可以”想想看是什么感觉？ ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0929]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0929.html</url>
    <content type="text"><![CDATA[必备句型​ Word on the street is… 有传言说… I am not wasting my time talking to you. 我就不浪费自己时间了 ​ 场景对话​ A: Word on the street is, you lit that match so you could pin it on me. B: I don’t know what you are talking about.And apparently, neither do you. I am not wasting my time talking to you. ​ 参考译文​ A: 有传言说，是你放了火，然后想嫁祸于我。 B: 我不知道你在乱扯什么，很显然你也不知道自己在讲什么，我就不浪费自己的时间了。 ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0928]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0928.html</url>
    <content type="text"><![CDATA[必备句型​ What the hell is wrong with you? 您到底怎么了？ I mean it 我是认真的 ​ 场景对话​ A: I’ve had enough, I don’t wanna talk to you anymore, and I don’t want to see you again in my life. B: What the hell is wrong with you? Are you kidding me? A: No, I mean it. ​ 参考译文​ A: 我真的受够了，不想再跟你说话，这辈子都不想再见到你了。 B: 你到底怎么了？你是在开玩笑吗？ A: 不，我是认真的。 ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0927]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0927.html</url>
    <content type="text"><![CDATA[必备句型​ I’ve been thinking about this for a long time. 我思考这个问题已经很长时间了 I will always, honestly, truly, completely love you. 我都会永远真诚地，全心全意地爱你 ​ 场景对话​ A: Hey,Clair told me that you wanna talk to me. B: Yes, I’ve been thinking about this for a long time. I love you, and no matter where you are or what you are doing or who you are with. I will always, honestly, truly, completely love you. ​ 参考译文​ A: 嘿，Clair告诉我你有事跟我讲。 B: 是的，我思考这个问题已经有很长时间了。我爱你，不管你在哪里，在做什么，跟谁在一起。我都会永远真诚地，全心全意地爱你。 ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0926]]></title>
    <url>%2Funcategorized%2Fenglish-reading-plan-0926.html</url>
    <content type="text"><![CDATA[必备句型​ I have Alzheimer’s disease, early onset. 我的了阿兹海默症，早发性的。 Live in the moment, I tell myself. 我要求自己活在当下。 ​ 场景对话​ A: I need to talk to you,I’ve got something wrong with me. B: What’s going on? A: I have Alzheimer’s disease, early onset. B: My God! A: Live in the moment, I tell myself, it’s really all I can do. Live in the moment. ​ 参考译文​ A: 我有事告诉你，我生病了。 B: 出什么事了？ A: 我得了阿兹海默症，早发性的。 B: 天哪。 A: 我要求自己活在当下，我现在也只能活在当下了。 ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0925]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0925.html</url>
    <content type="text"><![CDATA[必备句型​ I still can’t believe what you have done. 我仍然没有拌饭相信你做了什么 It’s my life, I did it my way. 这是我的生活，我有自己的方式 ​ 场景对话​ A: I still can’t believe what you have done.Why did you do that? B: I know that you care about me,but I know what I am doing. It’s my life, I did it my way. ​ 参考译文​ A: 我仍然没有办法相信你做了什么，你为什么这么做？ B: 我知道你关心我，但是我知道自己在做什么。这是我的生活，我有自己的方式。 ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0924]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0924.html</url>
    <content type="text"><![CDATA[必备句型​ We hit the road early. 我们很早就出发了 Enjoy your holiday 假期愉快 ​ 场景对话​ A: When did you get there? B: We hit the road early so that we reached the village by lunchtime. A: Nice, enjoy your holiday. ​ 参考译文​ A: 你们什么时候到的？ B: 我们很早就出发了，所以午饭时间就到达村庄了。 A: 真好，假期愉快。 ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0923]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0923.html</url>
    <content type="text"><![CDATA[必备句型​ Are you travelling light? 你们轻装旅行吗？ We would only stay for three days, so we packed light. 我们只待三天，所以我们没带太多行李。 ​ 场景对话​ A: What’s your plan for the holiday? B: I’ll go to New York with my friends. A: Do you need some help collecting your luggage, or are you travelling light? B: We would only stay for three days, so we packed light. ​ 参考译文​ A: 假期有什么计划吗？ B: 我跟朋友要去纽约。 A: 需要帮忙拿行李吗还是你们是轻装旅行？ B: 我们只待三天，所以我们没带太多行李。 ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0922]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-092.html</url>
    <content type="text"><![CDATA[必备句型​ Just stay for one more cup of coffee. 再喝杯咖啡再走吧 I am leaving now. See ya! 我现在得走了，再见！ ​ 场景对话​ A: Just stay for one more cup of coffee. B: I really can’t, I’m in a hurry. A: Alright, did you forget anything? B: Oh,right. The keys, I am leaving now. See ya! ​ 参考译文​ A: 再喝杯咖啡再走吧。 B: 真得不行，我得赶紧走了！ A: 好吧，你没忘什么东西吧？ B: 噢，对了，忘拿钥匙了。我现在得走了，再见！ ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0921]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0921.html</url>
    <content type="text"><![CDATA[必备句型​ You are just blinded by your pain. 你只是被疼痛蒙蔽了双眼 There can be miracles, when you believe. 当你充满信心，奇迹就会出现 ​ 场景对话​ A: I am so sorry, I wanna give up, I just couldn’t find a way out. B: You are just blinded by your pain. There can be miracles, when you believe. All you need to do right now is just trust yourself and do your best. ​ 参考译文​ A: 对不起，我想放弃了。感觉自己找不到了出路。 B: 你只是被疼痛蒙蔽了双眼，当你充满信心，奇迹就会出现。你需要做的就是相信自己，尽自己最大的努力。 ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0920]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0920.html</url>
    <content type="text"><![CDATA[必备句型​ Do you know how long I’ve been dreaming about this day? 知道我梦想着着一天有多久了吗？ This is the happiest moment in my life. 这是我一生中最快乐的时刻 ​ 场景对话​ A: What’s the rush? B: I am sorry, I just couldn’t wait. Do you know how long I’ve been dreaming about this day?I’m finally surrounded by moment in my life. ​ 参考译文​ A: 那么急干嘛？ B: 对不起，我只是等不及了。你知道我梦想着这一天有多久了吗？我终于能跟聪明又充满好奇的人在一起了。这是我一生中最快乐的时刻。 ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0919]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0919.html</url>
    <content type="text"><![CDATA[必备句型​ I am not all that certain that little girl was you. 我有点不确定你就是当年那个小女孩 Why don’t you cut the crap and tell me what I’m really doing here? 废话少说，告诉我今天你让我来的目的吧 ​ 场景对话​ A: Actually when I come to think of it, I am not all that certain that little girl was you. B: Alright, why don’t you cut the crap and tell me what I’m really doing here? ​ 参考译文​ A: 其实，当我回想当年。我有点不确定你就是当年那个小女孩。 B: 好了，废话少说，告诉我今天你让我来的目的吧。 ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0918]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0918.html</url>
    <content type="text"><![CDATA[必备句型​ I have no idea what’s going on. 我不知道发生了什么事 We’ll be safe and sound. 我们会安然无恙的 ​ 场景对话​ A: I have no idea what’s going on. We are in big trouble this time, what should I do? B: Don’t worry about it. You’ll be alright. We’ll be safe and sound. ​ 参考译文​ A: 我不知道发生了什么事。我们这次有大麻烦了，我该怎么办？ B: 别担心，你会没事的。我们都会安然无恙的。 ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0917]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0917.html</url>
    <content type="text"><![CDATA[必备句型​ Speaking of chores, I prefer to do laundry. 说到家务杂事，我更愿意洗衣服 I don’t know how to cook. 我不会做饭 ​ 场景对话​ A: Do you like cooking? B: Not at all. Speaking of chores, I prefer to do laundry. A: How come? B: Because I don’t know how to cook. ​ 参考译文​ A: 你喜欢做饭吗？ B: 一点也不喜欢，说到家务杂事，我更愿意洗衣服。 A: 为什么？ B: 因为我不会做饭。 ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0916]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0916.html</url>
    <content type="text"><![CDATA[必备句型​ I don’t wanna explain their whole story. It’s very complicated. 我就不一一解释整个故事，太复杂了 In a nutshell, they just wanted different things. 简单地说，他们想要的东西都不一样 ​ 场景对话​ A: What’s wrong with them? B: I don’t wanna explain their whole story.It’s very complicated, but in a nutshell, they just wanted different things. She wanted travel and adventure, he wanted to focus on his career. So in the end, they broke up. ​ 参考译文​ A: 他们发生了什么事？ B: 我就不一一解释整个故事了，太复杂了。简单地说，他们想要的东西不一样，她想要旅游和冒险，他想专注于自己的事业，所以最后他们分手了。 ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0915]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0915.html</url>
    <content type="text"><![CDATA[必备句型​ How about a cup of coffee at a nearby cafe? 去附近的咖啡屋喝杯咖啡吧。 I’ll have a soy latte. 我要豆奶拿铁咖啡。 ​ 场景对话​ A: How about a cup of coffee at a nearby cafe? B: That’s nice, what would you like to drink? A: I am a little hungry, I want some muffins, and a cup of cappuccino. B: I’ll have a soy latte. ​ 参考译文​ A: 去附近的咖啡屋喝杯咖啡吧？ B: 好啊，你想喝什么？ A: 我有点饿了，我想要一些松饼，还有一杯卡布奇诺。 B: 我要豆奶拿铁咖啡。 ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[八段代码理解Promise]]></title>
    <url>%2FJavaScript%2Feight-sections-of-code-understanding-promise.html</url>
    <content type="text"><![CDATA[Promise的立即执行性12345678910let p = new Promise((resolve,reject)=&gt;&#123; console.log("create a promise"); resolve("success");&#125;);console.log("after new Promise");p.then((value)=&gt;&#123; console.log(value);&#125;); 控制台输出 123create a promiseafter new Promisesuccess Promise对象表示未来某个将要发生的事件，但在创建（new）Promise时，作为Promise参数传入的函数是会被立即执行的，只是其中执行的代码可以是异步代码。有些同学会认为，当Promise对象调用then方法时，Promise接收的函数才会执行，这是错误的。因此，代码中”create a promise”先于”after new Promise”输出。 Promise三种状态123456789101112131415161718192021222324252627282930313233343536373839let p1 = new Promise((resolve,reject)=&gt;&#123; resolve(1);&#125;);let p2 = new Promise((resolve,reject)=&gt;&#123; setTimeout(()=&gt;&#123; resolve(2); &#125;,500)&#125;);let p3 = new Promise((resolve,reject)=&gt;&#123; setTimeout(()=&gt;&#123; reject(3); &#125;,500)&#125;);console.log(p1); //Promise &#123;[[PromiseStatus]]: "resolved", [[PromiseValue]]: 1&#125;console.log(p2); //Promise &#123;[[PromiseStatus]]: "pending", [[PromiseValue]]: undefined&#125;console.log(p3); //Promise &#123;[[PromiseStatus]]: "pending", [[PromiseValue]]: undefined&#125;setTimeout(()=&gt;&#123; console.log(p2); //Promise &#123;[[PromiseStatus]]: "resolved", [[PromiseValue]]: 2&#125;&#125;,1000);setTimeout(()=&gt;&#123; console.log(p3) //Promise &#123;[[PromiseStatus]]: "rejected", [[PromiseValue]]: 3&#125;&#125;,1000);p1.then(value=&gt;&#123; console.log(value); //1&#125;);p2.then(value=&gt;&#123; console.log(value); //2&#125;);p3.catch(err=&gt;&#123; console.log(err) //3&#125;); 控制台输出 12345678Promise &#123;[[PromiseStatus]]: "resolved", [[PromiseValue]]: 1&#125;Promise &#123;[[PromiseStatus]]: "pending", [[PromiseValue]]: undefined&#125;Promise &#123;[[PromiseStatus]]: "pending", [[PromiseValue]]: undefined&#125;123Promise &#123;[[PromiseStatus]]: "resolved", [[PromiseValue]]: 2&#125;Promise &#123;[[PromiseStatus]]: "rejected", [[PromiseValue]]: 3&#125; Promise的内部实现是一个状态机。Promise有三种状态：pending、resolved、rejected。当Promise刚创建完成时，处于pending状态；当Promise中的函数参数执行了resolve后，Promise由pending状态变成resolved状态；如果在Promise的函数参数中执行的不是resolve方法，而是reject方法，那么Promise会由pending状态变成rejected状态。 p2/p3刚创建完成时，控制台输出的这两台Promise都处于pending状态，但为什么p1是resolved状态呢？这是因为p1的函数参数中执行的是一段同步代码，Promise刚创年完成，resolve方法就已经被调用了，因而紧跟着的输出显示p1是resolved状态。我们通过两个setTimeout函数，延迟1s后再次输出p2、p3的状态，此时p2、p3已经执行完成，状态分别变成resolved和rejected。 Promise状态的不可逆性1234567891011121314151617let p1 = new Promise((resolve,reject)=&gt;&#123; resolve("success1"); resolve("success2");&#125;);let p2 = new Promise((resolve,reject)=&gt;&#123; resolve("success"); reject("reject");&#125;);p1.then(value=&gt;&#123; console.log(value);&#125;);p2.then(value=&gt;&#123; console.log(value);&#125;); 控制台输出 12success1success Promise状态一旦变成resolve或rejected时，Promise的状态和值就固定下来了，不论你后续再怎么调用resolve或reject方法，都不能改变它的状态和值。因此，p1中resolve(“success2”)并不能将p1的值更改为success2，p2中reject(“reject”)也不能将p2的状态由resolved改变为rejected。 链式调用1234567891011121314151617181920let p = new Promise((resolve,reject)=&gt;&#123; resolve(1);&#125;);p.then(value=&gt;&#123; //第一个then console.log(value); //1 return value * 2;&#125;).then(value=&gt;&#123; //第二个then console.log(value); //2&#125;).then(value=&gt;&#123; //第三个then console.log(value); //undefined return Promise.resolve('resolve')&#125;).then(value=&gt;&#123; //第四个then console.log(value); //'resolve' return Promise.reject('reject')&#125;).then(value=&gt;&#123; //第五个then console.log('resolve:' + value)&#125;,err=&gt;&#123; console.log('reject:' + err); //'reject:reject'&#125;); 控制台输出： 1234512undefinedresolvereject:reject Promise对象的then方法返回一个新的Promise对象，因此可以通过链式调用then方法。then方法接收两个函数作为参数，第一个参数是Promise执行成功时的回调，第二个参数是Promise执行失败时的回调。两个函数只会有一个被调用，函数的返回值将被用作创建then返回的Promise对象。这两个参数的返回值可以是以下三种情况中的一种： return 一个同步的值 ，或者 undefined（当没有返回一个有效值时，默认返回undefined），then方法将返回一个resolved状态的Promise对象，Promise对象的值就是这个返回值。 return 另一个 Promise，then方法将根据这个Promise的状态和值创建一个新的Promise对象返回。 throw 一个同步异常，then方法将返回一个rejected状态的Promise, 值是该异常。 根据以上分析，代码中第一个then会返回一个值为2（1*2），状态为resolved的Promise对象，于是第二个then输出的值是2。第二个then中没有返回值，因此将返回默认的undefined，于是在第三个then中输出undefined。第三个then和第四个then中分别返回一个状态是resolved的Promise和一个状态是rejected的Promise，依次由第四个then中成功的回调函数和第五个then中失败的回调函数处理。 Promise then()回调异步性123456789let p = new Promise((resolve,reject)=&gt;&#123; resolve("success")&#125;);p.then(value=&gt;&#123; console.log(value);&#125;);console.log("which one is called first?"); 控制台输出： 12which one is called first?success Promise接收的函数参数是同步执行的，但then方法中的回调函数执行则是异步的，因此，”success”会在后面输出。 Promise中的异常12345678910111213141516171819202122232425262728293031323334let p1 = new Promise((resolve,reject)=&gt;&#123; foo.bar(); resolve(1);&#125;);p1.then((value)=&gt;&#123; console.log('p1 then value:' + value); //&#125;,(err)=&gt;&#123; console.log('p1 then err:' + err);&#125;).then((value)=&gt;&#123; console.log('p1 then then value:' + value);&#125;,(err)=&gt;&#123; console.log('p1 then then err:' + err);&#125;);let p2 = new Promise((resolve,reject)=&gt;&#123; resolve(2);&#125;);p2.then((value)=&gt;&#123; console.log('p2 then value:' + value); foo.bar();&#125;,(err)=&gt;&#123; console.log('p2 then err:' + err);&#125;).then((value)=&gt;&#123; console.log('p2 then then value:' + value);&#125;,(err)=&gt;&#123; console.log('p2 then then err:' + err); return 1;&#125;).then((value)=&gt;&#123; console.log('p2 then then then value:' + value);&#125;,(err)=&gt;&#123; console.log('p2 then then then err:' + err);&#125;); 控制台输出： 12345p1 then err:ReferenceError: foo is not definedp2 then value:2p1 then then value:undefinedp2 then then err:ReferenceError: foo is not definedp2 then then then value:1 Promise中的异常由then参数中第二个回调函数（Promise执行失败的回调）处理，异常信息将作为Promise的值。异常一旦得到处理，then返回的后续Promise对象将恢复正常，并会被Promise执行成功的回调函数处理。另外，需要注意p1、p2 多级then的回调函数是交替执行的 ，这正是由Promise then回调的异步性决定的。 Promise.resolve()1234567891011121314151617181920212223242526let p1 = Promise.resolve(1);let p2 = Promise.resolve(p1);let p3 = new Promise((resolve,reject)=&gt;&#123; resolve(1);&#125;);let p4 = new Promise((resolve,reject)=&gt;&#123; resolve(p1);&#125;);console.log(p1 === p2);console.log(p1 === p3);console.log(p1 === p4);console.log(p3 === p4);p4.then((value)=&gt;&#123; console.log('p4=' + value);&#125;);p2.then((value)=&gt;&#123; console.log('p2=' + value);&#125;);p1.then((value)=&gt;&#123; console.log('p1=' + value);&#125;); 控制台输出(node v8.2.1) 1234567truefalsefalsefalsep4=1p2=1p1= 在Chrome或Safari的控制台里 1234567truefalsefalsefalsep2=1p1=1p4=1 Promise.resolve(...)可以接受一个值或者一个Promise对象作为参数。 当参数是普通值时，它返回一个resolved状态的Promise对象，对象的值就是这个参数； 当参数是一个Promise对象时，它直接返回这个Promise参数。 因此，p1 === p2。但通过new的方式创建的Promise对象都是一个新的对象，因此后面的三个比较结果都是false。另外，为什么p4的then最先调用，但在控制台上是最后输出结果的呢？因为p4的resolve中接收的参数是一个Promise对象p1，resolve会对p1“拆箱”，获取p1的状态和值，但这个过程是异步的。 resolve vs reject123456789101112131415161718192021222324let p1 = new Promise((resolve, reject) =&gt; &#123; resolve(Promise.resolve("resolve"));&#125;);let p2 = new Promise((resolve, reject) =&gt; &#123; resolve(Promise.reject("reject"));&#125;);let p3 = new Promise((resolve, reject) =&gt; &#123; reject(Promise.resolve("resolve"));&#125;);p1.then(value =&gt; &#123; console.log("fulfilled:" + value); //fulfilled:resolve&#125;, err =&gt; &#123; console.log("rejected:" + err)&#125;);p2.then(value =&gt; &#123; console.log("fulfilled:" + value);&#125;, err =&gt;&#123; console.log("rejected:" + err); //rejected: reject&#125;);p3.then(value =&gt; &#123; console.log("fulfilled:" + value);&#125;, err =&gt;&#123; console.log("rejected:" + err); //rejected:[object Promise]&#125;); 控制台输出： 123rejected:[object Promise]fulfilled:resolverejected:reject Promise回调函数中的第一个参数resolve，会对Promise执行“拆箱”动作。即当resolve的参数是一个Promise对象时，resolve会“拆箱”获取这个Promise对象的状态和值，但这个过程是异步的。p1“拆箱”后，获取到Promise对象的状态时resolved，因此fulfilled回调被执行；p2”拆箱“后，获取到Promise对象的状态是rejected，因此rejected回调被执行。但Promise回到函数中的第二个参数reject不具备”拆箱“的能力，reject的参数会直接传递给then方法中的rejected回调。因此，即使p3reject接受了一个resolveed状态的Promise，then方法中被调用的依然是rejected,并且参数就是reject接收到的Promise对象。 参考地址：https://juejin.im/post/597724c26fb9a06bb75260e8?utm_source=gold_browser_extension 本文结束，感谢阅读。 本文作者： 苍山沭河本文链接：https://melodyvoid.github.io/JavaScript/eight-sections-of-code-understanding-promise.html 欢迎转载，转载请注明文本链接]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Promise</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0914]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0914.html</url>
    <content type="text"><![CDATA[必备句型​ Life is a journey, we need to experience a lot of things. 人生如旅，我们需要经历很多事情。 I know I’m not the only one who regrets the things they’ve done. 我知道并非只有我自己后悔曾经做过的事。 ​ 场景对话​ A: Life is a journey, we need to experience a lot of things, to learn and to enjoy. Don’t you think so? B: You are absolutely right.I have some regrets though, but I konw I’m not the only one who regrets the things they’ve done. ​ 参考译文​ A: 人生如旅，我们需要经历很多事情，去学习和享受。你不这样觉得吗？ B: 完全正确，我也有一些遗憾，但是我知道并非只有我自己后悔曾经做过的事。 ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vuex官方文档学习]]></title>
    <url>%2Fvuex%2Fvuex-oficial-document-learning.html</url>
    <content type="text"><![CDATA[安装vuexnpm install vuex --save 捎带脚把element-ui也安装上了 npm install element --save #引入vuex 然后再main.js中引入vuex和element-ui 123456import ElementUI from 'element-ui'import 'element-ui/lib/theme-default/index.css'import Vuex from 'vuex'Vue.use(ElementUI)Vue.use(Vuex) Vuex是什么？Vuex是一个专为vue.js应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。 我们写个小的计数器Hello.vue中 123456789101112131415161718192021222324252627&lt;template&gt; &lt;div class=&quot;hello&quot;&gt; &lt;h1&gt;&#123;&#123; msg &#125;&#125;&lt;/h1&gt; &lt;el-button @click=&quot;increment&quot;&gt;增加&lt;/el-button&gt; &lt;el-button type=&quot;primary&quot;&gt;减少&lt;/el-button&gt; &lt;h1&gt;&#123;&#123; count &#125;&#125;&lt;/h1&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: &apos;hello&apos;, //state data () &#123; return &#123; msg: &apos;Welcome to Your Vue.js App&apos;, count: 0 &#125; &#125;, //aactions methods: &#123; increment () &#123; this.count++ &#125; &#125; &#125;&lt;/script&gt; 这个计数器包含以下几个部分： state, 驱动应用的数据源 view, 以生命方式将state映射到视图 (即模板template) actions, 响应在view上的用户输入导致的状态变化 但是，当我们的应用遇到多个组件共享状态时，单项数据流的简洁性就很容易被破坏： 多个视图依赖于同一状态 来自不同视图的行为需要变更同一状态 对于问题一，传参的方法对于多层嵌套的组件将会非常的繁琐，并且对于兄弟组件间的状态传递无能为力。 对于问题二，我们经常会采用父子组件直接引用或者通过事件来变更和同步状态的多份拷贝。以上的这些模式非常脆弱，通常会导致无法维护的代码。 因此，我们为什么不把组件的共享状态抽取出来，以一个全局单例模式管理呢？在这种模式下，我们的组件树构成了一个巨大的“视图”，不管在树的哪个位置，任何组件都能获取状态或者触发行为。 另外，通过定义和隔离状态管理中的各种概念并强制遵守一定的规则，我们的代码将会变得更结构化且易维护。 开始每一个Vuex应用的核心就是store（仓库）。“store”基本上就是一个容器，它包含着你的应用中大部分状态（state）。Vuex和单纯的全局对象有以下两点不同： Vuex的状态存储是响应式的。当Vue组件从store中读取状态的时候，若store中的状态发生变化，那么相应的组件也会相应地得到高效更新。 你不能直接改变store中的状态。改变store总的状态的唯一途径就是显式地提交(commit)mutations。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。 简单的计数器 1234567&lt;div id="app"&gt; &lt;p&gt;&#123;&#123; count &#125;&#125;&lt;/p&gt; &lt;p&gt; &lt;button @click="increment"&gt;+&lt;/button&gt; &lt;button @click="decrement"&gt;-&lt;/button&gt; &lt;/p&gt;&lt;/div&gt; 12345678910111213141516171819202122232425262728// make sure to call Vue.use(Vuex) if using a module systemconst store = new Vuex.Store(&#123; state: &#123; count: 0 &#125;, mutations: &#123; increment: state =&gt; state.count++, decrement: state =&gt; state.count-- &#125;&#125;)new Vue(&#123; el: '#app', computed: &#123; count () &#123; return store.state.count &#125; &#125;, methods: &#123; increment () &#123; store.commit('increment') &#125;, decrement () &#123; store.commit('decrement') &#125; &#125;&#125;) State在Vue组件中获得Vuex状态在store实例中读取状态最简单的方法就是在计算属性中返回某个状态， 项目结构Vuex并不限制你的代码结构。但是，它规定了一些需要遵守的规则： 应用层级的状态应该集中到单个store对象中。 提交mutation是更改状态的唯一方法，并且这个过程是同步的。 异步逻辑都应该封装到action里面。 只要你遵守以上规则，如何组织代码随便。如果你的store文件太大，只需将action、mutation、和getters分割到单独的文件。 对于大型应用，我们会希望把Vuex相关代码分割到模块中。下面是结构实例： 1234567891011121314├── index.html├── main.js├── api│ └── ... # 抽取出API请求├── components│ ├── App.vue│ └── ...└── store ├── index.js # 我们组装模块并导出 store 的地方 ├── actions.js # 根级别的 action ├── mutations.js # 根级别的 mutation └── modules ├── cart.js # 购物车模块 └── products.js # 产品模块 本文结束，感谢阅读。 本文作者：melody0z 本文链接：https://melodyvoid/ 欢迎转载，转载请注明文本链接]]></content>
      <categories>
        <category>vuex</category>
      </categories>
      <tags>
        <tag>vuex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0913]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0913.html</url>
    <content type="text"><![CDATA[必备句型​ This is role-playing game. 这是一个角色扮演游戏 I’m still a newbie. 我还是个新手 ​ 场景对话​ A: This is a role-playing game. B: The game sounds boring to me, maybe because I’m still a newbie. Can you show me how to play this game? A: Okay, but I want you to follow me on Twitter first. ​ 参考译文​ A: 这是一个角色扮演游戏。 B: 对我而言，这个游戏很无聊。可能是因为我还是个新手，你能告诉我怎么玩的吗？ A: 可以啊，但是我想让先关注我的推特。 ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0912]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0912.html</url>
    <content type="text"><![CDATA[必备句型​ The entire thing was a scam, you are a liar. 这整件事就是个骗局。 You’re overreacting, I wouldn’t tell lies to you. 你反应过激了，我不会对你说谎的。 ​ 场景对话​ A: Tell me what did you do last week. B: You still don’t believe me. A: The entire thing was a scam, you are a liar. B: You’re overreacting, I wouldn’t tell lies to you. I will never lie to you, and I am not a liar. ​ 参考译文​ A: 告诉我你上周做了什么。 B: 你还是不相信我。 A: 这整件事就是个骗局，你这个骗子。 B: 你反应过激了，我不会对你说谎的，我永远也不会欺骗你，我根不是骗子。 ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0911]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-091.html</url>
    <content type="text"><![CDATA[必备句型​ What a mess! 怎么这么乱！ I have to say that I don’t feel like doing the dishes today. 不得不说我今天不想洗碗。 ​ 场景对话​ A: Oh my God, What a mess! B: But the dinner is ready! A: Alright, let’s enjoy the dinner first. B: Okay, but I have to say that I don’t feel like doing the dishes today. I really tired. A: Fine, I’ll do it. ​ 参考译文​ A: 天啊，怎么这么乱！ B: 但是晚餐准备好啦！ A: 好吧，先吃饭。 B: 但是我不得不说我今天不想洗碗，我真的很累。 A: 好吧，我来。 ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0910]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0910.html</url>
    <content type="text"><![CDATA[必备句型​ It’s too late, I really have to go. 太晚了，我现在必须得走了。 Keep in touch, I hope to see you soon. 保持联系，希望很快再见到你。 ​ 场景对话​ A: Thank you so much for inviting me today, I had a wonderful evening with you. But I am afraid that I have to go right now. B: Can’t you stay a little longer? A: It’s too late, I really have to go. I hope we’ll get together again soon. B: Okay, keep in touch, I hope to see you soon. ​ 参考译文​ A: 谢谢你yao’iqng’w邀请我，今晚过得很愉快。但是kong恐怕现在我得走了。 B: 不能多待一会儿吗？ A: 太晚了，我现在必须得走了，希望不久以后可以再相聚。 B: 那好，保持联系，希望很快再见到你。 ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0909]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0909.html</url>
    <content type="text"><![CDATA[必备句型​ Would you like to hang out? 要不要出去逛逛？ It’s so good to get close to the nature. 和大自然亲近真好。 ​ 场景对话​ A: It’s Saturday again! Would you like to hang out? B: I’m going for a hike, I am also planning to go camping this weekend with my friends. Do you wanna go with us? A: Sure, It’s so good to get close to the nature. ​ 参考译文​ A: 又到周六啦！要不要出去逛逛？ B: 我打算图徒步旅行，也跟朋友计划去野营。你想要一起去吗？ A: 当然啦，和大自然亲近真好。 ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0908]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0908.html</url>
    <content type="text"><![CDATA[必备句型​ You look familiar,have we met before ? 你看起来很面熟，我们以前见过吗？ You’ve got the wrong person. 你认错人了。 ​ 场景对话​ A: Is this seat taken ? B: No. A: Excuse me, you look familiar, have we met before? B: I don’t think so. You’ve got the wrong person. A: No, I am sure I’ve met you somewhere. ​ 参考译文​ A: 这个座位有人坐吗？ B: 没人。 A: 不好意思，你看起来很面熟，我们以前见过吗？ B: 没有，没见过。你认错人了。 A: 不，我肯定在哪见过你。 ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0907]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0907.html</url>
    <content type="text"><![CDATA[必备句型​ Is it scary to sleep in your house after it was broken into ? 家里被人闯过之后，现在晚上睡觉会害怕吗？ It’s a nightmare. 就是场噩梦。 ​ 场景对话​ A: You still look pale. How’s everything? B: I’m okay now. A: Is it scary to sleep in your house after it was broken into? B: Yes,definitely. It’s a nightmare. I was terrified. ​ 参考译文​ A: 你看上去脸色还是不太好。一切还好吧？ B: 我现在好了。 A: 家里被闯入过了之后，现在晚上睡觉还会害怕吗？ B: 是的，当然啦。就是场噩梦，我当时都吓坏了。 ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0906]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0906.html</url>
    <content type="text"><![CDATA[必备句型​ I highly recommend Ordinary World. 我强烈推荐《平凡的世界》 You should really have a look. 你真的可以看看 ​ 场景对话​ A: Do you like reading? B: Yes, of course. I really enjoy reading books and collecting books. A: I highly recommend Ordinary World. This is the most wonderful book I’ve ever read. You should really have a look. 参考译文​ A: 你喜欢看书吗？ B: 是的，非常感兴趣。我对看书和藏书都很喜欢。 A: 我强烈推荐《平凡的shi’j世界》。这是我读过最棒的一本书，你真的可以看看。 ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0905]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0905.html</url>
    <content type="text"><![CDATA[必备句型​ Joey and I are engaged! 我和Joey订婚了。 I feel that I am the luckiest person in the world. 我感觉自己是这个世界上最幸运的人。 ​ 场景对话​ A: Joey and I are engaged. B: Wow! Congrats! A: I feel that I am the luckiest person in the world and the wedding is in 3 weeks. I am really excited. B: That’s amazing, I wish you both have a wonderful life together. ​ 参考译文​ A: 我和Joey订婚了。 B: 太好了，恭喜你们！ A: 我感觉自己是这个世界上最幸运的人，婚礼三周后就举行了。我好兴奋啊！ B: 太棒了，希望你们有一个幸福的生活。 ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0904]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0904.html</url>
    <content type="text"><![CDATA[必备句型​ You have to promise that you won’t tell anyone. 你必须保证你不会告诉其他人。 Your secert is safe with me. 我会保守秘密的。 ​ 场景对话​ A: Something is wrong, I’ve made a mistake. B: What happened? Do you need help? A: You have to promise that you won’t tell anyone. B: Sure,I’m your best friend. Your secret is safe with me. ​ 参考译文​ A: 坏事了，我犯错了。 B: 发生了什么？有什么需要帮忙的吗？ A: 你必须保证不告诉其他人。 B: 当然啦，我可是你最好的朋友，我会保守秘密的。 ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0903]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0903.html</url>
    <content type="text"><![CDATA[必备句型​ You haven’t returned any of my callls. 你一个电话也没给我回。 Please, don’t call me anymore. 以后再也不要给我打电话了。 ​ 场景对话​ A: Hey, can I talk to you for a minutes? B: What’s wrong? A: Where have you been lately? You haven’t returned any of my calls. B: We’re done, Charles.Please, don’t call me anymore. A: If that’s what you want. ​ 参考译文​ A: 嘿，能跟你聊聊吗？ B: 怎么了？ A: 你最近都上哪了？一个电话都没给我回。 B: 我们之间结束了，Charles.以后再也不要给我打电话了。 A: 如果你想要这样的话。 ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0901]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0901.html</url>
    <content type="text"><![CDATA[必备句型​ I know, and I don’t blame you. 我知道，我不怪你。 Thank you for your understanding. 谢谢你的理解。 ​ 场景对话​ A: I never told my family we adopted a baby. B: I know, and I don’t blame you, I know your family. If you told them, they would say something judgmental. A: Exactly.Thank you for your understanding. ​ 参考译文​ A: 我还没告诉我家人我们领养了一个孩子。 B: 我知道，我不怪你，我了解你家人。你一告诉他们，他们就会说三道四。 A: 就是这样，谢谢你的理解。 ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0831]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0831.html</url>
    <content type="text"><![CDATA[必备句型​ I am afraid that I can’t agree with you. 我不太同意你的看法。 I’m just not a big fan of horror movies. 我不太喜欢看恐怖片。 ​ 场景对话​ A: I think it is one of the best movies I’ve seen this year. What do you think of it? B: I am afraid that I can’t agree with you, it’s not so good. A: How come? B: I’m just not a big fan of horror movies. ​ 参考译文​ A: 我觉得这是我今年看过的最好的电影之一。你觉得呢？ B: 我不太同意你的看法，这部电影没那么好。 A: 怎么会？ B: 我不太喜欢看恐怖片。 ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0830]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0830.html</url>
    <content type="text"><![CDATA[必备句型​ Are you feeling better? 你感觉好点了吗？ You look much better, and we all care about you. 你看上去气色好多了，我们都很关心你。 ​ 场景对话​ A: Are you feeling better? B: I’m healing fast. A: That’s good, how long do you have to stay? B: You look much better, and we all care about you. By the way, I am looking forward to playing basketball with you again. ​ 参考译文​ A: 你感觉好点了吗？ B: 我恢复得很快。 A: 太好了，你还要在这里待多久？ B: 差不多还要一周。 A: 你看上去气色好多了，我们都很关心你。瞬变说一下，我还期待着跟你再打一次篮球呢。 ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0829]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0829.html</url>
    <content type="text"><![CDATA[必备句型​ Is there anything worth watching on the channel? 有什么好看的节目吗？ But the first season is over. 但是第一季已经演完了。 ​ 场景对话​ A: Is there anything worth watching on the channel? B: I heard that you love Grimm, but the first season is over,right? A: Yes, Fortunately, the second season is showing on TV at the moment, so I can catch up with it now. ​ 参考译文​ A: 有什么好看的节目吗？ B: 我听说你超喜欢《格林》，但是第一季已经演完了，是吗？ A: 是演完了，幸运的是第二季又开始播了，我又有机会追这部剧了。 ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0828]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0828.html</url>
    <content type="text"><![CDATA[必备句型​ You mean the world to me. 你是我的一切。 Let me take care of you forever. 让我来照顾你一辈子吧。 ​ 场景对话​ A: After all of this, I think that I can’t live without you. B: I feel the same way, Charles. You mean the world to me, and thank you for being my boyfriend and being around. A: Let me take care of you forever. Annie. ​ 参考译文​ A: 经历了所有这些之后，我想不能没有你。 B: 我也是，Charles.你说我的一切，谢谢你当我的男朋友，并且一直陪在我的身边。 A: 让我来照顾你一辈子吧，Annie。 ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0827]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0827.html</url>
    <content type="text"><![CDATA[必备句型​ He would do anything to help the people in need. 他会尽力帮助有困难的人。 He has a bad temper though. 他确实脾气不好。 ​ 场景对话​ A: He’s warm-hearted, he would do anything to help the people in need. B: Well,that’s true.But I still couldn’t believe that he yelled at the waitress last week. A: I know. He has a bad temper though. ​ 参考译文​ A: 他很热心，会尽力帮助有困难的人。 B: 是的。但是我还是无法相信他上周朝服务员大声喊叫。 A: 我知道，他确实脾气不好。 ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0826]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0826.html</url>
    <content type="text"><![CDATA[必备句型​ I’m afraid that I don’t have enough time to take care fo the pets. 我恐怕没有那么多时间照顾宠物。 I am going to walk the dog. 我要去遛狗了。 ​ 场景对话​ A: Wow,You really like your dog. B: Yes, he means a lot to me. I consider him as a part of the family. A: I’m afraid that I don’t have enough time to take care fo the pets. B: You are just too busy, anyway,I am going to walk the dog.Talk to you later. ​ 参考译文​ A: 哇，你真的很爱你的狗。 B: 是啊，他对我来说可重要了，我把他看成是家庭的一份子。 A: 我恐怕没有那么多时间照顾宠物。 B: 你就是太忙了，我要去遛狗了。 ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[caller和callee]]></title>
    <url>%2Funcategorized%2Fcaler-and-cale.html</url>
    <content type="text"><![CDATA[caller返回一个函数的引用，这个函数调用了当前的函数;callee放回正在执行的函数本身的引用，它是arguments的一个属性 #caller caller返回一个函数的引用，这个函数调用了当前的函数。使用这个属性要注意:1 这个属性只有当函数在执行时才有用2 如果在JavaScript程序中，函数是由顶层调用的，则返回null functionName.caller: functionName是当前正在执行的函数。 1234567var a = function() &#123; alert(a.caller); &#125; var b = function() &#123; a(); &#125; b(); 上面的代码中，b调用了a，那么a.caller返回的是b的引用，结果如下: 123var b = function() &#123; a(); &#125; 如果直接调用a(即a在任何函数中被调用，也就是顶层调用),返回null: 12345678var a = function() &#123; alert(a.caller); &#125; var b = function() &#123; a(); &#125; //b(); a(); 输出结果:null #callee callee放回正在执行的函数本身的引用，它是arguments的一个属性使用callee时要注意:1 这个属性只有在函数执行时才有效2 它有一个length属性，可以用来获得形参的个数，因此可以用来比较形参和实参个数是否一致，即比较arguments.length是否等于arguments.callee.length3 它可以用来递归匿名函数。 1234567var a = function() &#123; alert(arguments.callee); &#125; var b = function() &#123; a(); &#125; b(); a在b中被调用，但是它返回了a本身的引用，结果如下: 123var a = function() &#123; alert(arguments.callee); &#125; 1 ：caller 返回一个调用当前函数的引用 如果是由顶层调用的话 则返回null （举个栗子哈 caller给你打电话的人 谁给你打电话了 谁调用了你 很显然是下面a函数的执行 只有在打电话的时候你才能知道打电话的人是谁 所以对于函数来说 只有caller在函数执行的时候才存在） 1234567891011var callerTest = function() &#123; console.log(callerTest.caller); &#125;;function a() &#123; callerTest() ; &#125;a() ;//输出function a() &#123;callerTest();&#125;callerTest() ;//输出null 2 ：callee 返回一个正在被执行函数的引用 （这里常用来递归匿名函数本身 但是在严格模式下不可行） ​ callee是arguments对象的一个成员 表示对函数对象本身的引用 它有个length属性（代表形参的长度） 1234567var c = function(x,y) &#123; console.log(arguments.length,arguments.callee.length,arguments.callee)&#125;;c(1,2,3);//输出3 2 function(x,y)&#123;console.log(arguments.length,arguments.callee.length,arguments.callee)&#125; 本文结束，感谢阅读。 本文作者：melody0z 本文链接：https://melodyvoid/ 欢迎转载，转载请注明文本链接]]></content>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0825]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0825.html</url>
    <content type="text"><![CDATA[必备句型​ I am going to have a picnic with my friends. 我打算跟朋友去野餐。 I think we have a bad connection. 我觉得信号不太好。 ​ 场景对话​ A: Hey, Frank. It’s me, Allen. Do you have any plans for this weekend? B: I am going to have a picnic with my friends. A: I think we have a bad connection, could you speak a little bit louder please? B: Okay,I’ll call you back. ​ 参考译文​ A: 嘿，Frank，是我Allen，你这周末有什么安排吗？ B: 我打算跟朋友去野餐。 A: 我觉得信号不太好，你能说大声点吗？ B: 好的，我再打给你。 ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0824]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0824.html</url>
    <content type="text"><![CDATA[必备句型​ The food is extremely delicious but so spicy! 事物非常好吃就是太辣了。 I am kind of picky about what I eat. 我吃东西比较挑剔。 ​ 场景对话​ A: Hello,everybody. The party is going to begin and let’s start eating now. B: Wow, the food is extremely delicious but so spicy. A: Do you like spicy food? B: I am kind of picky about what I eat, but I love spicy food. ​ 参考译文​ A: 大家好，派对马上开始，现在咱们开始吃吧。 B: 食物非常好吃就是太辣了。 A: 你喜欢吃辣的吗？ B: 我吃东西比较挑剔，但是我很爱吃辣的。 ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0823]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0823.html</url>
    <content type="text"><![CDATA[必备句型​ I must apologize for the mistake. Please forgive me. 我必须为了这个错误向你道歉，请原谅我。 It’s not all your fault, never mind. 也不全是你的错，没关系。 ​ 场景对话​ A: Look at what you have done. B: I’m so sorry. I didn’t mean it. I must apologize for the mistake. Please forgive me. A: It’s not all your fault,never mind. B: Are we still firends? A: Sure. ​ 参考译文​ A: 看看你都做了什么？ B: 对不起，我不是故意的。我必须为了这个错误向你道歉，请原谅我。 A: 也不全是你的错，没关系。 B: 我们还是朋友吗？ A: 当然。 ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0822]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-082.html</url>
    <content type="text"><![CDATA[必备句型​ It’s been a while, how’s it going? 有段时间没见了，你最近好吗？ You deserve it! 这是你应得的 ​ 场景对话​ A: Hi, It’s been a while, how’s it going? B: Pretty good. A: Any good news? B: I passed the exam last week. A: Wow, that’s nice. You are a hard-working girl, you deserve it. ​ 参考译文​ A: 嗨，有段时间不见了，你最近好吗？ B: 非常好。 A: 有什么好消息吗？ B: 我上周通过了考试。 A: 哇，太好了。你很勤奋，这是你应得的。 ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0821]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0821.html</url>
    <content type="text"><![CDATA[必备句型​ I have to say that I don’t like classical music very much. 我不得不说我不太喜欢古典音乐。 Rock and roll helps me escape from the pressures of life. 摇滚能释放我的生活压力。 ​ 场景对话​ A: Can you sing, Tom? B: Nope, but I like classical music a lot. A: I have to say that I don’t like classical music very much. B: What kind of music do you like? A: I am a rock and roll person. Rock and roll helps me escape from the pressures of life. ​ 参考译文​ A: Tom,你会唱歌吗？ B: 不，但是我很喜欢古典音乐。 A: 我不得不说我不太喜欢古典音乐。 B: 你喜欢什么音乐？ A: 我爱摇滚，你知道的，摇滚能释放我的生活压力。 ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0820]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0820.html</url>
    <content type="text"><![CDATA[必备句型​ Don’t give me that look. 别这样看我。 Believe it or not, I didn’t do that. 信不信由你，我没那样做。 ​ 场景对话​ A: How could you do this to me? B: Don’t give that look, it’s not my fault. A: Why did you do that? B: Believe it or not, I didn’t do that.There’s no need for me to explain if you don’t believe me. ​ 参考译文​ A: 你怎么能这样对我？ B: 别这样看我，不是我的错。 A: 你为什么那样做？ B: 信不信由你，我没那样做。你不相信我，我也没有必要解释。 ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0819]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0819.html</url>
    <content type="text"><![CDATA[必备句型​ You are so pretty and I really like your T-shirt. 你太好看了，我真的很喜欢你的T恤。 That’s a steal. 真便宜。 ​ 场景对话​ A: Wow, look at you, You are so pretty and I really like your T-shirt. B: Thank you. A: How much is it? B: 5 dollars. A: That’s a steal. ​ 参考译文​ A: 哇，看看你！太好看了，我真的很喜欢你的T恤。 B: 谢谢。 A: 多少钱？ B: 5美元。 A: 真便宜。 ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0818]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0818.html</url>
    <content type="text"><![CDATA[必备句型​ Why are you staring at me? 你为什么盯着我看。 I think I have a crush on you 我觉得我喜欢上你了。 ​ 场景对话​ A: What’s wrong? B: I wanna talk to you. A: But why are you staring at me? B: Look, We’ve been going out together for a couple of times, I think I have a cursh on you. ​ 参考译文​ A: 怎么了？ B: 想跟你聊聊。 A: 但是你干嘛盯着我看？ B: 我们一起出去玩过几次了，我觉得我喜欢上你了。 ​ 短语分享​ I have no choice. 我别无选择。 I like ice-cream. 我喜欢吃冰淇淋。 I love this game. 我钟爱这项运动。 I’ll try my best. 我尽力而为。 I’m on your side. 我全力支持你。 No pain,no gain. 不劳无获 Long time no see. 好久不见。 Well, it depends. 噢，这得看情况。 We’re all for it. 我们全都同意。 What a good deal. 真便宜。 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack]]></title>
    <url>%2FWebpack%2Fwebpack.html</url>
    <content type="text"><![CDATA[安装nodejsHttps://nodejs.org/en/ npm NodeJS包管理和分发工具 Http://npmjs.org/ npm常用命令 npm init 创建package.json文件 npm install &lt;module-name&gt; -g/--save-dev/--save安装模块 npm update &lt;module-name&gt;更新模块 npm uninstall &lt;module-name&gt;卸载模块 webpackwebpack简介 一款模块加载器兼打包工具 支持AMD/CMD写法 处理依赖关系，然后解析出模块之间的依赖，将代码打包 把各种资源都作为模块来使用和处理 比如js、css、less、sass等 http://webpack.github.io/ 安装webpack npm install webpack -g 安装后就在命令行中使用webpack命令 把依赖写入package.json npm install webpack --save-dev webpack命令 打包命令webpack index.js output.js Index.js 打包的入口文件 output.js 打包后的文件 webpack js/index.js build/build.js 如果需要打包多个js文件到一个js文件，需要建立依赖关系 比如js文件夹中有index.js和app.js app.js中 12var str = "hello webpackkkkk";module.exports = str; index.js中 12var s = require("./app.js");document.write(s); 然后执行webpack js/index.js build/build.js index.html 12345678910&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script src="build/build.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 用ES6的模块化语法 demo.js 12let str = "ES6";export default str; index.js 12import s1 from "./demo.js"document.write(s1); 然后执行webpack js/index.js build/build.js 效果一样 模块加载器（loader） 各种不同文件类型的资源，webpack有对应的模块加载器 安装加载器 npm install xxx-loader --save-dev 例如：npm install css-loader style-loader --save-dev处理css文件和样式 webpack配置说明 webpack的配置项说明 entry: 打包的入口文件 string Object output: 配置打包结果 Object path：定义输出文件路径 filename:指定打包文件名称 module:定义了对模块的处理逻辑 Object rules：定义了一系列的加载器 Array [{ ​ test:正则，匹配到的文件后缀名 ​ loader/loaders:string | array，处理匹配到的文件 ​ include:string | array 包含的文件夹 ​ exclude: string | array 排除的文件夹 }] resolve：{ ​ extensions:[“,’.js’”,”.css”,”jsx”] //自动补全识别后缀 } 热加载 先在全局安装npm install webpack-dev-server -g 安装到依赖里面npm install webpack-dev-server --save-dev 然后运行webpack-dev-server --open浏览器会自动打开 端口被占用的话可以用webpack-dev-server --port 8081来修改端口号 然后修改package.json &quot;scripts&quot;: { &quot;start&quot;: &quot;webpack-dev-server&quot; } 再运行npm start就可以开启服务器 若报一堆错误，请在当前目录下安装webpack npm install webpack 热加载的配置如下 12345678910111213141516171819202122const path = require('path');const webpack = require('webpack'); //1.引入webpackmodule.exports = &#123; entry: './index.js', //2.添加插件 plugins: [ new webpack.HotModuleReplacementPlugin() // Enable HMR ], output: &#123; filename: 'main.js', path: path.resolve(__dirname, 'dist'), //路径是个坑，不能写相对路径 publicPath: '/' &#125;, devServer: &#123; hot: true, //3. Tell the dev-server we're using HMR contentBase: path.resolve(__dirname, 'dist'), publicPath: '/' &#125;&#125;; 又发现一个有趣的事情 在命令行里执行webpack-dev-server --hot --inline然后打开localhost:8080 发现是目录界面 原因是配置有问题 12345devServer: &#123; // hot: true, // Tell the dev-server we're using HMR //contentBase: path.resolve(__dirname, 'dist'), //publicPath: '/' //这里是重点 &#125; 当我这么配置 12345devServer: &#123; // hot: true, // Tell the dev-server we're using HMR contentBase: path.resolve(__dirname, 'dist'), publicPath: '/'&#125; 再执行webpack-dev-server --hot --inline的时候就会出现正常的页面，而且支持热加载， 下面是全的。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152const path = require("path");// const webpack = require('webpack');module.exports = &#123; entry:"./src/index.js", output:&#123; filename:"bundle.js", path:path.resolve(__dirname,"dist") &#125;, module:&#123; rules:[ &#123; test:/\.css$/, use:[ "style-loader", "css-loader" ] &#125;, &#123; test:/\.(png|svg|jpg|gif)$/, use:[ "file-loader" ] &#125;, &#123; test:/\.(woff|woff2|eot|ttf|otf)$/, use:[ "file-loader" ] &#125;, &#123; test:/\.(csv|tsv)$/, use:[ "csv-loader" ] &#125;, &#123; test:/\.xml$/, use:[ "xml-loader" ] &#125; ] &#125;, // plugins: [ // new webpack.HotModuleReplacementPlugin() // Enable HMR // ], devServer: &#123; // hot: true, // Tell the dev-server we're using HMR contentBase: path.resolve(__dirname, 'dist'), publicPath: '/' //这里是重点 &#125;&#125;; 不过我们要想执行npm start命令实现热加载还需要在webpack.config.js里面进行相关配置 自动生成index.html页面需要使用html-webpack-plugin插件 首先安装插件 npm install html-webpack-plugin --save-dev 然后配置 1234567891011121314151617const path = require("path");//1.引入插件const HtmlWebpackPlugin = require("html-webpack-plugin");module.exports = &#123; entry:"./src/index.js", output:&#123; filename:"bundle.js", //2.设置路径 path:path.resolve(__dirname,"dist") &#125;, plugins: [ //3.使用插件 new HtmlWebpackPlugin(&#123; title:"我是新生成的页面" &#125;) ]&#125;; webpack或者npm run build进行打包，index.html就会出现在dist文件夹下面。 如果想要打包两个甚至多个文件怎么办呢？webpack.config.js中 12345678910111213const path = require("path");module.exports = &#123; //1.入口文件写成对象的形式 entry:&#123; bundle:"./src/index.js", abc:"./src/abc.js" &#125; output:&#123; //2.filename写活成"[name].js"的形式 filename:"[name].js", path:path.resolve(__dirname,"dist") &#125;&#125;; 同样html-webpack-plugin也可以生成多个页面 1234567891011121314151617181920212223242526const path = require("path");//1.引入插件const HtmlWebpackPlugin = require("html-webpack-plugin");module.exports = &#123; entry:&#123; bundle:"./src/index.js", abc:"./src/abc.js" &#125;, output:&#123; filename:"[name].js", //2.设置路径 path:path.resolve(__dirname,"dist") &#125;, plugins: [ //3.使用插件 new HtmlWebpackPlugin(&#123; title:"我是新生成的页面", chunks:["bundle"] &#125;), new HtmlWebpackPlugin(&#123; title:"我是第二个页面"， filename:"index2.html", //注意这个不写，默认是index。html chunks:["abc"] &#125;) ]&#125;; 本文结束，感谢阅读。 本文作者：melody0z 本文链接：https://melodyvoid/Webpack/webpack.html 欢迎转载，转载请注明文本链接]]></content>
      <categories>
        <category>Webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0817]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0817.html</url>
    <content type="text"><![CDATA[必备句型​ I plan to go to the movies with Paul. 我打算跟Paul一起去看电影。 Count me in. 算上我。 ​ 场景对话​ A: It’s Friday night! Do you have any plans? B: Yes, I plan to go the movies with Paul.I am totally free because the exam is over. A: Wow, that’s nice. Count me in. B: Sure, let’s go together. ​ 参考译文​ A: 到周五晚上啦，有什么计划吗？ B: 有的，我打算跟Paul一起去看电影。考试结束了，感觉自己完全自由了。 A: 哇，太好了。我也要去。 B: 好的，一起去。 ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0816]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0816.html</url>
    <content type="text"><![CDATA[必备句型​ I know that I let you down last week. 我知道上周让你失望了。 You can count on me. 你可以依靠我。 ​ 场景对话​ A: I know that I let you down last week,but you can count on me this time. B: I still trust you, don’t worry about it. Just do your best. A: Thank you. B: That’s what friends are supposed to do. ​ 参考译文​ A: 我知道上周让你失望了，但是这次你可以信赖我。别担心。 B: 我依然相信你，尽力就好。 A: 谢谢你。 B: 本来就是朋友该做的。 ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0815]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0815.html</url>
    <content type="text"><![CDATA[必备句型​ You finished the exam lightening fast! 你这么快就完成了考试。 It’s a piece of cake for me. 对我来说这是小菜一碟。 ​ 场景对话​ A: I just couldn’t believe how early you left the room! You finished the exam lightening fast! B: You konw that I’m pretty good at math,it’s a piece of cake for me. ​ 参考译文​ A: 我没想到你很早就离开教室了，这么快就完成了考试！ B: 你知道的，我数学很好。对我来说就是小菜一碟。 ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0814]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0814.html</url>
    <content type="text"><![CDATA[必备句型​ You wouldn’t believe what happened to me yesterday! 你不会相信昨天我碰上了什么事。 When it rains,it pours! 祸不单行。 ​ 场景对话​ A: Hey, you look depressed. What’s wrong? B: You wouldn’t believe what happened to me yesterday! I missed my train, and I lost my wallet. Even worse,I got sick that night! When it rains,it pours! ​ 参考译文​ A: 嘿，你看上去很沮丧，怎么了？ B: 你不会相信昨天我碰上了什么事！错过了火车，钱包还丢了。更糟糕的是，那天晚上还生病了，真是祸不单行。 ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vuex]]></title>
    <url>%2FVue%2Fvuex.html</url>
    <content type="text"><![CDATA[vuex初步了解第一步：安装vuex npm install vuex --save-dev或npm install vuex -D 第二步：创建store.js文件 第三步：在mian.js文件中引入stroe模块 1234567891011import Vue from 'vue'import App from './App.vue'//1.引入store模块import store from "./store"new Vue(&#123; el: '#app', //2.将store模块应用到Vue中 store, render: h =&gt; h(App)&#125;); 第四步：完善store.js 1234567891011121314151617181920212223import Vue from "vue" //1.引入vueimport Vuex from "vuex" //2.引入vuex//3.使用vuexVue.use(Vuex);//4.创建state状态对象，里面放静态数据const state = &#123; count:2&#125;;//5.创建mutations方法对象，里面放方法const mutations = &#123; increase(state)&#123; state.count++ &#125;, decrease(state)&#123; state.count-- &#125;&#125;;//6.导出模块//注意：是new Vuex.Store()，一开始写的new Vuex()export default new Vuex.Store(&#123; state, mutations&#125;) 第四步：App.vue中的代码 123456789&lt;template&gt; &lt;div id="app"&gt; &lt;img src="./assets/logo.png"&gt; &lt;h1&gt;Hello vuex&lt;/h1&gt; &lt;h2&gt;&#123;&#123;$store.state.count&#125;&#125;&lt;/h2&gt; &lt;input type="button" value="增加" @click="$store.commit('increase')"&gt; &lt;input type="button" value="减少" @click="$store.commit('decrease')"&gt; &lt;/div&gt;&lt;/template&gt; state状态对象我们发现在模板里写&lt;h2&gt;&lt;/h2&gt;有点违背人家的意思， 要是写成&lt;h2&gt;&lt;/h2&gt;该多好，我们解决一下这个问题 App.vue中的代码 1234567891011121314151617181920212223242526272829&lt;template&gt; &lt;div id="app"&gt; &lt;img src="./assets/logo.png"&gt; &lt;h1&gt;Hello vuex&lt;/h1&gt; &lt;h2&gt;$store.state.count:&#123;&#123;$store.state.count&#125;&#125;&lt;/h2&gt; &lt;h2&gt;计算属性：&#123;&#123;count&#125;&#125;&lt;/h2&gt; &lt;input type="button" value="增加" @click="$store.commit('increase')"&gt; &lt;input type="button" value="减少" @click="$store.commit('decrease')"&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'app', data () &#123; return &#123; msg: 'Welcome to Your Vue.js App' &#125; &#125;, //计算属性是关键 computed:&#123; //这里的count属性在上面可以直接用了 count()&#123; //这里还是很累赘 return this.$store.state.count + 1 &#125; &#125;&#125;&lt;/script&gt; 我们需要在App.vue中引入mapState对象 123456789101112131415&lt;script&gt;//1.先引入mapState对象//注意导入模块的方式，第一次没有加&#123;&#125;导致了错误import &#123;mapState&#125; from "vuex"export default &#123; name: 'app', data () &#123; &#125;, //2.在计算属性里用mapState computed:mapState(&#123; count(state)&#123; return state.count &#125; &#125;)&#125; computed可以有四种写法 123456//ES5的写法computed:mapState(&#123; count:function (state)&#123; return state.count &#125;&#125;) 123456//ES6的写法computed:mapState(&#123; count(state)&#123; return state.count &#125;&#125;) 1234//ES6箭头函数的写法(官方不建议用箭头函数)computed:mapState(&#123; count:state =&gt; state.count&#125;) 123computed:mapState([ "count"]); //注意这种方法用的最多，因为简单，但是不能进行计算 Mutations方法对象(mutation是同步的)12&lt;input type="button" value="增加" @click="$store.commit('increase')"&lt;input type="button" value="减少" @click="$store.commit('decrease')" 注意上面的方法写的是不是很累赘，我们希望是以下的样子 12&lt;input type="button" value="增加" @click="increase"&gt;&lt;input type="button" value="减少" @click="decrease"&gt; 好了，我们来解决这个问题 first，先引入mapMutations对象 import {mapState,mapMutations} from &quot;vuex&quot; second,在方法里面写 12345//注意mapMutations里是数组的形式methods:mapMutations([ "increase", "decrease"]) Done,是不是很简单 把App.vue整体贴过来 123456789101112131415161718192021222324252627282930&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;img src=&quot;./assets/logo.png&quot;&gt; &lt;h1&gt;Hello vuex&lt;/h1&gt; &lt;h2&gt;计算属性：&#123;&#123;count&#125;&#125;&lt;/h2&gt; &lt;input type=&quot;button&quot; value=&quot;增加&quot; @click=&quot;increase&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;减少&quot; @click=&quot;decrease&quot;&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;//1.先引入mapState对象,引入mapMutations对象import &#123;mapState,mapMutations&#125; from &quot;vuex&quot;export default &#123; name: &apos;app&apos;, data () &#123; return &#123; msg: &apos;Welcome to Your Vue.js App&apos; &#125; &#125;, computed:mapState([ &quot;count&quot; ]), //注意mapMutations里是数组的形式 methods:mapMutations([ &quot;increase&quot;, &quot;decrease&quot; ])&#125;&lt;/script&gt; mapGetters用mapGetters和mapState差不多，但是mapGetters可以进行计算，而mapState要想计算，需要放到计算属性中 App.vue 123456789101112131415161718192021222324252627282930313233&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;img src=&quot;./assets/logo.png&quot;&gt; &lt;h1&gt;Hello vuex&lt;/h1&gt; &lt;h2&gt;$store.state.count:&#123;&#123;$store.state.count&#125;&#125;&lt;/h2&gt; &lt;h2&gt;计算属性：&#123;&#123;count&#125;&#125;&lt;/h2&gt; &lt;input type=&quot;button&quot; value=&quot;增加&quot; @click=&quot;increase&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;减少&quot; @click=&quot;decrease&quot;&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;//1.先引入mapGetters对象import &#123;mapState,mapMutations,mapGetters&#125; from &quot;vuex&quot;export default &#123; name: &apos;app&apos;, data () &#123; return &#123; msg: &apos;Welcome to Your Vue.js App&apos; &#125; &#125;, //2.在计算属性中使用mapGetters computed:mapGetters([ //注意这里写的count需要在store.js中的getters中设置 &quot;count&quot; ]), //注意mapMutations里是数组的形式 methods:mapMutations([ &quot;increase&quot;, &quot;decrease&quot; ])&#125;&lt;/script&gt; store.js 1234567891011121314151617181920212223242526272829303132import Vue from "vue"import Vuex from "vuex"Vue.use(Vuex);const state = &#123; count:2&#125;;const mutations = &#123; increase(state)&#123; state.count++ &#125;, decrease(state)&#123; state.count-- &#125;&#125;;//3.定义getters对象const getters = &#123; //设置count count(state)&#123; //在这里可以对count进行计算，也可以不计算 return state.count &#125;&#125;;//注意：是new Vuex.Store()，一开始写的new Vuex()export default new Vuex.Store(&#123; state, mutations, //4.别忘了把getter放到这里 getters&#125;) mapActionsmapAction与mapMutations差不多，区别是mapActions是异步执行，mapMutations是同步执行 App.vue 123456789101112131415161718192021222324252627282930313233&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;img src=&quot;./assets/logo.png&quot;&gt; &lt;h1&gt;Hello vuex&lt;/h1&gt; &lt;h2&gt;$store.state.count:&#123;&#123;$store.state.count&#125;&#125;&lt;/h2&gt; &lt;h2&gt;计算属性：&#123;&#123;count&#125;&#125;&lt;/h2&gt; &lt;!-- 2.方法加上,此例为plus和reduce --&gt; &lt;input type=&quot;button&quot; value=&quot;增加&quot; @click=&quot;plus&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;减少&quot; @click=&quot;reduce&quot;&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;//1.先引入mapAction对象import &#123;mapState,mapMutations,mapGetters,mapActions&#125; from &quot;vuex&quot;export default &#123; name: &apos;app&apos;, data () &#123; return &#123; msg: &apos;Welcome to Your Vue.js App&apos; &#125; &#125;, computed:mapGetters([ &quot;count&quot; ]), //注意mapActions与mapMutations不同的是mapActions是异步的 //3.在methods中写方法：plus和reduce，这里的方法名字对应store.js里面actions里的方法的名字 methods:mapActions([ &quot;plus&quot;, &quot;reduce&quot; ])&#125;&lt;/script&gt; Store.js 123456789101112131415161718192021222324252627282930313233343536373839404142import Vue from "vue"import Vuex from "vuex"Vue.use(Vuex);const state = &#123; count:2&#125;;//4.在mutations里面写方法的逻辑业务const mutations = &#123; plus(state)&#123; state.count++ &#125;, reduce(state)&#123; state.count-- &#125;&#125;;//5.在actions里面调用const actions = &#123; //完整的写 plus(context)&#123; context.commit("plus") &#125;, //解构的写法 reduce(&#123;commit&#125;)&#123; commit("reduce") &#125;&#125;;const getters = &#123; count(state)&#123; return state.count &#125;&#125;;//注意：是new Vuex.Store()，一开始写的new Vuex()export default new Vuex.Store(&#123; state, mutations, getters, //6.把action添加到这里 actions&#125;) 本文结束，感谢阅读。 本文作者：melody0z 本文链接：https://melodyvoid/Vue/vuex.html 欢迎转载，转载请注明文本链接]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vuex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0813]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0813.html</url>
    <content type="text"><![CDATA[必备句型​ I’ve made up my mind. 我做好决定了。 How could you do this to me ? 你怎么能这样对我？ ​ 场景对话​ A: I’ve been thinking about this for a long time, and I’ve made up my mind. B: What? Are you gonna break up with me? A: I’m sorry. B: How could you do this to me? ​ 参考译文​ A: 我想了很长一段时间，也做好决定了。 B: 怎么？要跟我分手吗？ A: 对不起。 B: 你怎么能这样对我？ ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0812]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0812.html</url>
    <content type="text"><![CDATA[必备句型​ Do you wanna go out and have a drink? 要不要出去喝一杯。 I’m a night person. 我是个夜猫子。 ​ 场景对话​ A: Hey,it’s me Alex. What are you doing? B: I’m watching TV right now. What’s up? A: Do you wanna go out and have a drink? B: Are you kidding me? It’s 11 pm now. A: You know that’s I’m a night person. ​ 参考译文​ A: 嘿，是我，Alex。现在在做什么呢？ B: 我在看电视，怎么了？ A: 要不要出去喝一杯？ B: 开什么玩笑？现在都11点了。 A: 我知道，我是个夜猫子。 ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0811]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-081.html</url>
    <content type="text"><![CDATA[必备句型​ Hold your horses. 别着急 There’s no need to rush. 没有必要这么匆忙。 ​ 场景对话​ A: What are you doing? Hurry up, or we’ll be late! B: Hold your horses.We still have 15minutes,there’s no need to rush. A: Alright,I’ll go first. ​ 参考译文​ A: 你在做什么呢？快点吧，不然我们就要迟到了。 B: 别着急，我们还有15分钟的时间。没有必要这么匆忙。 A: 好吧，那我先走了。 ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0810]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0810.html</url>
    <content type="text"><![CDATA[必备句型​ Would you like to join me for dinner tonight? 晚上要跟我一起吃饭吗？ That’s would be nice. 那太好了。 ​ 场景对话​ A: Would you like to join me for dinner tonight? B: Could you recommend some good restaurants around here? A: How about the new restaurant near the bus stop? B: That would be nice. ​ 参考译文​ A: 晚上要跟我一起吃饭吗？ B: 你能推荐几家附件的好餐馆吗？ A: 车站旁边新开张的那家餐馆怎么样？ B: 那太好了。 ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0809]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0809.html</url>
    <content type="text"><![CDATA[必备句型​ Are we short of tea and coffee? 茶叶和咖啡不多了吧。 I’ll go to the shop with the shopping list. 我拿着购物单去买东西。 ​ 场景对话​ A: Are we short fo tea and coffee? B: Oh,yes.We should buy some tea and coffee. We need a lot of things this week. A: List all the items you need from the store. I’ll go to the shop with the shopping list. ​ 参考译文​ A: 我们的茶叶和咖啡不多了吧。 B: 噢，是的。我们得买些茶叶和咖啡。这周我们需要购买很多东西。 A: 把你要买的物品列在购物单上。我拿着购物单去买东西。 ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0808]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0808.html</url>
    <content type="text"><![CDATA[必备句型​ You look terrible, What’s the matter? 你的脸色不太好，怎么了？ Your gums are bleeding,you’d better see a doctor. 你的牙龈在出血，最好去看一下医生。 ​ 场景对话​ A: You look terrible. What’s the matter? B: I don’t feel well. The tooth is killing me as soon as I eat sour food. A: Open your mouth,and let me have a look. Your gums are bleeding, you’d better see a doctor. ​ 参考译文​ A: 你的脸色不太好，怎么了？ B: 我感觉不舒服，我这颗牙一吃酸的东西就疼得难受。 A: 你张开嘴巴我看看，你的牙龈在出血，最好去看一下医生。 ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0807]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0807.html</url>
    <content type="text"><![CDATA[必备句型​ Excuse me, do you speak English? 抱歉打扰了，你说英语吗？ I can’t follow you when you speak fast. 你说得太快了，我没听懂。 ​ 场景对话​ A: Excuse me, do you speak English? B: Yes,but just a little. A: That’s great, could you please tell me where the nearest drug-store is? B: I am so sorry, I can’t follow you when you speak fast. ​ 参考译文​ A: 抱歉，打扰了。你说英语吗？ B: 会一点点。 A: 太好了，你能告诉我最近的药店在哪里吗？ B: 对不起，你说得太快，我没听懂。 ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0806]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0806.html</url>
    <content type="text"><![CDATA[必备句型​ I actually don’t like her. 我其实不喜欢她 So what? 那又怎么样？ ​ 场景对话​ A: I actually don’t like her. B: How come? I think she’s the most beautiful girl in our class. A: So what? She’s stupid. B: You are just jealous. ​ 参考译文​ A: 我其实不喜欢她。 B: 为什么？我觉得她是我们班上最漂亮的。 A: 那又怎么样？她很蠢。 B: 你只不过是嫉妒罢了。 ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跟李涛老师学后期04]]></title>
    <url>%2FPhotography%2Ffolow-teacher-li-tao-in-the-later-04.html</url>
    <content type="text"><![CDATA[HSL颜色调节所谓HSL其实就是三个英文字母的缩写 H：Hue 色相 就是我们平常说的颜色，赤橙黄绿青蓝紫，黑白没有色相。 S：Saturation 饱和度 饱和度就是指颜色的鲜艳程度 L：Lightness 亮度 亮度就是指颜色的明暗程度 HSL既可以做颜色，也可以做灰度，点击转换为灰度图片就会变灰，转换为灰度后，就只剩下亮度的变化了，不会再有饱和度和色相的变化。 我们在调片的时候要明确哪个颜色需要出来，哪个颜色需要下去，哪些颜色色相和色相之间可以转换。 但是我们如果想调一个颜色，但是我们又不确定它是什么颜色的时候怎么办呢？这时候就需要借助目标调整工具了 注意点： 一定要先选择需要改变的HSL，在去滑动鼠标。比如我们选择了色相，那么改变的就是色相。 效果如下： 通过HSL转灰度 颜色很丰富，有时候范围控制不住。所以过早的进入颜色控制，反而不容易控制。 看彩色照片时候，还是应该先从影调入手。有时候异彩纷呈反而没了重点。 在黑白照片里，是控制明暗来控制照片。 做黑白片，不建议直接转灰度，而是把所有的颜色的饱和度关掉。好处是可以继续控制色相、自然饱和度还是可以调整，可调整的范围更大。另外可以在黑白片里保留一个颜色，造成了片子的特殊性，也可以营造低饱和度的氛围（德系）。 黑白片里靠黑白来营造层次。 调性黑白影调后期处理与控制摄影中的影调，指照片的基调和调子。影调解决的是视觉画面中黑白明暗层次、虚实对比和色彩色相纯度等之间的关系问题。通过这些关系，使欣赏者感到光的变化流动，感受节奏与韵律构成的视觉美感。 影和调要提前决定自己的片子调成什么影调，不能随机、漫无目的，自己要有预感。原因是颜色层级关系太多，不容易平衡。 彩色和黑白均有影调的问题。 影调来源于音乐。 影：光影、明暗、黑白关系（节奏）（明快、平缓等等呢） 调：色调（tone）、色彩（韵律）—（冷暖等等呢） 影调在摄影中的作用 基本作用：创造色彩、光线效果，构成影片色彩和黑白的阶调（影调）基调。 准确表现主体。影调的准确表现会大大加强片子的表现力。 渲染片子气氛。 体现片子个性与风格。 塑造人物形象 亚当斯分区曝光法将0~255这256个色阶分为0~10这11个色阶。其中 0为纯黑 1、2、3为低调 4、5、6为中调 7、8、9为高调 10为纯白 片子又可以分为三个调性，分别是短调，中调和长调。这样我们建立一个坐标 这样我们就可以划分出9种片子，这就是9中调性 高长调的特征：大面积亮色，里面有黑白关系，如果是长调的话，既有黑又有白。 高中调：跨度范围没有那么长 高短调：很亮，但是调性非常短 最常见的片子是中长调，就是我们说的标准调色方式，有纯黑的地方做实了，但是不多，有纯白的地方做实了，但是也不多，整个调性拉长，大面积是中间的灰性调。所以这是我们最常见的片子。 思考：我们有九种调性可查，为什么我们所有人调的片子都只有中长调一个选择标准。 中短、高短、低短都挺难做的。在收藏级的作品里大多是低长调或者低中调，但是低中调会更多一些 九种调性例片高长调 高调的片子适合表现雪景、水面这种比较亮的东西 高中调 通过直方图我们可以看出其实这是一张高长调的片子 高短调 山本博司的作品 中长调 中中调 中短调 低长调 低中调 准确地说应该是低长调，有高光的东西在里面。 低短调 这个也应该是低长，短调的东西特别难做。 全长调只有黑白两个色，有灰色就成中长调了 所以我们应该先从中长调开始做起，然后慢慢尝试一些其他调性的片子，来体会不同调性片子的感受。 先定调还是先定影？取决于个人习惯，这里先定调性，定完调再定影 硬调和软调 暖调 冷调 先定调性 影调的决定因素 保存调片的参数在预设里面可以保存参数 清除调整参数 图片右上角-开发设置-清除设置 直接删除文件夹里的xmp。 亚当斯风格中长调调片技巧 先做渐变再做降色，会有层级关系出来。 画笔流动性放在20%，慢慢刷。 要把主题做出来，不能面面俱到，要有重点，要有主观情绪，带着自己的情绪，明白自己想表现的是什么，突出重点，其余的地方做减法。 全长调调片技巧 高光压下去，出亮部细节；阴影提上来，出暗部细节。 做片子前要想到需要做什么调性（前文提到的）。 可以修复或删除一些不需要的、影响视觉效果的、干扰画面的元素。（在ACR或PS里做均可） 内容感知移动工具，可以移动元素到需要的位置上。（单纯考虑画面而不考虑摄影的真实性的情况下） 通过画面比例调整，可以达到另外的观察视角。 全长调的色调适合反差很大的片子。 夸张是艺术表达的第一手法。 平衡有时候是破坏片子的最大的东西，经常为了照顾平衡丧失了片子的冲击力。 剪影是全长调的一种，但全长调不等于剪影。要适当控制细节，还要注意材质和纹理。 低短调调片技巧 要找到需要控制的对象。 选高亮法： 选择-色彩范围-点照片亮部取样-再选择容差值（不准）。 选择-色彩范围-选择颜色或高中低光（准） 选择-反选-图层-通过拷贝建立图层-正片叠底。 最后用画笔工具，精细化处理：拼合（盖印）ctrl+Alt+Shift+E，选出局部（例：眼睛），做羽化-拷贝建立图层-滤色（或假色）-画笔工笔，蘸白色，刷出高光。 做黑白要决定做什么调子 调性总结 不能漫无目的的调片子，要有目的性，可以通过影调来定。 注意运用夸张的手法。 学会分析什么样的片子适合什么样的调子。 ​ 本文结束，感谢阅读。 参考资料：[李涛] 简单摄影后期课本文作者：melody0z 本文链接：https://melodyvoid/Photography/folow-teacher-li-tao-in-the-later-04.html 欢迎转载，转载请注明文本链接]]></content>
      <categories>
        <category>Photography</category>
      </categories>
      <tags>
        <tag>后期</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跟李涛老师学后期03]]></title>
    <url>%2FPhotography%2Ffolow-teacher-li-tao-in-the-later-03.html</url>
    <content type="text"><![CDATA[输出与文件夹结构流程的最后一步就是输出了。 根据不同的使用场景（印刷还是放网上），选择不同的输出。 在Camera raw中，左下角点击储存图像 作为印刷输出在Bridge中单张输出格式选择为TIFF 压缩格式为LZW和ZIP都可以，这两个都是无损压缩，如果不勾这个选项，输出的片子会非常大，因为TIFF都是全尺寸输出。 色彩空间选择Adobe RGB(1998) 色彩空间相加端可以设置，要设置成Adobe RGB(1998),不能用sRGB,因为前者的色域比后者的色域大很多，sRGB只有一个地方可用，那就是互联网，如果是向网上输出，采用sRGB 色彩深度最好设置成16位，16位的空间更大。如果真要高品质的输出一定要16位地输出。一个通道里面如果是8位，这个通道是256个颜色，每个通道是256个颜色；如果是16位，每个通道是65000色。 然后输出到“成品”文件夹，项目结构如下 12345|--20170805_demo |--成品 |--_DSC0019.JPG |--_DSC0019.ARW |--... 批处理先选中需要存储的片子，然后command + R或者ctrl + R打开Camera raw，然后点击全选，在点击存储图像,然后重复上面的步骤。 在Photoshop中文件 ——&gt;存储为——&gt;格式选择为TIFF，勾选”嵌入颜色配置文件：Adobe RGB(1998)”——&gt;然后在压缩 作为网络输出在Bridge中把文件选中，command + R打开Camera raw，点击存储图像，格式选择为“JPEG”，品质给到8，只能存双数，不要存单数，因为单数的损失更大。默认值设置为8，觉得不太重要就给6.色彩空间一定要变为sRGB,因为是向互联网输出，浏览器只认sRGB,色彩深度只能是8位，因为JEPG记录不了16位的色彩深度，设置16位也没有用，输出大小单边尺寸1500点~2000点就够了。 在Photoshop中选择文件——&gt;脚本——&gt;图像处理器 连文件夹都不用给，点击运行之后会在目录下自动生成一个叫JPEG的文件夹，里面就是jpeg文件。 最后的目录结构是这个样子的 12345678910|--20170805_demo |--成品 |--JPEG |--_DSC0019.jpeg |--... |--_DSC0019.TIFF |--... |--_DSC0019.JPG |--_DSC0019.ARW |--... 水平校正好照片决定性瞬间可能达不到，需要二次构图。 布列松的口号是决定性瞬间，他的取景器是倒置的，学生：马克吕布的第一张作品《跳舞的油漆工人》拿到了大奖。倒置就排除了很多干扰，观察的世界不是印象中的世界，只能看到一些形体化的东西，所以拍出了不一样的东西。 二次构图的技巧，垂直线技巧，一定要保证片子横平竖直，这是基本功。 因为镜头是有畸变的，所以把线拍直有时并不是那么简单。 水平垂直校正可用拉直工具，根据照片需要的效果去裁切。 垂直校正用广角镜头拍，水平保证了，我们会发现垂直的都歪了，这就是广角透视造成的，产生了畸变，垂直校正用镜头校正 镜头校正要在基本的五步之前。 摄影基本功扎不扎实，看你拍东西能不能拍直。 启用镜头配置文件 删除色差值，色差就是在大光比的情况下，会出现的紫边，不容易察觉，但是删除色差能把它剔除掉。 手动，手动调节 调相机校准 总结标准流程： 文件夹命名（日期文件夹、成品文件夹、jpeg文件夹、作品文件夹） 打星过滤 相机、镜头校准 五条技术指标规范。 局部处理。 二次构图二次构图就是做减法，减到趣味中心点上，减到自己想要的东西，画面干干净净。 思考： 摄影师能否在拍摄的一瞬间，融入到当前的拍摄环境中去？ 是否令观者感同身受？ 这些都跟自己的经历与阅历有关系 局部处理工具：调整画笔、渐变滤镜 多数情况下我们是使用调整画笔来调的 局部调整时，先动参数，再用工具。 用渐变滤镜时候，先缩小图片。 渐变滤镜只能从边上到中间。 如果要加滤镜，要先点新建。 画笔：羽化是渐变的范围。流动不要开太大，更浓度有关。可以慢慢刷。 ​ 本文结束，感谢阅读。 参考资料：[李涛] 简单摄影后期课本文作者：melody0z 本文链接：https://melodyvoid.github.io/Photography/folow-teacher-li-tao-in-the-later-03.html 欢迎转载，转载请注明文本链接]]></content>
      <categories>
        <category>Photography</category>
      </categories>
      <tags>
        <tag>后期</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0805]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0805.html</url>
    <content type="text"><![CDATA[必备句型​ What luck! We’ve run out of gas. 真倒霉！汽油用光了 Today just isn’t my day. 今天真是什么都不顺心 ​ 场景对话​ A: What luck! We’ve run out of gas. B: Today just isn’t my day. What should we do now? A: Then we’ll have to get off and run to our office. B: I hope we won’t be late. ​ 参考译文​ A: 真倒霉！汽油用光了。 B: 今天真是什么都不顺心。我们现在该怎么办？ A: 那我们得要下车跑到办公室了。 B: 希望我们不会迟到。 ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0804]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0804.html</url>
    <content type="text"><![CDATA[必备句型​ The point is that you’ve been trying your best. 重点是你一直在努力 Everything will be fine. 一切都会好的 ​ 场景对话​ A: You look depressed, is everything okay? B:I lost my job one month ago,and I still can’t find a new one. A: Don’t be so upset, the point is that you’ve been trying your best to find one. Everything will be fine. ​ 参考译文​ A: 你看起来很沮丧，一切还好吧？ B: 失业一个月了，我还没找到工作。 A: 不要那么低落，重点是你一直在努力，一切都会好的。 ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跟李涛老师学后期02]]></title>
    <url>%2FPhotography%2Ffolow-teacher-li-tao-in-the-later-02.html</url>
    <content type="text"><![CDATA[全局操作的五个步骤我们经常会看到有人拍片子会带着色板去拍，为什么会带这样的东西去拍片子呢？ 如果我们在Brideg里面看到了我们需要的片子，我们也定好要调节了，我们就需要进入调节的状态，调节状态的方式不要直接双击，在没有打开Photoshop的情况下，我们调用Bridge正确的方式不是双击，应使用command + R 为什么要做这一步？因为这样可以检测到你的软件正常不正常，或者你的软件合理不合理的一个重要的指标，比如我们看到一张raw的源文件，然后我们按下command + R,然后就直接打开到了Camera raw里面。 Camera raw就是我们说的阅读器，用来解读底片的阅读器 Camera raw 有两套，一个在Bridge里面，一个在Photoshop里面，我们通过双加击打开，是进到了Photoshop里面，这样并没有在Bridge里面直接把它解决掉，多数情况下，我们是不需要进到Photoshop，在Bridge里面就已经可以调用到，所以它有两个Camera raw，这个必须是有两个，一个在Bridge里面，一个在Photoshop里面，这两个都打开才正常。要不开这个会有小问题，比如批处理会有问题，假设有一组片子，我们把一张片子调好之后，其他片子直接通过拷贝粘贴就可以把效果粘贴过去了，但是没有这个选项，就粘贴不过去。 我们进入正式调片流程的情况下，有五个环节（技术指标） 准确的色彩还原 正确的黑白场 足够的清晰度 适当的饱和度 丰富合理的层次 以上五个是技术指标 准确的色彩还原为什么要校色我们修片第一件事情就是校色，顾名思义校正颜色。 什么叫准确的色彩还原？ 因为白平衡的原因，我们必须要做校色，光是会被改变的，也是会被欺骗的。光和颜色会收到影响，就好比有的时候白的东西看上去并不是白色。光是有欺骗性的。默认情况下我们所说的光，是传统意义上的白光。但实际上光本身是有颜色的，白天的光也会发生颜色的变化，早上的颜色和夕阳的颜色肯定是不一样。 假如我们处在一个光照环境不是很正常的环境，颜色就会出现偏差，这就是我们把光的记录方式放错了。 我们打灯拍摄，灯的色温不同也会影响照片的颜色 如何校色白平衡工具,command + R之后，在左上角有一个白平衡工具 白平衡要吸在什么地方呢？吸灰的地方，准确点说是找18%的中性灰，注意是找画面中的18%中性灰，那么我们怎么知道画面中什么地方是18%的中性灰呢？ 在拍照的时候拿个灰卡 没有灰卡就在照片里面找类似灰的地方，注意灰色一定不能带有色相，找黑白灰 所以我们在拍人像的时候最好带上色卡。 群组校色如何群组校色？选中一组（在同一光源下拍摄），然后command + R打开Camera raw，这样我们只需要校准第一张（照片里有色卡），校正完后点击全选，然后点击同步，最后点击确定，这样所有的片子都校正完了。或者在Camera raw里面command + A全选，然后在全选的状态下校准第一张，这样其余的也都跟着变了。 校错会是什么情况正常情况下我们校正是吸取18%中性灰，但是我们吸取到黑色或者白色会是什么情况？ 色温会发生变化。 黑白灰的特点是它没有色相，白平衡有一定的宽容度，它认为18%灰是最准的，但是如果在不准的情况下，在宽容度范围内色温会发生一些变化。但是注意：千万千万不能吸取到黑白灰以外的颜色，如果在有色相的地方去吸取就会发生偏差了。举个例子：如果吸取到了红色，那么片子就会发绿发青。为什么会发青呢？因为红和青是补色，只要认为红颜色是准的，它就要补青色在里面。你要是认为黄颜色是准的，它就会补蓝色。所以千万不能点到有色相的地方。 灰色找不到找白色，白色找不到找黑色。黑、白、灰的校正之间没有那么大的差别，只是在色温上稍微有点差别。 正确的黑白场什么是确定片子的黑白场说白了就是知道这个片子什么地方最黑，什么地方最白。 先找图片的最黑和最白，要把白和黑都做实。白的漂亮，黑的很实。 正确的黑白场是指调性是全长的。 黑白场确定下来，这个片子就是白的是高光，漂亮。黑的是死黑一片。但是我们是不是要那么多的死黑一片？这就需要根据片子的情况来决定了。有的时候我们不要要死黑一片，因为暗部里面我们需要细节。 怎么来调黑白场在Camera raw面板的最右边，有一个黑色和白色,那个就是调黑白场的。 调片子倒着调：上来并不是先动曝光，而是先动的是黑白场。 调色用CMY去调，而不是用RGB去调，就是因为CMY好计算，我们队RGB的直接反应是迟钝的。 调黑白场：按住alt或者option键，然后调节白色和黑色 然后通过看直方图，我们可以看出照片的黑白场信息 足够的清晰度清晰度的设置 相机上设置：饱和度、锐化度、清晰度。清晰度在可以不加或者减一档，但是万万不要在相机里面做过多的加的设置，因为会对片子的后期的底片有一定的影响。 在Camera raw里面设置：在Camera raw面板的右面有一个叫做清晰度的选项，在黑色下面。根据不同片子的情况来决定清晰度是加是减还是不动。动清晰度会影响曝光值的变化。或者说对比度发生变化。如果之前曝光正确，我们增加了清晰度，那么曝光就会增加，这是我们应该将曝光减一档或者半档来进行修正。 Camera raw右面板的第三标签细节里面有锐化：这个指的是最后输出的时候做锐化。因为在Bridge这样的预处理软件能够完成60%~70%的工作，然后再经过Photoshop，不断的加层，层多了必然对图片的清晰度有一定的影响，所以我们整个片子修完了，最后一步再调一下锐化，让它平衡一下图层过多的影响。做锐化一定要用蒙版做：因为锐化是针对轮廓的，对于虚焦的物体来说我们并没有必要做锐化。其实蒙版就是局部处理，只要是局部处理就是蒙版的问题。按下option或者alt键，然后滑动蒙版我们就可以看到效果。蒙版就是锐化的有效范围放在哪里，所谓的有效范围就是白颜色的地方，白颜色的地方就是我们要做锐化的地方。 适当的饱和度在Camera raw的面板右侧，有一个叫做自然饱和度和一个叫做饱和度的选项。 二者的区别： 自然饱和度能把隐现的颜色提出来，说白了就是把似有似无的颜色加强了、 饱和度是在画面平均的情况下，把画面所有颜色的纯度给它提高，颜色就变鲜艳了 欠饱和度是一种影调，很舒服的影调 过饱的片子打眼，欠饱的片子耐看 丰富合理的层次丰富合理的层次就是说暗部、亮部，整个长调的片子，整个调性很长，会看到细节。 学会看直方图，直方图涵盖了整个片子里面特别重要的颜色信息值在里面，我们来看一个直方图 我们可以看到直方图的右边几乎没有信息，从中间这个调性以后，后面整个都没有细节了，说明这个片子欠曝，或者说它比较暗，不亮。 那么我们怎么调呢？ 先加一点曝光，暗部的细节会出现 再加一点阴影，此时我们发现全部东西都出来了，但是气氛却不如以前了 觉得天空太亮了，我们收一下高光，此时天空的暗部细节就会出现多一些，出现层次 觉得不够亮，就再补一点白色 第二张片子 暗部溢出了，暗部溢出整个片子就会整体偏暗 先校色，一般情况下，云彩是灰色，我们可以根据取色器显示的RGB值来确定灰色，三个数值一样就是灰色 然后确定黑白场 把阴影的地方调亮，暗部的地方就会出现细节 高光收下去，因为太阳太亮了，亮的地方往下收，亮部也出现细节 自然饱和度和清晰度追加一点点 然后如果想让片子偏冷或者偏暖一点需要调节色温，调之前一定要记住原始色温，因为它不可以ctrl+Z撤销回去 我们把色温调的冷一点，然后把色调往上调一点，把暖色稍微追上来一点 以上操作就把片子调完了，我们做的是全局操作，全局操作就是定片子的调性，打片子的基础，定片子规范的框架，物先大体，然后再进入局部调节，精调片子。 本文结束，感谢阅读。 参考资料：[李涛] 简单摄影后期课本文作者：melody0z 本文链接：https://melodyvoid/Photography/folow-teacher-li-tao-in-the-later-02.html 欢迎转载，转载请注明文本链接]]></content>
      <categories>
        <category>Photography</category>
      </categories>
      <tags>
        <tag>后期</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跟李涛老师学后期01]]></title>
    <url>%2FPhotography%2Ffolow-teacher-li-tao-in-the-later-01.html</url>
    <content type="text"><![CDATA[摄影后期的概述发现 • 联系 • 重组 --简单摄影后期课 越简单的东西越难 有些片子的后期只停留在校色、修正等简单处理上，还有些后期的功能很强大，它加入了创作者的创作思维在里面，就变成了另外一个阶层的事情在里面。 后期只要讲的说白了就是：艺道 志于道 据于德 依于人 游于艺 -- 《论语·述而》 依游于艺，道不远人 你执着于，长时间执着于，像被黑洞吸附了一样地去做一件事情，直到从这件事情上，得到你这件事情上的道，然后就通了。 为什么每个人的作品不一样，每个人多美学有不同的看法，有独特的眼光，不同的处理方式，不同的想法。 道，法，术。术是最低级的东西，也就是我们说的Photoshop操作。我们要培养自己的美感。把美的东西带进去。 艺术通感有时候我们会觉得我们拍的片子或者我们调的片子调不出好的感觉，调不出好的境界，很多情况是我们的艺术通感没有实现。艺术的东西背后都有一套心理学、美学、哲学体系在支撑着。这套支撑的体系导致我们看到的东西跟别人不一样。所以我们如果只是一味地学习Photoshop是远远不够的，那样我们永远跳不出来，我们必须涉猎跟艺术相关的东西。 艺术通感就是指所有的艺术门类是互通的，比如绘画，音乐，摄影… “摄影师谱曲，后期是演奏” -- Ansel Adams 谱曲和演奏都有才是一个完整的作品 前期和后期是一个阴阳关系，缺一不可，彼此互相依赖。技术可以提炼后期，后期返过去再为前期服务。前期要不打好基础，那么后期什么都做不了。 “我们不只使用相机拍照，我们带到摄影中去的是所有我们读过的书、看过的电影、听过的音乐、走过的路、爱过的人。” -- Ansel Adams 是我们的经历和眼界决定我们的片子是一个什么样的状态，只有带着这样的胸襟，带着这样的状态，去拍片子，去调片子，你的片子才能富有情感，才能被读者接收到，观众才能被打动。 不能因为有术而心中无道。 如果想要拍出好的照片，做出好的效果，我们不是要苦学Photoshop技巧，而是应该培养自己的艺术素养，多看书，多听音乐，多走路，多爱人。 学习方法取法乎上，寻师经典 取法于上 仅得为中 取法为中 故为其下 --唐太宗《帝范》卷四 求其上 得其中 求其中 得其下 求其下 必败 --《孙子兵法》 就好比我们挝钢筋，我们想要挝到90度，那一定是需要先挝到40度，然后它在反弹回去，要是我们一开始就挝90度，那它最后一定是会比90度大的 物先大体，鉴必穷源 先物大体 鉴必穷源 乘一总万 举要治繁 --《文心雕龙》 就是我们找东西，必须找到根源，要拍一个思路，一个体系，要有想法，必须找到根源，而且我们要有整个的大体观。要在大的框架里面找到它的根源是什么。 诚心正意，自证良知诚心正意是专心只干一件事，自证良知是亲自去实践它 怎么评判一张片子的好坏好片子的标准：赏心、悦目 悦目：物理层面，就是指作品好看，比如说：漂亮、聚焦、简洁（ 赏心：心里层面，就是类似共鸣、兴趣 如何打造一张好的片子，三个切入点 天下大事，必做于细片子里的细节是否到位，细节到位是一个很重要的环节。当然并不是所有的作品都是追求细节的，例如山本博文的作品就都是虚焦的。但是我们刚接触摄影，是需要先从细节开始下手的。 众生平等，皆有联系我们一定要从联系中间看待问题。我们和众生都是都是平等的，和万物都是平等的，然后再去发现之间的联系。如果我们不能正确看待众生平等这件事，那么我们就是孤立的，那也就没有联系可言。因为你看到别人都是别人，你看到自己就是自己。我们和别人没有联系，那么我们的作品就没办法达到共鸣，无法站在观众的角度去体会这个作品的深刻含义在里面。 情理之中，意料之外在片子里面要有兴趣点，而这个兴趣点是意料之外的。如果我们抓住这个了，那么我们的作品就会非常点题。如果我们想要自己的作品不平淡，那么我们的画面中必须要有一个焦点，我们不要以为这个焦点是很实的，也不要以为这个焦点是一个灭点，其实这个点是兴趣点 发现（观察力）· 联系（想象力）· 重组（创造力）——重要的学习方法。 图片管理Bridge拍完片子我们需要做的第一件事就是图片的管理 养成好的文件夹命名习惯：一般以日期+主题作为命名：2017.02.14_情人节 Bridge最重要的浏览方式在于右上方的几个选项必要项 、胶片、元数据、关键字、预览、看片台、文件夹 这里我们选择文件夹方式来浏览，左侧面板第一个模块设置为文件夹模块，第二个模块设置为过滤器模块。 快速预览快速预览：space空格，图片就会全屏显示，想要看细节的话，用鼠标点一下，图片就会100%显示，上下左右可以翻图片，Esc退出全屏。 例选模式选中片子，然后按command + B或者ctrl + B，进入例选模式。←和→是选择图片，↓是剔除图片。 数字底片一定要选用raw格式，一定要用raw的原片去拍，坚决禁止用JPEG（李涛老师好无情）因为用raw格式的原片才能给后期更大的空间 标记command + 数字键或ctrl + 数字键 1~5是打1~5颗星，6是红色，7是黄色，8是绿色，9是蓝色，0是取消星数。 我们从三星开始打起，只要片子看着打眼就标记为三星，忽然间发现一张片子特别棒，给四星。然后片子挑完之后，从四星里面拔五星，从三星里面剔二星。 处理一组片子如果想把一组片子放在一起，比如拍延时，或者接片的这种，我们可以用command + G或者ctrl + G把它们放到一个组里，Group。 本文结束，感谢阅读。 参考资料：[李涛] 简单摄影后期课本文作者：melody0z 本文链接：https://melodyvoid/Photography/folow-teacher-li-tao-in-the-later-01.html 欢迎转载，转载请注明文本链接]]></content>
      <categories>
        <category>Photography</category>
      </categories>
      <tags>
        <tag>后期</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0731]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0731.html</url>
    <content type="text"><![CDATA[必备句型​ Each of us has our own understanding of what love is. 我们每个人都对爱情有着不同的理解 Love is mysterious. 爱很神秘 ​ 场景对话​ A: What do people mean when they say they love someone? B: Each of us has our own understanding of what love is. A: Do you believe in love? B: Love is mysterious, but I do believe in it. ​ 参考译文​ A: 当人们说他们爱某人时，他们是怎么想的呢？ B: 我们每个人都对爱情有着不同的理解。 A: 你相信爱情吗？ B: 爱是很神秘，但是我真的相信它。 ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gulp学习笔记]]></title>
    <url>%2Fgulp%2Fgulp-learning-notes.html</url>
    <content type="text"><![CDATA[gulp是什么我们来看官网给出的解释： Automate and enhance your workflow 翻译过来就是：用自动化构建工具增强你的工作流程！ gulp是前端开发过程中对代码进行构建的工具，是自动化项目的构建利器；它不仅能对网站资源进行优化，而且在开发过程中很多重复的任务能够使用正确的工具自动完成；使用它，我们不仅可以很愉快的编写代码，而且大大提高我们的工作效率。 gulp能用来做什么 搭建web服务器 使用预处理器Sass，Less 压缩优化，可以压缩HTML、css、JavaScript、 图片 自动将更新变化的代码实时显示在浏览器 前端测试 …… gulp有极丰富的插件来帮助我们实现各种功能 gulp插件地址：http://gulpjs.com/plugins 安装gulp前提假设我们已经安装了node，并且对npm也了解 全局安装gulp全局安装gulp目的是为了通过它执行gulp任务 1$ npm install gulp -g 查看是否正确安装，我们在终端输入gulp -v 123$ gulp -v[10:26:05] CLI version 3.9.1[10:26:05] Local version 3.9.1 出现版本号，说明正确安装 新建package.json文件首先我们先新建一个项目文件夹 1$ mkdir Gulp 然后进入项目文件夹 1$ cd Gulp 创建一个package.json 1$ npm init -y 在项目目录里局部安装gulp 1$ npm install gulp --save-dev 创建gulpfile.js在根目录下面创建gulpfile.js文件，此文件为配置文件 自定义任务gulpfile.js 123456const gulp = require("gulp");//定义一个任务gulp.task("hello",()=&gt;&#123; console.log("Hello World");&#125;) 然后在命令行执行gulp任务 12345$ gulp hello[11:51:14] Using gulpfile ~/WebstormProjects/Gulp/gulpfile.js[11:51:14] Starting 'hello'...Hello World[11:51:14] Finished 'hello' after 392 μs 我们会看到打印出了”Hello World” 默认任务gulpfile.js 1234567const gulp = require("gulp");gulp.task("hello",()=&gt;&#123; console.log("Hello World")&#125;);//第一个参数是"default",第二个参数是一个数组，里面存放的是自定义任务名gulp.task("default",["hello"]); 这样我们就可以直接gulp了 1234567$ gulp[12:21:34] Using gulpfile ~/WebstormProjects/Gulp/gulpfile.js[12:21:34] Starting 'hello'...Hello World[12:21:34] Finished 'hello' after 171 μs[12:21:34] Starting 'default'...[12:21:34] Finished 'default' after 43 μs Basic读取想要处理的文件，然后把处理好的文件放到指定的地方 gulp.src()gulp.src()方法可以帮我们找到想要处理的文件 .pipe()然后通过.pipe()来处理这些找出来的文件，pipe就是一个管道，每一个管道里面我们都可以指定它的功能来处理这个文件 .pipe(gulp.dest())最后我们再使用.pipe(gulp.dest())方法，去把处理好的文件放到指定的地方。 dest is short for destination(目的地，目标位置) Copy目录结构 12|--index.html|--gulpfile.js gulpfile.js 123456const gulp = require("gulp");gulp.task("copy",()=&gt;&#123; return gulp.src("index.html") //注意：这里写"./index.html"和"index.html"效果一样 .pipe(gulp.dest("dist"))&#125;); 然后在命令行执行gulp copy 1234$ gulp copy[12:42:06] Using gulpfile ~/WebstormProjects/Gulp/gulpfile.js[12:42:06] Starting 'copy'...[12:42:06] Finished 'copy' after 16 ms 然后目录结构就变了 1234|--dist |--index.html|--index.html|--gulpfile.js glob目录结构 123456789101112|--dist |--index.html|--images |--icon |--01.png |--02.png |--03.png |--01.jpg |--02.jpg |--03.png|--index.html|--gulpfile.js 下面我们要做的就是把jpg图片复制到dist目录下的images文件夹里 gulpfile.js 123456const gulp = require("gulp");gulp.task("images",()=&gt;&#123; return gulp.src("images/*.jpg") //只匹配images目录下的jpg文件 .pipe(gulp.dest("dist/images"))&#125;); 执行gulp images 1234$ gulp images[13:07:12] Using gulpfile ~/WebstormProjects/Gulp/gulpfile.js[13:07:12] Starting 'images'...[13:07:12] Finished 'images' after 39 ms 然后我们观察目录结构变化 123456789101112131415|--dist |--index.html |--images |--01.jpg |--02.jpg|--images |--icon |--01.png |--02.png |--03.png |--01.jpg |--02.jpg |--03.png|--index.html|--gulpfile.js 那么怎么才能把png和jpg都复制过来呢？ gulpfile.js 1234567 const gulp = require("gulp"); gulp.task("images",()=&gt;&#123;- return gulp.src("images/*.jpg") //只匹配images目录下的jpg文件+ return gulp.src("images/*.&#123;jpg,png&#125;") //匹配image目录下的jpg和png文件 .pipe(gulp.dest("dist/images")) &#125;); 执行gulp images后，dist文件夹目录结构如下 123456|--dist |--index.html |--images |--01.jpg |--02.jpg |--03.png 我们再来看，修改一下 12345678910gulpfile.js里面匹配是*.*gulp.src(&quot;images/*.*&quot;)那么dist目录结构|--dist |--index.html |--images |--01.jpg |--02.jpg |--03.png 1234567891011gulpfile.js里面匹配是*gulp.src(&quot;images/*&quot;)那么dist目录结构|--dist |--index.html |--images |--icon |--01.jpg |--02.jpg |--03.png 如果想要深层次匹配 1234567891011121314gulpfile.js里面匹配是**/*gulp.src(&quot;images/**/*&quot;)那么dist目录结构|--dist |--index.html |--images |--icon |--01.png |--02.png |--03.png |--01.jpg |--02.jpg |--03.png 怎么样，images里的文件全都匹配过来了 多个glob目录结构 12345678|--dist |--index.html|--json |--01.json|--xml |--01.xmlindex.htmlgulpfile.js gulpfile.js 123456const gulp = require("gulp");gulp.task("data",()=&gt;&#123; return gulp.src(["json/*.json","xml/*.xml"]) //用数组的形式匹配多个glob .pipe(gulp.dest("dist/data"))&#125;); 执行gulp data dist的目录结构变为 12345|--dist |--index.html |--data |--01.json |--01.xml negate不想包含的文件用!排除 例如json文件夹里 123|--json |--01.json |--negate-01.json 我们不想要negate开头的json文件 gulpfile.js 123456const gulp = require("gulp");gulp.task("data",()=&gt;&#123; return gulp.src(["json/*.json","xml/*.xml","!json/negate-*.json"]) //再多加一个排除的glob，注意前面用！号 .pipe(gulp.dest("dist/data"))&#125;); 执行完过后，就不会复制negate-01.json这个文件了 任务依赖如果一个任务的建立是依赖于其他任务，就需要用到以下的写法 gulpfile.js 1234567891011121314151617181920const gulp = require("gulp");//复制index.htmlgulp.task("copy",()=&gt;&#123; return gulp.src("index.html") .pipe(gulp.dest("dist"))&#125;);//复制图片gulp.task("images",()=&gt;&#123; return gulp.src("images/**/*") .pipe(gulp.dest("dist/images"))&#125;);//复制数据gulp.task("data",()=&gt;&#123; return gulp.src(["json/*.json","xml/*.xml"]) .pipe(gulp.dest("dist/data"))&#125;);//build任务是依赖于前三个任务的，那么我们第二个参数，传入数组，数组里存放的是它所依赖的任务名gulp.task("build",["copy","images","data"],()=&gt;&#123; console.log("编译完成");&#125;) 然后执行gulp build 1234567891011$ gulp build[13:48:20] Using gulpfile ~/WebstormProjects/Gulp/gulpfile.js[13:48:20] Starting 'copy'...[13:48:20] Starting 'images'...[13:48:20] Starting 'data'...[13:48:20] Finished 'copy' after 53 ms[13:48:20] Finished 'data' after 43 ms[13:48:20] Finished 'images' after 52 ms[13:48:20] Starting 'build'...编译完成[13:48:20] Finished 'build' after 154 μs 我们可以看出，copy,images和data三个任务是同时进行的，然后再执行build任务 watch用gulp.watch()方法可以监视文件的变化 gulpfile.js 12345678910111213141516171819202122232425const gulp = require("gulp");//复制index.htmlgulp.task("copy",()=&gt;&#123; return gulp.src("index.html") .pipe(gulp.dest("dist"))&#125;);//复制图片gulp.task("images",()=&gt;&#123; return gulp.src("images/**/*") .pipe(gulp.dest("dist/images"))&#125;);//复制数据gulp.task("data",()=&gt;&#123; return gulp.src(["json/*.json","xml/*.xml"]) .pipe(gulp.dest("dist/data"))&#125;);//监视文件gulp.task("watch",()=&gt;&#123; //当index.html文件变化时，就执行copy任务 gulp.watch("index.html",["copy"]); //当图片变化时，就执行images任务 gulp.watch("images/**/*.&#123;png,jpg&#125;",["images"]); //当数据发生变化时，就执行data任务 gulp.watch(["json/*.json","xml/*.xml","!json/negate-*.json"],["data"]);&#125;); 执行gulp watch就可以监视文件的变化 plugingulp提供了很好的接口，它本身并不会去做太多的事情，除了去可以读取文件，监视文件的变化，可以把文件放到指定的位置，我们可以插件来扩展gulp的功能，这些插件可以取执行特定的任务，比如说： 编译Sass，编译Less 合并文件 压缩、混淆文件 重命名 优化图像的尺寸 创建一个本地的开发服务器 … gulp插件地址：[http://gulpjs.com/plugins 使用方法都类似 先找到所需的插件，然后npm install 插件名 --save-dev安装 然后在gulpfile.js中引入插件const minifycss = require(&quot;gulp-minify-css&quot;) 查看插件文档，看使用方法 gulp-sass安装gulp-sass1$ npm install gulp-sass --save-dev 使用gulp-sass在配置文件gulpfile.js中引入这个插件 12345678const gulp = require("gulp");const sass = require("gulp-sass");gulp.task("sass",()=&gt;&#123; return gulp.src("style/**/*.scss") .pipe(sass()) .pipe(gulp.dest("dist/css"))&#125;); 然后执行gulp sass 呃，我们遇到个错误 1Node Sass does not yet support your current environment: OS X 64-bit with Unsupported runtime (57) 在Stack Overflow上查了一下，说让我们运行一下npm rebuild node-sass 于是我们执行npm rebuild node-sass 然后再执行gulp sass 还是不行，于是我们在https://github.com/sass/node-sass/releases/tag/v3.13.1里看到了 想起来我装的是node的最新版，输入node -v 12$ node -vv8.2.1 也罢，那就等着它支持到8.x了吧。 于是，我们假装成功了（不要脸.jpg) 然后我们就能看见在dist文件夹下有一个css文件夹，里面有style.css文件 gulp-less安装gulp-less1$ npm install gulp-less --save-dev 使用gulp-less在配置文件gulpfile.js中引入这个插件 12345678const gulp = require("gulp");const less = require("gulp-less");gulp.task("less",()=&gt;&#123; return gulp.src("style/**/*.less") .pipe(less()) .pipe(gulp.dest("dist/css"))&#125;); 然后执行gulp less 1234$ gulp less[17:49:26] Using gulpfile ~/WebstormProjects/Gulp/gulpfile.js[17:49:26] Starting 'less'...[17:49:26] Finished 'less' after 72 ms 会在dist下面生成 123|--dist |--css |--style.css gulp-connect安装gulp-connect1$ npm install gulp-connect --save-dev 使用gulp-connect将gulp-connect模块导入 123456789const gulp = require("gulp");const connect = require("gulp-connect");gulp.task("server",()=&gt;&#123; connect.server(&#123; //在这个配置对象里可以配置端口，根目录等相关信息 root:"dist" &#125;)&#125;); 然后执行gulp server，我们会看到如下信息 12345$ gulp server[17:47:54] Using gulpfile ~/WebstormProjects/Gulp/gulpfile.js[17:47:54] Starting 'server'...[17:47:54] Finished 'server' after 51 ms[17:47:54] Server started http://localhost:8080 告诉我们在http://localhost:8080就可以查看网页了 reload当某些文件变化以后，能实时地刷新页面，这样就不用每次修改之后，再手动地刷新页面来查看变化。 打开gulpfile.js,找到创建服务器的任务，把livereload的值设置为true 1234567891011121314151617181920212223242526272829303132333435const gulp = require("gulp");const connect = require("gulp-connect");gulp.task("copy",()=&gt;&#123; return gulp.src("index.html") .pipe(gulp.dest("dist")) //2.文件复制过后执行reload方法 .pipe(connect.reload())&#125;);gulp.task("images",()=&gt;&#123; return gulp.src("images/**/*") .pipe(gulp.dest("dist/images"))&#125;);gulp.task("data",()=&gt;&#123; return gulp.src(["json/*.json","xml/*.xml"]) .pipe(gulp.dest("dist/data"))&#125;);gulp.task("watch",()=&gt;&#123; gulp.watch("index.html",["copy"]); gulp.watch("images/**/*.&#123;png,jpg&#125;",["images"]); gulp.watch(["json/*.json","xml/*.xml","!json/negate-*.json"],["data"]);&#125;);gulp.task("server",()=&gt;&#123; connect.server(&#123; root:"dist", //1.将livereload设置为true livereload: true &#125;)&#125;);//3.设置默认任务，依赖于server和watchgulp.task("default", ["server","watch"]); 执行顺序是 index.html文件发生变化 触发watch任务 watch任务又触发copy任务 将更改后的index.html拷贝到dist文件夹中 reload gulp-concat使用gulp-concat这个插件我们可以使几个文件合并到一块儿 安装插件1$ npm install gulp-concat --save-dev 使用gulp-concat123456789const gulp = require("gulp");//1.引入gulp-concatconst concat = require("gulp-concat");gulp.task("scripts",()=&gt;&#123; return gulp.src("javascript/**/*.js") //2.找到需要合并的js文件 .pipe(concat("index.js")) //3.通过pipe流入concat()方法，concat方法的参数是合并后的名字 .pipe(gulp.dest("dist/js")) //4.流入指定的文件夹&#125;); 合并后的dist目录 123|--dist |--js |--index.js gulp-uglify把几个js文件合并到一块儿，接下来我们可以再压缩混淆一下，完成这个动作我们可以使用gulp-uglify这个插件 安装插件1$ npm install gulp-uglify --save-dev 使用插件123456789101112const gulp = require("gulp");const concat = require("gulp-concat");//1.引入gulp-uglifyconst uglify = require("gulp-uglify");gulp.task("scripts",()=&gt;&#123; return gulp.src("javascript/**/*.js") .pipe(concat("index.js")) //2.合并之后压缩混淆 .pipe(uglify()) .pipe(gulp.dest("dist/js"))&#125;); 然后执行gulp scripts就可以压缩混淆了 注意： 若出现一下种错误，说明js代码有问题 1234events.js:182 throw er; // Unhandled &apos;error&apos; event ^GulpUglifyError: unable to minify JavaScript rename在把处理好的文件存储到指定的位置之前，我们可以重命名一下它，这里使用gulp-rename这个插件 安装插件1$ npm install gulp-rename --save-dev 使用插件12345678910111213const gulp = require("gulp");const concat = require("gulp-concat");const uglify = require("gulp-uglify");const rename = require("gulp-rename");gulp.task("scripts",()=&gt;&#123; return gulp.src("javascript/**/*.js") .pipe(concat("index.js")) .pipe(gulp.dest("dist/js")) .pipe(uglify()) .pipe(rename("index.min.js")) .pipe(gulp.dest("dist/js"))&#125;); 这个就不一一解释了 gulp-minify-css压缩css使用gulp-minify-css 安装插件1$ npm install gulp-minify-css --save-dev 使用插件 1234567891011121314const gulp = require("gulp");const less = require("gulp-less");const connect = require("gulp-connect");const concat = require("gulp-concat");const uglify = require("gulp-uglify");const rename = require("gulp-rename");const minifycss = require("gulp-minify-css");gulp.task("less",()=&gt;&#123; return gulp.src("style/**/*.less") .pipe(less()) .pipe(minifycss()) //如果愿意，在这里也可以压缩完重命名什么的 .pipe(gulp.dest("dist/css"))&#125;); 执行gulp less就可以压缩css代码了 gulp-imagemingulp-imagemin可以帮我们优化图片的尺寸，在保证不改变图像质量的情况下可以让图像的体积变得更小一些，下面我们先去安装一下这个插件 安装插件1$ npm install gulp-imagemin --save-dev 使用插件12345678const gulp = require("gulp");const imagemin = require("gulp-imagemin");gulp.task("images",()=&gt;&#123; return gulp.src("images/**/*") .pipe(imagemin()) .pipe(gulp.dest("dist/images"))&#125;); 然后执行gulp images就可以执行了。 本文结束，感谢阅读。 本文作者：melody0z 本文链接：https://melodyvoid/gulp/gulp-learning-notes.html 欢迎转载，转载请注明文本链接]]></content>
      <categories>
        <category>gulp</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>前端自动化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node学习笔记03]]></title>
    <url>%2FNode%2Fnode-learning-notes-03.html</url>
    <content type="text"><![CDATA[缓冲区处理（二进制数据）什么是缓冲区 缓冲区就是内存中操作数据的容器 只是数据容器而已 通过缓冲区可以很方便的操作二进制数据 而且在大文件操作时必须有缓冲区 为什么要有缓冲区 JavaScript是比较擅长处理字符串，但是早期的应用场景主要用于处理HTML文档，不会有太大篇幅的数据处理，也不会接触到二进制的数据。 而在Node中操作数据、网络通信是没办法完全以字符串的方式操作的 所以在Node中引入了一个二进制的缓冲区的实现：Buffer 创建缓冲区 创建长度为4个字节的缓冲区 1let buffer = new Buffer(4) 通过指定数组内容的方式创建 1let buffer = new Buffer([00,01]) 通过指定编码的方式创建 1let buffer = new Buffer("hello","utf8"); Node默认支持的编码Buffers和JavaScript字符串对象之间转换时需要一个明确的编码方法。下面是字符串的不同编码。 “ASCII” —7位的ASCII数据，这种编码方式非常快，它会移除最高位内容 “UTF8” — 多字节编码Unicode字符。大部分网页和文档使用这类编码方式。 “UTF16LE” — 2个或4个字节，Little Endian（LE）编码Unicode字符。编码范围（U+10000到U+10FFFF)。 “UCS2” — “UTF16LE”的子集。 “base64” — Base64字符编码 “binary” — 仅使用每个字符的头8位将原始的二进制信息进行编码。在需使用Buffer的情况下，应该尽量避免使用这个已经过时的编码方式，这个编码方式将会在未来某个版本中弃用。 “hex” — 每个字节都采用2进制编码。 文件流什么是流？ 文件流、网络流 任何数据的最根本 表现形式都是二进制的 文件流 文件流就是以面向对象的概念对文件数据进行的抽象 文件流定义了一些对文件数据的操作方式 以文件流的方式来拷贝文件1234567891011121314151617181920212223//以文件流的方式复制const fs = require("fs");const path = require("path");//创建读取流let streamReader = fs.createReadStream("./github.css");//创建写入流let streamWriter = fs.createWriteStream("./markdown.css");fs.stat("./github.css",(err,stats) =&gt; &#123; if(stats) &#123; let readTotal = 0; streamReader.on("data",(chunk)=&gt;&#123; streamWriter.write(chunk,(err) =&gt; &#123; console.log("写入进度：" + ((readTotal += chunk.length) / stats.size * 100) + "%"); &#125;) &#125;); streamReader.on("end",()=&gt;&#123; console.log("复制完毕") &#125;) &#125;&#125;); 当然我们还可以用pipe方法 12345678//用pipe的方式复制文件const fs =require("fs");const path = require("path");let streamReader = fs.createReadStream("./github.css");let streamWriter = fs.createWriteStream("./github1.css");streamReader.pipe(streamWriter); 是不是清爽了好多 网络操作相关模块 url：用于解析URL格式的模块 querystring：用于操作类似k1=v1&amp;k2=v2的查询字符串 http：用于创建http服务器或http客户端 URL解析模块 将一个URL字符串解析为一个URL对象 1url.parse(urlStr[,parseQueryString][,slashesDenoteHost]) 将一个URL对象格式化为字符串的形式 1url.format(urlObj) 用于组合URL成员为完整的URL字符串 1url.resolve(from,to) 查询字符串模块（querystring） querystring.escape querystring.parse(str[, sep][, eq][, options]) querystring.stringify(obj[, sep][, eq][, options]) querystring.unescape ​ 本文结束，感谢阅读。 本文作者：melody0z 本文链接：https://melodyvoid/Node/node-learning-notes-03.html 欢迎转载，转载请注明文本链接]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0730]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0730.html</url>
    <content type="text"><![CDATA[必备句型​ We are close friend. 我们是很亲密的朋友 Suspicion is the poison fo true friendship 猜疑是真诚友谊的一副毒剂 ​ 场景对话​ A: It seems that you and Alex are good friends. B: Well,yes. We are close friends, but I don’t really trust him. A: You know,suspicon is the posion of true friendship. ​ 参考译文​ A: 看起来你和Alex非常好。 B: 是的呢，我们是很亲密的朋友，但是我并不是真正信任她。 A: 你要知道，猜疑是真诚友谊的一副毒剂。 ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新概念计划]]></title>
    <url>%2FEassy%2Fnew-concept-plan.html</url>
    <content type="text"><![CDATA[写在前面好久没有写过随笔了，人每当开始树立一个新的目标或是决定开始一项新的任务时总是会异常兴奋，甚至是想用文字来记录下来。下面说说我此篇文章的意义。 ​ 今天是2017年7月30日，我在网上下载了新概念英语的全套录音，然后在淘宝上淘了一套四本新概念英语的旧书(ps:买旧书真的是超值，4本总共才40元，而且买回来基本也是新的）。8月是一个新的开始，而在这新的开始我也将开始我的计划，姑且叫做新概念计划。计划内容大概是用两年时间背完2、3、4册，乍一看两年时间挺长，其实可以说很短，因为我并不是全日制地在学，在背，在自己空余时间用两年时间完成3本书的背诵，任务其实还是挺艰巨的。目标就是把英语口语练好。我希望自己不是三分钟热度，希望自己可以坚持下来，两年后我会回来打卡，到时会写一篇文章做一次思想报告，来汇报新概念计划的完成情况，以及我自己的改变。 关于坚持说到坚持，我其实有很多想跟大家分享的，请大家回想一下自己坚持时间最长的一件有意义的事情是什么，我曾经这样问过我自己，但是我的答案是：Nothing。现在想想还真有点儿可悲，我放弃过很多东西，其实说到底还是自己没有坚持去做。 很多东西放下很容易，但要再次拾起却很难 自己大学毕业到现在一直坚持下来的总共也就四件事： 学编程 学英语 读书 健身 在这个浮躁的世界里，慢就是快 我为什么这么说？我看过太多人不想经过时间的磨练而速成一件事情的，事实告诉你：不可能！“我零基础，在学习JavaScript，两个月能学会吗？” “我报了个培训班，培训四个月，出来后就可以拿10k的工资吗”不知各位看到诸如此类的问题怎么看，反正我是非常反感。我从去年9月开始学习前端，到现在基本上快一年了。我说下我自己的体会，时间的沉淀真的很重要，不要觉得自己一次可以吸收那么多，我每一次看书都有新的体会。当初读Head First系列的从书，很多是看不懂的，一本书读下来能理解吸收50%都是很不错的，到后面随着你接触的越来越多，好多东西你会觉得“哦，原来是这个样子！”那种豁然开朗的心情是非常愉悦的。等等，好像要跑题，说起前端的学习体会，真是一时半会儿说不完的（捂脸.jpg)，然而这次的主题是英语。 咱们继续说坚持，健身，坚持了一年多了，真的有很大的改观，身体变强壮了，胸肌和二头比以前更加结实，这种变化是坚持的结果，绝不是我这个礼拜心血来潮了，练上个三五天就能成的样子。我在健身房发现一个有趣的现象，就是陌生的面孔越来越多，最开始和我一起办卡的那些人，慢慢的都不见踪影了，所能坚持下来一年的超不过10个人（认真脸）one more thing,我还发现一个有趣的现象：健身房里的女生永远比男生多，男士们难道真的这么不在乎自己的体型了吗？还是女生特别在意自己的体型？而且越是身材好的妹子，越能自律。同样的现象也发生在我学习英语的群。上过发音课和练口语的微信群，里面女生的比例远远大于男生。是女生太努力还是男生太忙？不得而知。 关于英语接下来步入正题，说说我学习英语的路线。其实最大的驱动力还是兴趣 我经常会问自己一些问题：为什么学了这么时间英语，英语还是这么烂？ 我记得张庆和我说过，他说“咱们就是学学就放下了，没有一直坚持去学“，说的没错，放下很容易，再拾起就困难了。我在毕业后和万词王曲根老师学习过单词坚持过两个月 然后后来就不学单词了，记得后来每天晚上一直在听一个电台，在网易云音乐上有个叫英语怎么说的节目，内容是萌叔肖恩和女神米歇尔以对话的形式来说英语，不时穿插着汉语在里面，我每一集都听过，现在好像停止更新了。 再到后来，张祎买了一个发音的课，账号分享给我了，我跟着上了课，真的是刷新了我的英语观，没错，真的是刷新，我才发现自己有大概50%的发音都是错误的。于是我决定开始从发音开始练口语，从Bingo到洛基英语到乐口英语，上的公开课以及发音群，真的让我收获了不少。 记得第一次在群里发语音的时候，真是张不开嘴，练了至少20分钟才敢于在群里发20s的语音，虽说我是一个不怎么在乎面子的人，群里也没人认识我，可是张嘴读英语还是那么地难。之前学的都是哑巴英语 我是2017.06.21开始加入了英语跟读计划，至今已经坚持了一个多月，很感谢纠音老师的每一次指导，你的每一次纠音我都有收藏 同样也是由于您给了我前进的动力，您告诉我可以再向上迈一个台阶，每天阅读英文和听听力，再默写之类的。于是乎我决定从新概念下手。在知乎上也看到好多人说新概念是经典中的经典。 关于行动既然已经决定，那就干吧。不要以没有时间做借口，因为现在是你时间最多的时候 You will never have more time than you do right now. 本文结束，感谢阅读。 本文作者：melody0z 本文链接：https://melodyvoid/Eassy/new-concept-plan.html 欢迎转载，转载请注明文本链接]]></content>
      <categories>
        <category>Eassy</category>
      </categories>
      <tags>
        <tag>NCE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0729]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0729.html</url>
    <content type="text"><![CDATA[必备句型​ I do love you. 我真的爱你 I don’t buy your story. 我不相信你的话 ​ 场景对话​ A: Last fall you said we couldn’t be together, and I believe you. Why are you here now? B: I am sorry Alex, but I do love you. And I… A: Enough, I don’t buy your story. ​ 参考译文​ A: 去年秋天你说我们不能在一起，而我相信了你。你来这里做什么？ B: 对不起，Alex。但是我是真的爱你。我… A: 够了，我猜不相信你的话。 ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ECMAScript 6]]></title>
    <url>%2FJavaScript%2Fecmascript-6.html</url>
    <content type="text"><![CDATA[定义变量：let之前：var a = 12;现在：let a = 12;代码块：用{}包含起来的代码，比如if、for、while let特点：只能在代码块里面使用 var 只有函数作用域 1234567891011&#123; let a = 12; alert(a); //弹出12；&#125;alert(a); //报错，a is not defined&#123; var a = 12; alert(a); //弹出12；&#125;alert(a); //弹出12 1234567var a = 12;var a = 5;alert(a); //弹出12let a = 12;let a = 5;alert(a); //报错，a已经被声明过了 let 具备块级作用域 不能重复声明总结：其实let才是接近其他语言的变量 用处封闭空间： 123456以前：(function()&#123; //code...&#125;)();现在：&#123; //code...&#125; 1234567891011(function()&#123; var a = 12; alert(a); //弹出12；&#125;)()；alert(a); //报错，a is not defined&#123; let a = 12; alert(a); //弹出12；&#125;alert(a); //报错，a is not defined i值问题： 12345678910111213141516171819202122232425var aBtn = document.getElementsByTagName("input");for(var i = 0;i&lt;aBtn.length;i++)&#123; aBtn[i].onclick = function()&#123; alert(i); //这肯定是错的，加入页面上有3个btn，那么总弹出3 &#125;&#125;解决办法：使用封闭空间以前：var aBtn = document.getElementsByTagName("input");for(var i = 0;i&lt;aBtn.length;i++)&#123; (function(index)&#123; aBtn[index].onclick = function()&#123; alert(index); &#125; &#125;)(i); &#125;现在：将var改为letvar aBtn = document.getElementsByTagName("input");for(let i = 0;i&lt;aBtn.length;i++)&#123; aBtn[i].onclick = function()&#123; alert(i); &#125;&#125; 总结：块级作用域其实就是匿名函数立即调用 const1234567891011var a = "组件"；a = 12;alert(a); //弹出12let a = "大组件"；a = 12;alert(a); //弹出12如果定义一个常量，我们用constconst a = "大组件"；a = 5; //试图修改常量会报错 const用来定义常量，一旦赋值，以后再也修改bu不了了，而且必须一次性赋完值 const a; a = 12;这样是错的。 注意：const必须给初始值，因为以后再也无法赋值了。并且不能重复的声明。 字符串连接之前： “abc” + 变量名 + “ef” 123var a = "a";var e = 'e';var str = a + "bcd" + e + "fg"; 现在： `abc${变量名}ef` 123var a = "a";var e = "e";var str = `$&#123;a&#125;bdc$&#123;e&#125;fg`; //反单引号 解构赋值123456789var [a,b,c] = [12,5,101];console.log(a,b,c); //12,5,101var &#123;a,b,c&#125; = &#123;a:12,b:5,c:101&#125;;console.log(a,b,c); //12,5,101var &#123;a,b,c&#125; = &#123;b:5,a:12,c:101&#125;;console.log(a,b,c); //12,5,101我们可以发现，json解构跟顺序无关，因为json本身就是无序的 模式匹配 左侧的样子需要和右侧一样 1234匹配[12,[1,2],5]var [a,[b,c],d] = [12,[1,2],5];var [&#123;a,e&#125;,[b,c],d] = [&#123;e:"eee",a:"aaa"&#125;,[1,2],5]; 交互： [{“title”:””,”href”:””,”img”:””}]; 解构赋值还可以给默认值： var json = {}; var a = json.a || 12; 语法： var {time=12,id=0} = {}; 12345function getPos()&#123; return &#123;left:100,top1:1000&#125;&#125;var &#123;left,top1&#125; = getPos();console.log(left,top1); //100,1000 复制数组 循环 1234567var arr = [1,2,3];var arr2 = [];for(var i = 0;i&lt;arr.length;i++)&#123; arr2[i] = arr[i];&#125;arr2.pop();console.log(arr,arr2); //[1,2,3],[1,2] Array.from 1234var arr = [1,2,3];var arr2 = Array.from(arr);arr2.pop();console.log(arr,arr2); //[1,2,3],[1,2] var arr2 = […arr]; 1234var arr = [1,2,3];var arr2 = [...arr];arr2.pop();console.log(arr,arr2); //[1,2,3],[1,2] …的用法 12345function show ()&#123; arguments.push(4); console.log(arguments); //报错arguments.push is not a function&#125;show(1,2,3); 12345function show (...args)&#123; args.push(4); console.log(args); //[1,2,3,4]&#125;show(1,2,3); 循环普通for循环 for in循环 新增了for of循环：用来遍历（迭代、循环）整个对象，表现有点类似于for in 1234var arr = ["apple","banana","orange"];for(var i in arr)&#123; console.log(i); //0,1,2 是索引key&#125; 1234var arr = ["apple","banana","orange"];for(var i of arr)&#123; console.log(i); //apple,banana,orange 是值value&#125; for of循化可以循环数组，不能循环json。而它真正的目的是为了循环 map对象 map对象： ​ 和json相似，也是一种key-value形式。 ​ map对象为了和for of循环配合而生的。 1234567891011121314var map = new Map();//设置：map.set(name,value)map.set("a","apple");map.set("b","banana");console.log(map); // &#123;"a" =&gt; "apple", "b" =&gt; "banana"&#125;//获取：map.get(name)console.log(map.a); //undefined 说明这样获取不对console.log(map.get("a")); //apple,获取的正确姿势//删除：map.delete(name)delete map.a;console.log(map); //&#123;"a" =&gt; "apple", "b" =&gt; "banana"&#125; 说明删除失败map.delete("a"); //&#123;"b" =&gt; "banana"&#125;删除的正确姿势 注意：遍历map不能使用for in，使用for in没有效果 12345678910111213141516171819202122232425var map = new Map();map.set("a","apple");map.set("b","banana");map.set("c","orange");for(var name of map)&#123; //默认是键值对全有 console.log(name); //a,apple b,banana c,orange&#125;for(var [key,value] of map)&#123; console.log(key,value); //key value&#125;for(var name of map.entries())&#123; console.log(name); //a,apple b,banana c,orange&#125;for(var [key,value] of map.entries())&#123; console.log(key,value); //key value&#125;//只循环keyfor(var key in map.keys())&#123; console.log(key); //a,b,c&#125;//只循环valuefor(var value in map.values())&#123; console.log(value); //apple,banana,orange&#125; for of 也可以循环数组 123456789101112var arr = ["西游记","三国演义"];for(var value of arr)&#123; console.log(value); //"西游记"，"三国演义"&#125;//只循环索引for(var key of arr.keys())&#123; console.log(key); //0,1&#125;//索引和值都循环for(var some of arr.entries())&#123; console.log(some); [0, "西游记"] [1, "三国演义"]&#125; 箭头函数函数：之前 1234function show()&#123; alert(1);&#125;show(); 1234function show(a)&#123; return a;&#125;show(12); 1234function show(a,b)&#123; return a + b;&#125;show(12,5); 123456对比：var arr = [34,101,-100,90,98,77777];arr.sort(function (a,b) &#123; return a - b;&#125;);console.log(arr); // [-100, 34, 90, 98, 101, 77777] 123var arr = [34,101,-100,90,98,77777];arr.sort((a,b)=&gt;a-b);console.log(arr); // [-100, 34, 90, 98, 101, 77777] 1234567891011function show(a)&#123; return a&#125;var show = a =&gt; a;function show(a,b)&#123; return a + b &#125;var show = (a,b) =&gt; a + b;function show()&#123; return "welcome" &#125;var show = () =&gt; "welcome";function show()&#123; alert(1) &#125;var show = () =&gt; &#123; alert(1) &#125; 注意：this的指向问题，this指向了window 123456789var a = 101;var json = &#123; a:1, b:2, show:() =&gt;&#123; alert(this.a); //弹出结果是101 &#125;&#125;json.show(); //弹出结果是101，因为this指向了window 注意：arguments不能使用了 123456789function show()&#123; console.log(arguments); // [1, 2, 3, callee: ƒ, Symbol(Symbol.iterator): ƒ]&#125;show(1,2,3);var show = () =&gt;&#123; console.log(arguments); //报错：arguments is not defined&#125;show(1,2,3); 对象对象语法简洁化 单例模式： 1234567891011var person = &#123; name:"Jack", age:18, showName: function()&#123; alert(this.name); &#125;, showAge:function()&#123; alert(this.age); &#125;&#125;person.showName(); //弹出Jack 12345678910111213var name = "Jack";var age = 18;var person = &#123; name, age, showName()&#123; alert(this.name); &#125;, showAge()&#123; alert(this.age); &#125;&#125;person.showName(); //Jack 面向对象 之前： 1234567891011121314151617181920212223function Person(name,age)&#123; //又是类，又是构造函数 this.name = name; this.age = age;&#125;Perosn.prototype.showName = function()&#123; return this.name;&#125;;Perosn.prototype.showAge = function()&#123; return this.age;&#125;//Workerfunction Worker(name,age,job)&#123; Person.call(this.name,age); this.job = job;&#125;function F()&#123;&#125;;F.prototype = Person.prototype;Worker.prototype = new F();Worker.constructor = Worker;var p = new Person("Jack",18);var w = new Worker("Mary",16);alert(p.showName); //弹出Jackalert(w.showName); //弹出Mary ES6里有类的概念了： 类 class 构造函数 constructor 生成完实例之后自己就执行的函数 123456789101112131415161718192021222324252627class Person&#123; //类 constructor(name="default",age=0)&#123; this.name = name; this.age = age; &#125; showName()&#123; return this.name; &#125; showAge()&#123; return this.age; &#125;&#125;//继承class Worker extends Person&#123; constructor(name,age,job="扫地的")&#123; super(name,age); //执行父级的constructor this.job = job; &#125; showJob()&#123; return this.job; &#125;&#125;var p = new Person("Jack",18);alert(p.showName()); //弹出”Jack“var w = new Worker("Mary",19,"coder");alert(w.showJob()); //弹出"coder" 123456789101112131415161718class Queue&#123; constructor(content = [])&#123; this._queue = [...content]; &#125; shift()&#123; const vaule = this._queue[0]; this._queue.shift(); return value; &#125; push(n)&#123; this._queue.push(n); return this._queue.length; &#125;&#125;var q = new Queue([1，2，3，4])；q.shift();q.push(5);console.log(q._queue); //[2,3,4,5] 模块化seajs、requirejs ES6自带模块化 必须引入traceur和bootstrap，type必须写成module 如何定义（导出）模块： 12const a = 12;export default a; 如何使用（引用）模块 1import modA from "a.js" 123a.js:const a = 12;export default a; 123b.js:const a = 5;export default b; 1234index.html:import modA from "a.js";import modB from "b.js";console.log(modA + modB); //17 123456sum.jsimport a from "a.js";import b from "b.js";export default function sum()&#123; return a + b;&#125; 123index.html:import sumMod from "sum.js";console.log(sumMod()); //17 导出多个模块 1234c.js:const a = 12;const b = 5;export default &#123;a,b&#125;; 123index.html:import c from "c.js";console.log(c.a + c.b); Promisepromise—承诺 就是一个对象，用来传递异步操作的数据（消息） 三种状态： pending：初始状态 fulfilled：成功的操作 rejected：失败的操作 123456789var p = new Promise(function(resolve,reject)&#123; if(异步处理成功了)&#123; resolve(成功数据) &#125;else&#123; reject(失败原因) &#125;&#125;)；p.then(onFilfulled,onRejected);//接收两个函数作为参数，一个在fulfilled的时候被调用，一个在rejected的时候被调用，接收参数就是onFulfilled对应resolve，onRejected对应reject 12345678var p = new Promise(function(resolve,reject)&#123; resolve(1);&#125;);p.then(function(value)&#123; alert("成功了:" + value); //弹出："成功了：1"&#125;,function(vaule)&#123; alert("失败了:" + value);&#125;) 123456789var p = new Promise(function(resolve,reject)&#123; //resolve(1); reject(2);&#125;);p.then(function(value)&#123; alert("成功了:" + value); &#125;,function(vaule)&#123; alert("失败了:" + value); //弹出："失败了：2"&#125;) 1234567891011var p = new Promise(function(resolve,reject)&#123; resolve(1);&#125;);p.then(function(value)&#123; console.log(value); //1 return value + 1; //返回值，供下次使用&#125;,function(vaule)&#123; alert("失败了:" + value);&#125;).then(function(value)&#123; console.log(value); //2&#125;) Generator是一个函数，可以遍历，generator就是一个状态机 语法： 1function show()&#123;&#125; //普通函数 123function *show()&#123; yield xxx&#125; //generator函数 形式上： 函数名字前面有* 函数内部使用yield语句 1234567891011function* show()&#123; yield "Hello"; yield "World"; yield "ES6";&#125;var res = show();console.log(res.next()); //&#123;value:"Hello",done:false&#125;console.log(res.next()); //&#123;value:"World",done:false&#125;console.log(res.next()); //&#123;value:"ES6",done:false&#125;console.log(res.next()); //&#123;value:undefined,done:true&#125;//最后一个为什么是undefined呢?因为函数没有返回值 总结：每次返回一个value的done的结果 value，每次yield后面的值 done，是一个布尔值，代表是否遍历结束 yield是否有返回值？ ​ yield语句本身没有返回值，或者每次返回undefined next可以带参数？ ​ 给上一个yield值 for…of循环 ​ 循环generator函数 本文结束，感谢阅读。 本文作者：melody0z 本文链接：https://melodyvoid/JavaScript/ecmascript-6.html 欢迎转载，转载请注明文本链接]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>ECMAScript 6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[循环创建文件夹]]></title>
    <url>%2FNode%2Fcycle-creation-folder.html</url>
    <content type="text"><![CDATA[创建文件夹目录结构 |— 20-mkdir.js 12345678const fs = require("fs");const path = require("path");fs.mkdir(path.join(__dirname,"demo1"),(err) =&gt; &#123; console.log(err)&#125;);fs.mkdir(path.join(__dirname,"./demo2"),(err) =&gt; &#123; console.log(err)&#125;); 执行20-mkdir.js 123$ node 20-mkdir.js nullnull 目录结构变为 |— 20-mkdir.js |— demo1 |— demo2 报错什么情况下会报错呢？ 文件夹已经存在目录结构 |— 20-mkdir.js |— demo1 |— demo2 这里的意思是原本就已经存在demo1和demo2，我们试着再创建一下 同样执行20-mkdir.js 1234567891011$ node 20-mkdir.js &#123; Error: EEXIST: file already exists, mkdir '/Users/melody0z/github/nodejs/second/demo1' errno: -17, code: 'EEXIST', syscall: 'mkdir', path: '/Users/melody0z/github/nodejs/second/demo1' &#125;&#123; Error: EEXIST: file already exists, mkdir '/Users/melody0z/github/nodejs/second/demo2' errno: -17, code: 'EEXIST', syscall: 'mkdir', path: '/Users/melody0z/github/nodejs/second/demo2' &#125; 报错信息为Error: EEXIST: file already exists说文件夹已经存在。 不存在的文件夹20-mkdir.js 1234567891011 const fs = require("fs"); const path = require("path");- fs.mkdir(path.join(__dirname,"demo1"),(err) =&gt; &#123;- console.log(err)- &#125;);- fs.mkdir(path.join(__dirname,"./demo2"),(err) =&gt; &#123;- console.log(err)- &#125;);+ fs.mkdir(path.join(__dirname,"./test/demo3"),(err) =&gt; &#123;+ console.log(err);+ &#125;); 执行20-mkdir.js 123456$ node 20-mkdir.js &#123; Error: ENOENT: no such file or directory, mkdir '/Users/melody0z/github/nodejs/second/test/demo3' errno: -2, code: 'ENOENT', syscall: 'mkdir', path: '/Users/melody0z/github/nodejs/second/test/demo3' &#125; 报错信息Error: ENOENT: no such file or directory不存在的文件夹，因为我们并没有test文件夹，所以它不会帮我们创建，就直接报错。 创建层级目录我们先来创建一个模块 mkdirs.js 12function mkdirs(pathname,callback)&#123;&#125;module.exports = mkdirs; 在21-mkdirs.js中引入 123const fs = require("fs");const path = require("path");const mkdirs = require("./mkdirs"); 这是大体的骨架，然后我们来完善mkdirs.js模块 123456789101112131415161718+ //我们需要文件操作，文件操作就需要引入fs和path+ const fs = require("fs");+ const path = require("path"); function mkdirs(pathname, callback) &#123;+ //1.判断传入的是否是绝对路径+ pathname = path.isAbsolute(pathname)+ ? pathname+ : path.join(__dirname, pathname);+ //2.获取想要创建的部分+ // /Users/melody0z/github/nodejs/second/test/demo3+ // test文件夹和demo3文件夹需要创建，我们需要获取+ // dirname 是/Users/melody0z/github/nodejs/second+ pathname = pathname.replace(__dirname,"");+ console.log(pathname); &#125; module.exports = mkdirs; 写到这里我们来测试一下，在21-mkdirs.js中 123456const fs = require("fs");const path = require("path");const mkdirs = require("./mkdirs");mkdirs("test/demo3");mkdirs("/Users/melody0z/github/nodejs/second/test/demo3") 执行 123$ node 21-mkdirs.js /test/demo3/test/demo3 是我们想要的结果，我们得到了test和demo3 然而我们还有一种方法，那就是path模块自带的path.relative()方法 mkdirs.js中 12345678910111213141516 const fs = require("fs"); const path = require("path"); function mkdirs(pathname, callback) &#123; //1.判断传入的是否是绝对路径 pathname = path.isAbsolute(pathname) ? pathname : path.join(__dirname, pathname); //2.获取想要创建的部分 // /Users/melody0z/github/nodejs/second/test/demo3 // test文件夹和demo3文件夹需要创建，我们需要获取 // dirname 是/Users/melody0z/github/nodejs/second- //pathname = pathname.replace(__dirname,"");+ pathname = path.relative(__dirname,pathname); console.log(pathname); &#125; module.exports = mkdirs; 其余不变，我们再来执行21-mkdirs.js 123$ node 21-mkdirs.js test/demo3test/demo3 同样也能得到test和demo3。 以上两种方法的区别仅仅是多一个少一个/ 好了，我们用第二种方法接着往下写 mkdirs.js 12345678910111213141516171819const fs = require("fs");const path = require("path");function mkdirs(pathname, callback) &#123; //1.判断传入的是否是绝对路径 pathname = path.isAbsolute(pathname) ? pathname : path.join(__dirname, pathname); //2.获取想要创建的部分 // /Users/melody0z/github/nodejs/second/test/demo3 // test文件夹和demo3文件夹需要创建，我们需要获取 // dirname 是/Users/melody0z/github/nodejs/second let relativePath = path.relative(__dirname,pathname); let folders = relativePath.split(path.sep); console.log(folders);&#125;module.exports = mkdirs; 注意14行let folders = relativePath.split(path.sep);中不能写成let folders = relativePath.split(&quot;/&quot;);因为windows和POSIX平台上是不同的，需要用path.sep来代替。 然后我们执行一下21-mkdirs.js来测试一下 123$ node 21-mkdirs.js [ 'test', 'demo3' ][ 'test', 'demo3' ] good！是我们想要的结果。 我们继续写 12345678910111213141516171819202122232425262728 const fs = require("fs"); const path = require("path"); function mkdirs(pathname, callback) &#123; //1.判断传入的是否是绝对路径 pathname = path.isAbsolute(pathname) ? pathname : path.join(__dirname, pathname); //2.获取想要创建的部分 // /Users/melody0z/github/nodejs/second/test/demo3 // test文件夹和demo3文件夹需要创建，我们需要获取 // dirname 是/Users/melody0z/github/nodejs/second let relativePath = path.relative(__dirname,pathname); let folders = relativePath.split(path.sep);+ //3.遍历，由于遍历是同步的(文件夹需要有顺序)，创建文件夹也需要同步+ //同步的话就需要用try...catch来捕获错误+ try&#123;+ folders.forEach(folder =&gt; &#123;+ fs.mkdirSync(path.join(__dirname,folder));+ &#125;);+ callback &amp;&amp; callback(null);+ &#125;catch (error)&#123;+ callback &amp;&amp; callback(error)+ &#125; &#125;module.exports = mkdirs; 21-mkdirs.js 12345const fs = require("fs");const path = require("path");const mkdirs = require("./mkdirs");mkdirs(path.join(__dirname,"test/demo3")); 我们来执行一下21-mkdirs.js 目录结构发生了变化 |— 21-mkdirs.js |— mkdirs.js |— test |— demo3 我们发现demo3并没有在test文件夹里面，所以我们还需要修改 mkdirs.js 123456789101112131415161718192021222324252627282930 const fs = require("fs"); const path = require("path"); function mkdirs(pathname, callback) &#123; //1.判断传入的是否是绝对路径 pathname = path.isAbsolute(pathname) ? pathname : path.join(__dirname, pathname); //2.获取想要创建的部分 // /Users/melody0z/github/nodejs/second/test/demo3 // test文件夹和demo3文件夹需要创建，我们需要获取 // dirname 是/Users/melody0z/github/nodejs/second let relativePath = path.relative(__dirname,pathname); let folders = relativePath.split(path.sep);+ let pre = ""; try&#123; folders.forEach(folder =&gt; &#123;- fs.mkdirSync(path.join(__dirname,folder));+ fs.mkdirSync(path.join(__dirname,pre,folder));+ pre = path.join(pre,folder); &#125;); callback &amp;&amp; callback(null); &#125;catch (error)&#123; callback &amp;&amp; callback(error) &#125; &#125; module.exports = mkdirs; 我们再来执行21-mkdirs.js 目录结构 |— 21-mkdirs.js |— mkdirs.js |— test |— demo3 这样就打成我们的目标了 ​ 注意点我们更改一下目录结构 |— module |— mkdirs.js |— 21-mkdirs.js 再来执行21-mkdirs.js就会报错，说文件夹已存在，原因就在于mkdirs.js模块里的__dirname; __dirname是相对于mkdirs.js模块的路径，而我们需要的是谁引用了mkdirs.js模块，路径就相对于谁，这里需要使用module.parent. module/mkdirs.js 12345678910111213141516171819202122232425262728293031323334353637383940const fs = require("fs");const path = require("path");function mkdirs(pathname, callback) &#123; const filename = module.parent.filename; const root = path.dirname(filename); //1.判断传入的是否是绝对路径 pathname = path.isAbsolute(pathname) ? pathname : path.join(root, pathname); //2.获取想要创建的部分 // /Users/melody0z/github/nodejs/second/test/demo3 // test文件夹和demo3文件夹需要创建，我们需要获取 // __dirname 是/Users/melody0z/github/nodejs/second //pathname = pathname.replace(__dirname,""); //注意：这里的__dirname有问题，应该是谁调用这个模块，__dirname就是就是这个文件的路径 let relativePath = path.relative(root,pathname); let folders = relativePath.split(path.sep); let pre = ""; try&#123; folders.forEach(folder =&gt; &#123; try&#123; //检测文件夹状态，文件夹不存在跳到catch里面去创建 fs.statSync(path.join(root,pre,folder)); &#125;catch (error)&#123; fs.mkdirSync(path.join(root,pre,folder)); &#125; pre = path.join(pre,folder); &#125;); callback &amp;&amp; callback(null); &#125;catch (error)&#123; callback &amp;&amp; callback(error) &#125;&#125;module.exports = mkdirs; 21-mkdirs.js 12345678910const fs = require("fs");const path = require("path");const mkdirs = require("./module/mkdirs");mkdirs(path.join(__dirname,"test/demo3/demo4"),(err) =&gt; &#123; console.log(err)&#125;);mkdirs(path.join(__dirname,"test/demo3/demo5"),(err) =&gt; &#123; console.log(err)&#125;); 我们执行后，创建的目录如下 |— test |— demo3 |— demo4 |— demo5 ​ ​ 本文结束，感谢阅读。 本文作者：melody0z 本文链接：https://melodyvoid/Node/cycle-creation-folder.html 欢迎转载，转载请注明文本链接]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0728]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0728.html</url>
    <content type="text"><![CDATA[必备句型​ What the hell is wrong with you? 你到底怎么了？ I mean it. 我是认真的。 ​ 场景对话​ A: I’ve had enough, I don’t wanna talk to you anymore,and I don’t want to see you again in my life. B: What the hell is wrong with you? Are you kidding me? A: No,I mean it. ​ 参考译文​ A: 我真的受够了，不想再跟你说话，这辈子都不想再见到你了。 B: 你到底怎么了？你是在开玩笑吗？ A: 不，我是认真的。 ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文件写入]]></title>
    <url>%2FNode%2Ffile-write.html</url>
    <content type="text"><![CDATA[我们来看一下如何写一个文件。 创建19-writeFile.js 首先，先引入fs模块和path模块 12const fs = require("fs");const path = require("path"); 写入文件一共有三种方式， 异步写入 fs.writeFile() 同步写入 fs.writeFileSync() 以流的方式写入 fs.createWriteStream() ​ 一、fs.writeFile() 123456789101112const fs = require("fs");const path = require("path");const filename = path.join(__dirname,"./demo.txt");fs.writeFile(filename,&#123;name:"Jack"&#125;,(err) =&gt; &#123; if(err)&#123; console.log("error"); &#125;else&#123; console.log("success"); &#125;&#125;); fs.writeFile()的第二个参数是类型值，可以是any，我们刚写入了一个对象，看看会是什么结果。我们执行一下 12$ node 19-writeFile.js success 写入成功，我们看看demo.txt里是什么 1[object Object] 我们可以发现，写入的内容就是object.toString()过后的结果。 那么怎么才能达到我们想要的结果呢？ 答案是用JSON.stringify()把对象转换为JSON（序列化） JSON.stringify() =&gt; 序列化 JSON.parse() =&gt; 反序列化 我们修改一下上面的代码 123456789101112const fs = require("fs");const path = require("path");const filename = path.join(__dirname,"./demo.txt");fs.writeFile(filename,JSON.stringify(&#123;name:"Jack"&#125;),(err) =&gt; &#123; if(err)&#123; console.log("error"); &#125;else&#123; console.log("success"); &#125;&#125;); 再来执行一下。我们看到demo.txt是如下结果 1&#123;&quot;name&quot;:&quot;Jack&quot;&#125; 什么情况会出现写文件错误呢？ 意外错误 文件权限问题 文件夹找不到（不会自动创建文件夹） 二、fs.writeFileSync() 123456789const fs = require("fs");const path = require("path");const filename = path.join(__dirname,"./demo.txt");try&#123; fs.writeFileSync(filename,JSON.stringify(&#123;name:"Mary"&#125;));&#125;catch (e)&#123; console.log(e)&#125; 执行过后，demo.txt里的内容变为 1&#123;&quot;name&quot;:&quot;Mary&quot;&#125; 三、fs.createWriteStream() 12345678910const fs = require("fs");const path = require("path");const filename = path.join(__dirname,"./demo.txt");let writeStream = fs.createWriteStream(filename);writeStream.write("Hello",(err) =&gt; &#123; if (err) throw err; console.log("写入成功")&#125;); 执行过后，demo.txt里的内容变为 1Hello 以上就是写入文件的三种方式。 but，我们发现了一个问题，就是文件写入默认是会覆盖之前的内容的，那么怎么才能不覆盖呢？好，我们引出下面的API，fs.appendFile(),用法和上面的一样。 123456789101112const fs = require("fs");const path = require("path");const filename = path.join(__dirname,"./demo.txt");fs.appendFile(filename,&#123;name:"Jack"&#125;,(err) =&gt; &#123; if(err)&#123; console.log("error"); &#125;else&#123; console.log("success"); &#125;&#125;); 执行本代码过后，demo.txt里的内容变为了 1Hello&#123;&quot;name&quot;:&quot;Jack&quot;&#125; 本文结束，感谢阅读。 本文作者：melody0z 本文链接：https://melodyvoid/Node/file-write.html 欢迎转载，转载请注明文本链接]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>文件写入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[arguments]]></title>
    <url>%2FJavaScript%2Farguments.html</url>
    <content type="text"><![CDATA[1234567891011var length = 10;function fn()&#123; alert(this.length)&#125;var obj = &#123; length: 5, method: function(fn) &#123; arguments[0]() &#125;&#125;obj.method(fn)//输出1 这里没有输出5，也没有输出10，反而输出了1，有趣。这里arguments是javascript的一个内置对象（可以参见mdn：arguments - JavaScript**），是一个类数组（就是长的比较像数组，但是欠缺一些数组的方法，可以用slice.call转换，具体参见上面的链接），其存储的是函数的参数。也就是说，这里arguments[0]指代的就是你method函数的第一个参数：fn，所以arguments0的意思就是：fn()。 不过这里有个疑问，为何这里没有输出5呢？我method里面用this，不应该指向obj么，至少也会输出10呀，这个1是闹哪样？ 1234567arguments = &#123; 0: fn, //也就是 functon() &#123;alert(this.length)&#125; 1: 第二个参数, //没有 2: 第三个参数, //没有 ..., length: 1 //只有一个参数&#125; 所以这里alert出来的结果是1。 如果要输出5应该咋写呢？直接 method: fn 就行了。 我们可以看看最后这个调用：obj.method(fn).其中，obj是对象，method是obj的方法，fn是method的参数，fn是函数的名–引用对应的函数。arguments是取得当前method函数的参数数组，arguments[0]就是参数fn。加个括号其实是函数调用。这个obj.method(fn) 在runtime就是fn()，即调用alert(this.length)。比较操蛋的是现在有三个length，第一是global的length=10,其次是obj的this.length=5，还有一个是arguments数组本身的length属性，其值等于1——只有一个参数传给obj.method方法。这个例子讲的是JavaScript中this引用的，这个的this是caller的this，这里引用是arguments数组的length。所以这个例子的结果是：alert(arguments.length); = alert(1) 本文结束，感谢阅读。 本文作者：melody0z 本文链接：https://melodyvoid/JavaScript/arguments.html 欢迎转载，转载请注明文本链接]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>arguments</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node学习笔记02]]></title>
    <url>%2FNode%2Fnode-learning-notes-02.html</url>
    <content type="text"><![CDATA[核心模块和对象核心模块的意义 如果只是在服务器运行JavaScript代码，意义并不大，因为无法实现任何功能（读写文件，访问网络）。 Node的用处在于它本身还提供的一系列功能模块，用于与操作系统互动。 这些核心的功能模块在Node中内置。 内置模块： path: 处理文件路径 fs: 操作（CRUD）文件系统 CRUD—增加（Create）、读取查询（Retrieve)、更新（Update）和删除（Delete） child_process: 新建子进程 util: 提供一系列实用小工具 http: 提供HTTP服务器功能 url: 用于解析URL querystring: 解析URL中的查询字符串 crypto: 提供加密和解密功能 …… 包的概念什么是包 由于Node是一套轻内核的平台，虽然提供了一系列的内置模块，但是不足以满足开发者的需求，于是乎出现了包（package）的概念。 与核心模块类似，就是将一些预先设计好的功能或者API封装到一个文件夹，提供给开发者使用 包的加载机制 id：包名的情况：require(“http”) 现在系统核心（优先级最高）的模块中找（以后不要创建一些和现有的包重名的包） 然后再到当前项目中node_modules目录中找 如何管理那么多的包 由于Node本身并没有太多的功能性API，所以市面上涌现出大量的第三方人员开发出来的Package 包的生态圈一旦繁荣起来，就必须有工具去代替人脑或者文档的方式管理 NPMNPM概述Node Package Manager 随着时间的发展，NPM出现了两层概念： 一层含义是Node的开放式模块登记和管理系统，也可以说是一个生态圈，一个社区 另一层含义是Node默认的模块管理器，是一个命令行下的软件，用来安装和管理Node模块 安装NPM NPM不需要单独安装，默认在安装Node的时候，会连带一起安装NPM。 但是，Node附带的NPM可能不是最新版本，最好用下面的命令，更新到最新版本 npm install npm -g 默认安装到当前系统Node所在目录下。 常用NPM命令 npm config npm init npm search npm info npm install npm uninstall npm list npm outdated npm update npm run npm cache 文件系统操作相关模块 fs：基础的文件操作API path：提供和路径相关的操作API readline：用于读取大文本文件，一行一行读 fs-extra(第三方) https://www.npmjs.com/package/fs-extra 路径操作模块（path) 在文件操作的过程中，都“必须”使用物理路径（绝对路径） path模块提供了一系列一系列与路径相关的API path.join([p1][,p2]…) =&gt;连接多个路径 path.basename(p,ext) =&gt;获取文件名 path.dirname(p) =&gt;获取文件夹路径 path.extname(p) =&gt;获取文件扩展名 path.format(obj) 和path.parse(p) 一个是格式化对象为字符串，一个是将字符串解析为对象 path.relative(from,to) =&gt; 获取从from到to的相对路径。 同步或异步调用 fs模块对文件的几乎所有操作都有同步和异步两种形式 例如：readFile() 和readFileSync() 区别： 同步调用会阻塞代码的执行，异步则不会 异步调用会将读取任务下达到任务队列，知道任务执行完成才会回调 异常处理方面，同步必须使用try…catch方式，异步可以通过回调函数的第一个参数（错误优先） 文件读取 异步文件读取 fs.readFile(file[,option],callback(err,data)) 同步文件读取 fs.readFileSync(file[,option]) 文件流的方式读取 fs.createReadStream(path[,options]) readline模块逐行读取文本12345678const readline = require("readline");const fs = require("fs");const rl = readline.createInterface(&#123;input:fs.createReadStream("sample.txt")&#125;);rl.on("line",(line) =&gt; &#123; console.log("Line from file:",line);&#125;); 文件写入 确保操作没有额外的问题，一定使用绝对路径的方式 异步文件写入 fs.writeFile(file,data[,option],callback(err)) 同步文件写入 fs.writeFileSync(file,data[,option]) 流式文件写入 fs.createWriteStream(path[,option]) 默认写入操作是覆盖源文件 异步追加 fs.appendFile(file,data[,option],callback(err)) 同步追加 fs.appendFileSync(file,data[,options]) 其他文件操作 获取文件信息 fs.stat(path,callback(err,stats)) fs.statSync(path) =&gt;返回一个fs.stats实例 移动文件 fs.rename(oldPath,newPath) 重命名文件或目录 fs.rename(oldPath,newPath,callback) fs.renameSync(oldPath,newPath) 删除文件 fs.unlink(path,callback(err)) fs.unlinkSync(path) 目录操作 创建一个目录 fs.mkdir(path[,model],callback) fs.mkdirSync(path[,model]) 删除一个空目录 fs.rmdir(path,callback) fs.rmdirSync(path) 读取一个目录 fs.readdir(path,callback(err,files)) fs.readdirSync(path) =&gt; 返回files 监视文件 监视文件变化 fs.watchFile(filename[,options],listener(curr,prev)) options:{persistent,interval} fs.watch(filename[,options][,listener]) 本文结束，感谢阅读。 本文作者：melody0z 本文链接：https://melodyvoid/Node/node-learning-notes-02.html 欢迎转载，转载请注明文本链接]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0727]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0727.html</url>
    <content type="text"><![CDATA[必备句型​ Mind your own business. 管好你自己的事 What do you mean by saying so? 你这样说是什么意思？ ​ 场景对话​ A: I still don’t understand, why did you do that? B: It’s not what you think. Mind your own business. A: What do you mean by saying so? I was just trying to help. ​ 参考译文​ A: 我还是不明白，你为什么要那样做？ B: 不是你想的那样，管好你自己的事。 A: 你这样说是什么意思？我只是想帮忙。 ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[以文件流的方式读取文件内容]]></title>
    <url>%2FNode%2Freads-file-contents-in-a-file-stream.html</url>
    <content type="text"><![CDATA[目录结构 |— 16.createStream.js |— blood.lrc 12345678910111213141516171819const fs = require("fs");const path = require("path");const iconv = require("iconv-lite");const filename = path.join(__dirname,"./blood.lrc");//创建一个文件读取流let stream = fs.createReadStream(filename);//让文件流通过iconv过滤编码stream = stream.pipe(iconv.decodeStream("gbk"));let content = "";stream.on("data",(chunk) =&gt; &#123; content += chunk;&#125;);//读取结束stream.on("end",() =&gt; &#123; console.log(content);&#125;) 我们来执行一下它 1234567$ node 16-createStream.js [ti:血染的风采][ar:黄耀明]...中间省略[03:19.42] 共和国的旗帜上有我们血染的风采[03:25.51] * * *[03:32.98] ---End--- 我们尝试着让歌词滚动显示 |— 17-showLyric.js 123456789101112131415161718192021222324252627282930313233const fs = require("fs");const path = require("path");const iconv = require("iconv-lite");const filename = path.join(__dirname,"./blood.lrc");fs.readFile(filename,(err,data) =&gt; &#123; if(err) throw err; let lines = iconv.decode(data,"gbk").split("\n"); //[00:32.67] 也许我告别 将不再回来 let regexp = /\[(\d&#123;2&#125;):(\d&#123;2&#125;)\.(\d&#123;2&#125;)]\s(.+)/; let start = new Date().getTime(); //遍历 lines.forEach((line) =&gt; &#123; // [00:32.67] 也许我告别 将不再回来 let matches = regexp.exec(line); if(matches)&#123; let min = matches[0]; let sec = parseFloat(matches[2]); let ms = parseFloat(matches[3]); let lyric = matches[4]; let time = min * 60 * 1000 + sec * 1000 + ms; //当前歌词不是立即执行，由于下达任务的时刻不同我们要设置时间偏移量 let offset = new Date().getTime(); setTimeout(() =&gt; &#123; console.log(lyric) &#125;,time - offset); &#125;else&#123; //不是一句歌词 console.log(line); &#125; &#125;)&#125;) 执行16.showLyric.js 12345678910$ node 17-showLyric.js [ti:血染的风采][ar:黄耀明][al:人山人海][offset:500][00:55.04]中文歌词库 www.CnLyric.com歌曲：血染的风采歌手：黄耀明^C 我们成功了。 我们以上拆分歌词是用split(&quot;\n&quot;)拆分成数组，然后再遍历每一句这样做的。然而node给我们提供了一个模块叫做readline.我们下面用readline模块完成同样的业务。 18-readline.js 12345678910111213141516171819202122232425262728293031//readline实现一行一行读取歌词const fs = require("fs");const path = require("path");const iconv = require("iconv-lite");const readline = require("readline");const filename = path.join(__dirname,"./blood");const readStream = fs.createReadStream(filename) .pipe(iconv.decodeStream("gbk"));let rl = readline.createInterface(&#123;input:readStream&#125;);let regexp = /\[(\d&#123;2&#125;):(\d&#123;2&#125;)\.(\d&#123;2&#125;)]\s(.+)/;let start = new Date().getTime();rl.on("line",(line) =&gt; &#123; if(matches)&#123; let min = parseFloat(matches[1]); let sec = parseFloat(matches[2]); let ms = parseFloat(matches[3]); let lyric = matches[4]; let time = min * 60 * 1000 + sec * 1000 + ms; //当前歌词不是立即执行，由于下达任务的时刻不同我们要设置时间偏移量 let offset = new Date().getTime() - start; setTimeout(() =&gt; &#123; console.log(lyric); &#125;,time - offset); &#125;else&#123; //不是一句歌词 console.log(line); &#125;&#125;) 执行18-readline.js 12345678910$ node 18-readline.js [ti:血染的风采][ar:黄耀明][al:人山人海][offset:500][00:55.04]中文歌词库 www.CnLyric.com歌曲：血染的风采歌手：黄耀明^C ​ ​ 本文结束，感谢阅读。 本文作者：melody0z 本文链接：https://melodyvoid/Node/reads-file-contents-in-a-file-stream.html 欢迎转载，转载请注明文本链接]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>文件流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用自定义事件的方法实现拖拽组件的开发]]></title>
    <url>%2FJavaScript%2Fimplementation-of-drag-and-drop-components-using-custom-events.html</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100&lt;script&gt; window.onload = function () &#123; var d1 = new Drag(); d1.init(&#123; id: "div1" &#125;); var d2 = new Drag(); d2.init(&#123; id: "div2" &#125;); bindEvent(d2, "toDown", function () &#123; document.getElementById("div2").style.backgroundColor = "yellow" &#125;); var d3 = new Drag(); d3.init(&#123; id: "div3" &#125;); bindEvent(d3, "toDown", function () &#123; document.getElementById("div3").style.backgroundColor = "yellowgreen" &#125;); bindEvent(d3, "toUp", function () &#123; document.getElementById("div3").style.backgroundColor = "purple" &#125;); var d4 = new Drag(); d4.init(&#123; id: "div4" &#125;); bindEvent(d4, "toUp", function () &#123; alert("byebye") &#125;) &#125;; function Drag() &#123; this.obj = null; this.deltaX = 0; this.deltaY = 0; this.settings = &#123;&#125; &#125; Drag.prototype.init = function (opt) &#123; var This = this; this.obj = document.getElementById(opt.id); extend(this.settings, opt); this.obj.onmousedown = function (ev) &#123; var ev = ev || window.event; This.fnDown(ev); fireEvent(This, "toDown"); document.onmousemove = function (ev) &#123; var ev = ev || window.event; This.fnMove(ev); return false; &#125;; document.onmouseup = function () &#123; This.fnUp(); fireEvent(This, "toUp"); &#125;; return false; &#125; &#125;; Drag.prototype.fnDown = function (ev) &#123; this.deltaX = ev.clientX - this.obj.offsetLeft; this.deltaY = ev.clientY - this.obj.offsetTop; &#125;; Drag.prototype.fnMove = function (ev) &#123; this.obj.style.left = ev.clientX - this.deltaX + "px"; this.obj.style.top = ev.clientY - this.deltaY + "px"; &#125;; Drag.prototype.fnUp = function () &#123; document.onmousemove = null; document.onmouseup = null; &#125;; function bindEvent(obj, events, fn) &#123; obj.listeners = obj.listeners || &#123;&#125;; obj.listeners[events] = obj.listeners[events] || []; obj.listeners[events].push(fn); if (obj.nodeType) &#123; if (obj.addEventListener) &#123; obj.addEventListener(events, fn, false); &#125; else &#123; obj.attachEvent("on" + events, fn); &#125; &#125; &#125; function fireEvent(obj, events) &#123; if (obj.listeners &amp;&amp; obj.listeners[events]) &#123; for (var i = 0; i &lt; obj.listeners[events].length; i++) &#123; obj.listeners[events][i](); &#125; &#125; &#125; function extend(obj1, obj2) &#123; for (var attr in obj2) &#123; obj1[attr] = obj2[attr]; &#125; &#125; &lt;/script&gt; 本文结束，感谢阅读。 本文作者：melody0z 本文链接：https://melodyvoid/JavaScript/implementation-of-drag-and-drop-components-using-custom-events.html 欢迎转载，转载请注明文本链接]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编码问题]]></title>
    <url>%2FNode%2Fcoding-problem.html</url>
    <content type="text"><![CDATA[fs在读取文件的时候，会把文件读取为buffer，buffer有一个toString()方法，可以把文件转换为字符串，但是默认编码是utf8，读取编码为gbk的文件就会乱码。本文将会读取一个编码为gbk的歌词文件，下面是过程。 目录结构 |— 14-readFileSync.js |— blood.lrc 14-readFileSync.js 123456789101112//同步读取文件的内容//所有的文件操作都是基于fs模块const fs = require("fs");//无论是同步还是异步，文件操作都要使用绝对路径const path = require("path");//将文本读取到一个buffer中const buffer = fs.readFileSync(path.join(__dirname,"./blood.lrc"));//将buffer中的内容读取出来const data = buffer.toString();console.log(data); 执行14-readFileSync.js 12345678910$ node 14-readFileSync.js [ti:ѪȾ�ķ��][ar:��ҫ��][al:��ɽ�˺�][offset:500][00:01.21] ������ѪȾ�ķ��...中间省略[03:19.42] ���͹���������������ѪȾ�ķ��[03:25.51] * * *[03:32.98] ---End--- 读取出来的是乱码，为什么是乱码呢？因为编码问题，.lrc文件是gbk编码，node默认是utf8编码 为了解决编码问题，我们需要引入第三方模块 iconv-lite 在项目目录下创建package.json 1$ npm init -y 1$ npm install iconv-lite --save-dev 好了，模块安装好了之后我们就可以直接引用了 14-readFileSync.js 123456789101112 const fs = require("fs"); const path = require("path"); const buffer = fs.readFileSync(path.join(__dirname,"./blood.lrc")); - const data = buffer.toString();- console.log(data); + //我们需要引入第三方模块+ const iconv = require("iconv-lite");+ const data2 = iconv.decode(buffer,"gbk");+ console.log(data2); 执行14-readFileSync.js 123456$ node 14-readFileSync.js [ti:血染的风采][ar:黄耀明]...中间省略[03:25.51] * * *[03:32.98] ---End--- done,成功读取。 下面我们用异步的方式再来读取一下 15-readFile.js 12345678910const fs = require("fs");const path = require("path");const iconv = require("iconv-lite");const filename = path.join(__dirname,"./blood.lrc");fs.readFile(filename,(err,data) =&gt; &#123; if(err) throw err; console.log(iconv.decode(data,"gbk"));&#125;); 执行15-readFile.js 123456$ node 15-readFile.js [ti:血染的风采][ar:黄耀明]...中间省略[03:25.51] * * *[03:32.98] ---End--- 也一样读取成功。 ​ 本文结束，感谢阅读。 本文作者：melody0z 本文链接：https://melodyvoid/Node/coding-problem.html 欢迎转载，转载请注明文本链接]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>编码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0726]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0726.html</url>
    <content type="text"><![CDATA[必备句型​ This is gonna be the hottest day we’ve had so far this summer. 今夏以来这大概是最热的一天了 You can say that again. 你说的一点也没错 ​ 场景对话​ A: Oh my God. It’s so hot today. This is gonna be the hottest day we’ve had so far this summer. B: You can say that again! I’ve never suffered so much from the heat. ​ 参考译文​ A: 我的天啊，今天好热，今夏以来这大概是最热的一天了。 B: 你说的一点也没错，我还从没有经受过这么炎热的天气。 ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[path模块]]></title>
    <url>%2FNode%2Fpath-module.html</url>
    <content type="text"><![CDATA[path.basename(path[,ext])语法：path.basename(path[,ext]) path:路径 例：/Users/melody0z/github/nodejs/second/a.txt ext: 扩展名 （extension) 例：.txt 返回一个path的最后一部分，也就是文件名。 12345path.basename("/Users/melody0z/github/nodejs/second/a.txt")// a.txtpath.basename("/Users/melody0z/github/nodejs/second/a.txt",".txt");// a path.delimiter提供平台特定的路径分隔符 windows上是; POSIX上是: 12345console.log(process.env.PATH);// /usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbinconsole.log(process.env.PATH.split(path.delimiter));// [ '/usr/local/bin', '/usr/bin', '/bin', '/usr/sbin', '/sbin' ] path.dirname(path)语法：path.dirname(path) path: 路径 例如：/Users/melody0z/github/nodejs/second/a.txt 返回一个path的目录名 12path.dirname("/Users/melody0z/github/nodejs/second/a.txt")// /Users/melody0z/github/nodejs/second path.extname(path)语法：path.extname(path) path: 路径 例如：/Users/melody0z/github/nodejs/second/a.txt 返回path的扩展名，即从 path 的最后一部分中的最后一个 .（句号）字符到字符串结束。 如果 path 的最后一部分没有 . 或 path 的文件名（见 path.basename()）的第一个字符是 .，则返回一个空字符串。 1234567891011121314path.extname('index.html');// 返回: '.html'path.extname('index.coffee.md');// 返回: '.md'path.extname('index.');// 返回: '.'path.extname('index');// 返回: ''path.extname('.index');// 返回: '' path.parse(path)语法：path.parse(path) path.parse() 方法返回一个对象，对象的属性表示 path 的元素。 返回的对象有以下属性： dir root base name ext 在POSIX上： 1234567891011121314path.parse('/home/user/dir/file.txt');// 返回:// &#123; root: '/',// dir: '/home/user/dir',// base: 'file.txt',// ext: '.txt',// name: 'file' &#125;┌─────────────────────┬────────────┐│ dir │ base │├──────┬ ├──────┬─────┤│ root │ │ name │ ext │" / home/user/dir / file .txt "└──────┴──────────────┴──────┴─────┘(请无视以上字符串中的空格，它们只是为了布局) 在 Windows 上： 123456789101112131415path.parse('C:\\path\\dir\\file.txt');// 返回:// &#123; root: 'C:\\',// dir: 'C:\\path\\dir',// base: 'file.txt',// ext: '.txt',// name: 'file' &#125;┌─────────────────────┬────────────┐│ dir │ base │├──────┬ ├──────┬─────┤│ root │ │ name │ ext │" C:\ path\dir \ file .txt "└──────┴──────────────┴──────┴─────┘(请无视以上字符串中的空格，它们只是为了布局) path.format(pathObject) pathObject dir root base name ext 返回一个path字符串 path.format() 方法会从一个对象返回一个路径字符串。 与 path.parse() 相反。 当 pathObject 提供的属性有组合时，有些属性的优先级比其他的高： 如果提供了 pathObject.dir，则 pathObject.root 会被忽略 如果提供了 pathObject.base 存在，则 pathObject.ext 和 pathObject.name 会被忽略 例如，在 POSIX 上： 1234567891011121314151617181920212223242526// 如果提供了 `dir`、`root` 和 `base`，则返回 `$&#123;dir&#125;$&#123;path.sep&#125;$&#123;base&#125;`。// `root` 会被忽略。path.format(&#123; root: '/ignored', dir: '/home/user/dir', base: 'file.txt'&#125;);// 返回: '/home/user/dir/file.txt'// 如果没有指定 `dir`，则 `root` 会被使用。// 如果只提供了 `root` 或 `dir` 等于 `root`，则平台的分隔符不会被包含。// `ext` 会被忽略。path.format(&#123; root: '/', base: 'file.txt', ext: 'ignored'&#125;);// 返回: '/file.txt'// 如果没有指定 `base`，则 `name` + `ext` 会被使用。path.format(&#123; root: '/', name: 'file', ext: '.txt'&#125;);// 返回: '/file.txt' 在 Windows 上： 12345path.format(&#123; dir: 'C:\\path\\dir', base: 'file.txt'&#125;);// 返回: 'C:\\path\\dir\\file.txt' path.isAbsolute(path)path: 路径 返回一个布尔值 path.isAbsolute() 方法会判定 path 是否为一个绝对路径。 如果给定的 path 是一个长度为零的字符串，则返回 false。 例如，在 POSIX 上： 1234path.isAbsolute('/foo/bar'); // truepath.isAbsolute('/baz/..'); // truepath.isAbsolute('qux/'); // falsepath.isAbsolute('.'); // false 在 Windows 上： 1234567path.isAbsolute('//server'); // truepath.isAbsolute('\\\\server'); // truepath.isAbsolute('C:/foo/..'); // truepath.isAbsolute('C:\\foo\\..'); // truepath.isAbsolute('bar\\baz'); // falsepath.isAbsolute('bar/baz'); // falsepath.isAbsolute('.'); // false path.join([…paths])…pahts 一个路径片段的序列 返回一个完整路径字符串 path.join() 方法使用平台特定的分隔符把全部给定的 path 片段连接到一起，并规范化生成的路径。 长度为零的 path 片段会被忽略。 如果连接后的路径字符串是一个长度为零的字符串，则返回 &#39;.&#39;，表示当前工作目录。 例子： 12345path.join('/foo', 'bar', 'baz/asdf', 'quux', '..');// 返回: '/foo/bar/baz/asdf'path.join('foo', &#123;&#125;, 'bar');// 抛出 'TypeError: Path must be a string. Received &#123;&#125;' path.normalize(path)path: 路径 返回一个正常版的路径字符串 path.normalize() 方法会规范化给定的 path，并解析 &#39;..&#39; 和 &#39;.&#39; 片段。 当发现多个连续的路径分隔符时（如 POSIX 上的 / 与 Windows 上的 \ 或 /），它们会被单个的路径分隔符（POSIX 上是 /，Windows 上是 \）替换。 末尾的多个分隔符会被保留。 如果 path 是一个长度为零的字符串，则返回 &#39;.&#39;，表示当前工作目录。 例如，在 POSIX 上： 12path.normalize('/foo/bar//baz/asdf/quux/..');// 返回: '/foo/bar/baz/asdf' 在 Windows 上： 12path.normalize('C:\\temp\\\\foo\\bar\\..\\');// 返回: 'C:\\temp\\foo\\' path.relative(from,to)path.relative() 方法返回从 from 到 to 的相对路径（基于当前工作目录）。 如果 from 和 to 各自解析到同一路径（调用 path.resolve()），则返回一个长度为零的字符串。 如果 from 或 to 传入了一个长度为零的字符串，则当前工作目录会被用于代替长度为零的字符串。 例如，在 POSIX 上： 12path.relative('/data/orandea/test/aaa', '/data/orandea/impl/bbb');// 返回: '../../impl/bbb' 在 Windows 上： 12path.relative('C:\\orandea\\test\\aaa', 'C:\\orandea\\impl\\bbb');// 返回: '..\\..\\impl\\bbb' path.resolve([…paths])…paths 一个路径或路径片段的序列 返回一个绝对路径 path.resolve() 方法会把一个路径或路径片段的序列解析为一个绝对路径。 给定的路径的序列是从右往左被处理的，后面每个 path 被依次解析，直到构造完成一个绝对路径。 例如，给定的路径片段的序列为：/foo、/bar、baz，则调用 path.resolve(&#39;/foo&#39;, &#39;/bar&#39;, &#39;baz&#39;) 会返回 /bar/baz。 如果处理完全部给定的 path 片段后还未生成一个绝对路径，则当前工作目录会被用上。 生成的路径是规范化后的，且末尾的斜杠会被删除，除非路径被解析为根目录。 长度为零的 path 片段会被忽略。 如果没有传入 path 片段，则 path.resolve() 会返回当前工作目录的绝对路径。 例子： 123456789path.resolve('/foo/bar', './baz');// 返回: '/foo/bar/baz'path.resolve('/foo/bar', '/tmp/file/');// 返回: '/tmp/file'path.resolve('wwwroot', 'static_files/png/', '../gif/image.gif');// 如果当前工作目录为 /home/myself/node，// 则返回 '/home/myself/node/wwwroot/static_files/gif/image.gif' path.sep提供了平台特定的路径片段分隔符： Windows 上是 \ POSIX 上是 / 例如，在 POSIX 上： 12'foo/bar/baz'.split(path.sep);// 返回: ['foo', 'bar', 'baz'] 在 Windows 上： 12'foo\\bar\\baz'.split(path.sep);// 返回: ['foo', 'bar', 'baz'] 注意：在 Windows 上，斜杠字符（/）和反斜杠字符（\）都可作为路径分隔符； 但 path 的方法只添加反斜杠（\）。 本文结束，感谢阅读。 参考资料：node官方文档本文作者：melody0z 本文链接：https://melodyvoid/Node/path-module.html 欢迎转载，转载请注明文本链接]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>path模块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0725]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0725.html</url>
    <content type="text"><![CDATA[必备句型​ I think that a good friend should be a good listener. 我觉得一个好朋友应该善于倾听 I’m so lucky to such a friend like you. 有你这样的朋友真是幸运。 ​ 场景对话​ A: I think that a good friend should be a good listener. B: That’s true. I’m so lucky to have such a friend like you. A: Me,too,thank you for all you have done for me. ​ 参考译文​ A: 我觉得一个好朋友应该善于倾听。 B: 确实，有你这样的朋友真是幸运。 A: 我也是，感谢你为我所做的一切。 ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义事件]]></title>
    <url>%2FJavaScript%2Fcustom-event.html</url>
    <content type="text"><![CDATA[什么是组件？ 对面向对象的深入应用（UI组件，功能组件） 将配置参数、方法、事件三者分离 创建自定义组件 有利于多人协作开发代码 如何去挂载自定义事件与事件函数 自定义事件：主要是跟函数有关系，就是让函数能够具备事件的某些特性。 用原生的方法写自定义事件 123456789101112131415161718192021222324252627282930313233343536373839window.onload = function()&#123; var oDiv = document.getElementById("div1"); var oSpan = document.getElementById("span1"); bindEvent(oDiv,"click",function()&#123; alert(1); &#125;); bindEvent(oDiv,"click",function()&#123; alert(2); &#125;); bindEvent(oSpan,"show",function()&#123; alert(3); &#125;); bindEvent(oSpan,"show",function()&#123; alert(4); &#125;); bindEvent(oSpan,"hide",function()&#123; alert(5); &#125;); fireEvent(oSpan,"show"); //弹出3，4 function bindEvent(obj,events,fn)&#123; obj.listeners = obj.listensrs || &#123;&#125;; obj.listeners[events] = obj.listeners[events] || []; obj.listeners[events].push(fn); if(obj.addEventListener)&#123; obj.addEventListener(events,fn,false); &#125;else&#123; obj.attachEvent("on" + events,fn); &#125; &#125; function fireEvent(obj,events)&#123; for(var i = 0;i &lt; obj.listeners[events].length;i++)&#123; obj.listeners[events][i](); &#125; &#125;&#125; 本文结束，感谢阅读。 本文作者：melody0z 本文链接：https://melodyvoid/JavaScript/custom-event.html 欢迎转载，转载请注明文本链接]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0724]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0724.html</url>
    <content type="text"><![CDATA[必备句型​ It’s hard to imagine what it would be like to have no friends. 真难以想象没有朋友会是什么样子 I totally agree with you. 我完全同意你的看法 ​ 场景对话​ A: I have a lot of close friends. B: You must be pretty happy then? A: Yeah, It’s hard to imagine what it would be like to have no friends. B: I totally agree with you. ​ 参考译文​ A: 我有很多好朋友。 B: 那你一定很快乐吧。 A: 是的，真难以想象没有朋友会是个什么样子。 B: 我完全同意你的看法。 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模块化结构]]></title>
    <url>%2FNode%2Fmodular-structure.html</url>
    <content type="text"><![CDATA[模块化代码结构 Node采用的模块化结构是commonJS规范 模块与文件是一一对应关系，即加载一个模块，实际上就是加载对应的一个模块文件 CommonJS模块的特点 所有代码都运行在模块作用域，不会污染全局作用域。 模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。 模块加载的顺序，按照其在代码中出现的顺序。 模块的分类 文件模块 就是我们自己写的功能模块文件 核心模块 Node平台自带的一套基本的功能模块，也有人称之为Node平台的API 第三方模块 社区或者第三方个人开发好的功能模块，可以直接拿回来用 模块化开发的流程 创建模块（foo.js) 导出成员（module.exports = {}) 载入模块 （let foo = require(“./foo.js”) 使用模块 （foo.bar()) 模块内的（伪）全局环境我们在文件操作中必须使用绝对路径 __dirname 用于获取当前文件所在目录的完整路径； 在REPL环境无效 __filename 用来获取当前文件的完整路径； 在REPL环境无效； module 模块对象 exports 映射到module.exports的别名 require() require.cache require.extensions require.main require.resolve() module对象Node内部提供一个module构建函数。所有模块都是module的实例。有以下属性： module.id 模块的识别符，通常是带有绝对路径的模块文件名。 module.filename 模块定义的文件的绝对路径。 module.loaded返回一个布尔值，表示模块是否已经加载完毕。 module.parent 返回一个对象，表示调用该模块的模块 module.children 返回一个数组，表示该模块要用到的其他模块。 module.exports 表示模块对外输出的值。 载入一个模块就是构建一个module实例 看个例子 |— module |— module.js |— 05-module.js module/module.js 1console.log(module); 05-module.js 1234const foo = require("./module/module");console.log("----------------------------------------");console.log(module); 然后我们执行05-module.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253$ node 05-module.js Module &#123; id: '/Users/melody0z/github/nodejs/second/module/module.js', exports: &#123;&#125;, parent: Module &#123; id: '.', exports: &#123;&#125;, parent: null, filename: '/Users/melody0z/github/nodejs/second/05-module.js', loaded: false, children: [ [Circular] ], paths: [ '/Users/melody0z/github/nodejs/second/node_modules', '/Users/melody0z/github/nodejs/node_modules', '/Users/melody0z/github/node_modules', '/Users/melody0z/node_modules', '/Users/node_modules', '/node_modules' ] &#125;, filename: '/Users/melody0z/github/nodejs/second/module/module.js', loaded: false, children: [], paths: [ '/Users/melody0z/github/nodejs/second/module/node_modules', '/Users/melody0z/github/nodejs/second/node_modules', '/Users/melody0z/github/nodejs/node_modules', '/Users/melody0z/github/node_modules', '/Users/melody0z/node_modules', '/Users/node_modules', '/node_modules' ] &#125;----------------------------------------Module &#123; id: '.', exports: &#123;&#125;, parent: null, filename: '/Users/melody0z/github/nodejs/second/05-module.js', loaded: false, children: [ Module &#123; id: '/Users/melody0z/github/nodejs/second/module/module.js', exports: &#123;&#125;, parent: [Circular], filename: '/Users/melody0z/github/nodejs/second/module/module.js', loaded: true, children: [], paths: [Object] &#125; ], paths: [ '/Users/melody0z/github/nodejs/second/node_modules', '/Users/melody0z/github/nodejs/node_modules', '/Users/melody0z/github/node_modules', '/Users/melody0z/node_modules', '/Users/node_modules', '/node_modules' ] &#125; 模块的定义 一个新的js文件就是一个模块 一个合格的模块应该是有导出成员的，否则模块就失去了定义的价值。 模块内部是一个独立（封闭）的作用域（模块与模块之间不会冲突） 模块之间必须通过导出或导入的方式协同 导出方式： exports.name = value; module.exports = {name:value} module.exports和exports module.exports是用于为模块导出成员的接口 exports是指向module.exports的别名，相当于在模块开始的时候执行：var exports = module.exports; 一旦为module.exports赋值，就会切断之前两者的相关性； 最终模块的导出成员以module.exports为准。 看个例子 |— module |— module.exports.js |— 06-module.exports.js module/module.exports.js 123456789let a = 10;let msg = "hello";function foo() &#123; return "我是函数"&#125;exports.a = a;exports.msg = msg;exports.foo = foo; 06-module.exports.js 1234const bar = require("./module/module.exports");console.log(bar.a);console.log(bar.msg);console.log(bar.foo()); 然后我们执行06-module.exports.js 1234$ node 06-module.exports.js 10hello我是函数 然后我们用module.exports的方式改写一下 123456789101112131415 let a = 10; let msg = "hello"; function foo() &#123; return "我是函数" &#125; - exports.a = a;- exports.msg = msg;- exports.foo = foo; + module.exports = &#123;+ a:a,+ msg:msg,+ foo:foo+ &#125;; 执行06-module.exports.js 1234$ node 06-module.exports.js 10hello我是函数 我们再用ES6的语法简化一下 1234567891011121314151617 let a = 10; let msg = "hello"; function foo() &#123; return "我是函数" &#125; - module.exports = &#123;- a:a,- msg:msg,- foo:foo- &#125;;+ module.exports = &#123;+ a,+ msg,+ foo+ &#125;; 执行结果和上面的一样。 载入模块 Node使用commonJS模块规范，内置的require函数用于加载模块文件。 require的基本功能是，读入并执行一个JavaScript文件，然后返回该模块的exports对象。 如果没有发现执行模块，会报错。 模块的加载机制id：路径的情况就是直接以相对路径的方式找文件 require实现机制 将传入的模块ID通过加载规则找到对应的模块文件 读取这个文件里面的代码 通过拼接的方式为该段代码构建私有空间 执行该代码 拿到module.exports返回 我们手动写一个$require函数 |— module |— module.exports.js |— 07-$require.js 12345678910111213141516171819202122232425262728293031323334//自己写一个require函数，目的是了解require的实现机制function $require(id) &#123; //1.先找到文件，文件不存在报错 //2.读取文件内容，内容是js代码 const fs = require("fs"); const path = require("path"); //要加载js的路径（完整路径） const filename = path.join(__dirname,id); const dirname = path.dirname(filename); let code = fs.readFileSync(filename,"utf8"); //同步读取文件，不会加入到事件队列 //3.执行代码，所要执行的代码需要营造一个私有空间 let module = &#123; id:filename, exports:&#123;&#125; &#125;; let exports = module.exports; code = `(function ($require,module,exports,__dirname,__filename) &#123; $&#123;code&#125; &#125;)($require,module,exports,dirname,filename)` eval(code); //4.返回值 return module.exports;&#125;const bar = $require("./module/module.exports.js");console.log(bar.a);console.log(bar.msg);console.log(bar.foo()); 然后执行 1234$ node 07-\$reqiure.js 10hello我是函数 require扩展名require加载文件时可以省略扩展名： require(&quot;./module&quot;) require(&quot;./module.js&quot;)此时文件按js文件执行 require(&quot;./module.json&quot;)此时文件按JSON文件解析 require(&quot;./module.node&quot;)此时文件预编译好的C++模块执行 优先级是js&gt;json&gt;node require加载文件规则 通过./后../开头：则按照相对路径从当前文件所在文件夹开始寻找模块； require(&quot;../file.js&quot;) 上级目录下找file.js文件 通过/开头：则以系统根目录开始寻找模块； require(&quot;/Users/melody0z/github/nodejs/second/module/file.js&quot;) 以绝对路径的方式寻找 如果参数字符串不以”./“或”/“开头，则表示加载的是一个默认提供的核心模块（位于node的系统安装目录中） require(&quot;fs&quot;) 加载核心模块中的文件系统（file system)模块 或者从当前目录向上搜索node_modules目录中的文件： require(&quot;my_module&quot;); 各级node_modules文件夹中搜索my_module.js文件； require加载目录规则 如果require传入的是一个目录的路径，会自动查看该目录的package.json文件，然后加载main字段指定的入口文件 如果package.json文件没有main字段，或者根本就没有package.json文件，则默认找目录下的index.js文件作为模块 require(&quot;./module&quot;);当前目录下找module文件夹中的index.js文件 模块的缓存 第一次加载某个模块时，Node会缓存该模块。以后再加载该模块，就直接冲缓存取出该模块的module.exports属性（不会再次执行该模块） 如果需要多次执行模块中的代码，一般可以让模块暴露行为（函数） 模块的缓存可以通过require.cache拿到，同样也可以删除 验证模块有缓存 目录结构 |— date.js |— 08.cache.js date.js 1module.exports = new Date(); 08-cache.js 12345const date = require("./date");setInterval(() =&gt; &#123; console.log(date.getTime());&#125;,1000); 执行08-cache.js 1234567$ node 08-cache.js 15009326952781500932695278150093269527815009326952781500932695278^C 看，每次输出的时间戳一样，说明结果被缓存起来了。 我们再来看 目录结构 |— date.js |— 09.cache2.js 09-cache2.js 1234567let last;setInterval(() =&gt; &#123; const date = require("./date"); console.log(last === date); last = date; console.log(date.getTime());&#125;,1000); 执行 12345678910$ node 09-cache2.js false1500933712763true1500933712763true1500933712763true1500933712763^C 同样证明有缓存 缓存长什么样？ 目录结构 |— date.js |— 10.cache3.js 10-cache3.js 12const date = require("./date")console.log(require.cache); 我们打印一下缓存看看 1234567891011121314151617181920212223242526272829303132333435363738&#123; '/Users/melody0z/github/nodejs/second/10-cache3.js': Module &#123; id: '.', exports: &#123;&#125;, parent: null, filename: '/Users/melody0z/github/nodejs/second/10-cache3.js', loaded: false, children: [ [Object] ], paths: [ '/Users/melody0z/github/nodejs/second/node_modules', '/Users/melody0z/github/nodejs/node_modules', '/Users/melody0z/github/node_modules', '/Users/melody0z/node_modules', '/Users/node_modules', '/node_modules' ] &#125;, '/Users/melody0z/github/nodejs/second/date.js': Module &#123; id: '/Users/melody0z/github/nodejs/second/date.js', exports: 2017-07-24T22:09:00.024Z, parent: Module &#123; id: '.', exports: &#123;&#125;, parent: null, filename: '/Users/melody0z/github/nodejs/second/10-cache3.js', loaded: false, children: [Object], paths: [Object] &#125;, filename: '/Users/melody0z/github/nodejs/second/date.js', loaded: true, children: [], paths: [ '/Users/melody0z/github/nodejs/second/node_modules', '/Users/melody0z/github/nodejs/node_modules', '/Users/melody0z/github/node_modules', '/Users/melody0z/node_modules', '/Users/node_modules', '/node_modules' ] &#125; &#125; 我们发现，缓存和module对象类似 了解了缓存之后，我们就知道如何清除缓存了 目录结构 |— date.js |— 11-swipecache.js 11-swipecache.js 1234567setInterval(() =&gt; &#123; Object.keys(require.cache).forEach((key) =&gt; &#123; delete require.cache[key]; &#125;); const date = require("./date"); console.log(date.getTime());&#125;,1000); 执行11-swipecache.js 123456$ node 11-swipecache.js 1500935467664150093546869215009354696991500935470701^C 注意： 先清除缓存，再require。 下面我们将自己写的$require加上缓存 123456789101112131415161718192021222324252627282930313233343536function $require(id) &#123; const fs = require("fs"); const path = require("path"); const filename = path.join(__dirname, id); $require.cache = $require.cache || &#123;&#125;; if ($require.cache[filename]) &#123; return $require.cache[filename].exports; &#125; //第一次没有缓存 const dirname = path.dirname(filename); let code = fs.readFileSync(filename, "utf8"); //定义一个数据容器，用容器去装模块导出的成员 let module = &#123; id: filename, exports: &#123;&#125; &#125;; let exports = module.exports; code = ` (function($require, module, exports, __dirname, __filename) &#123; $&#123;code&#125; &#125;)($require, module, exports, dirname, filename);`; eval(code); //缓存起来 $require.cache[filename] = module; return module.exports;&#125;setInterval(() =&gt; &#123; const date = $require("./date.js"); console.log(date.getTime());&#125;,1000); 执行 12345$ node 12-\$require-cache.js 150093764976915009376497691500937649769^C 本文结束，感谢阅读。 本文作者：melody0z 本文链接：https://melodyvoid.github.io/Node/modular-structure.html 欢迎转载，转载请注明文本链接]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[路径问题]]></title>
    <url>%2FNode%2Frouting-problem.html</url>
    <content type="text"><![CDATA[目录结构 |— /module ​ |— path.js |— index.js |— a.txt module/path.js 123456789const fs = require("fs");fs.readFile("../a.txt",(err,data) =&gt; &#123; if(err) &#123; console.log(err); &#125;else&#123; console.log(data); &#125;&#125;); index.js 1const foo = require("./module/path"); 然后我们执行index.js 12$ node 04-path.js &#123; Error: ENOENT: no such file or directory, open '../a.txt' errno: -2, code: 'ENOENT', syscall: 'open', path: '../a.txt' &#125; 原因是没有找到。咦？路径没有错啊，path.js上级目录下面的a.txt。 其实原因是这样的。在node执行的时候，是会以入口文件为基准，去找文件。我们的入口文件是index.js。那么a.txt是和它平级，在module/path.js中写成./a.txt就可以了，我们试一下。 12345678910 const fs = require("fs"); - fs.readFile("../a.txt",(err,data) =&gt; &#123;+ fs.readFile("./a.txt",(err,data) =&gt; &#123; if(err) &#123; console.log(err); &#125;else&#123; console.log(data); &#125; &#125;); 在执行一下index.js 12$ node index.js &lt;Buffer 53 75 6e 20 4a 75 6c 20 32 33 20 32 30 31 37 20 32 31 3a 30 34 3a 31 38 20 47 4d 54 2b 30 38 30 30 20 28 43 53 54 29&gt; 可以读出来了，但是是buffer，我们需要toString一下 12345678910 const fs = require("fs"); fs.readFile("./a.txt",(err,data) =&gt; &#123; if(err) &#123; console.log(err); &#125;else&#123;- console.log(data);+ console.log(data.toString()); &#125; &#125;); 再执行一下index.js 12$ node index.js Sun Jul 23 2017 21:04:18 GMT+0800 (CST) 我们成功了！but，有一个问题，我们试着想一下，我们在阅读module/path.js的代码时，看到./a.txt会误以为在module文件夹下有a.txt(实际上没有)。所以我们要引出下面的东西 __dirname 获取当前脚本所在路径 __filename 获取文件路径 module/path.js 1234567891011121314+ //获取当前脚本所在路径+ console.log(__dirname);+ //获取文件路径+ console.log(__filename); const fs = require("fs"); fs.readFile("./a.txt",(err,data) =&gt; &#123; if(err) &#123; console.log(err); &#125;else&#123; console.log(data.toString()); &#125; &#125;); 执行index.js 1234$ node index.js /Users/melody0z/github/nodejs/second/module/Users/melody0z/github/nodejs/second/module/path.jsSun Jul 23 2017 21:04:18 GMT+0800 (CST) 我们发现上面的两个东西可以获取绝对路径 所以我们在文件操作的时候路径都必须是绝对路径（物理路径） 123456789 const fs = require("fs");- fs.readFile("./a.txt",(err,data) =&gt; &#123;+ fs.readFile(__dirname + "/../a.txt",(err,data) =&gt; &#123; if(err) &#123; console.log(err); &#125;else&#123; console.log(data.toString()); &#125; &#125;); 这样看起来是不是舒服多了 注意点： __dirname可以获取当前文件所在目录的完整路径；在模块全局环境有效，但在REPL环境无效 __filename可以用来获取当前文件的完整路径；在模块全局环境有效，但在REPL环境无效 本文结束，感谢阅读。 本文作者：melody0z 本文链接：https://melodyvoid.github.io/Node/routing-problem.html 欢迎转载，转载请注明文本链接]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[拖拽组件的开发]]></title>
    <url>%2FJavaScript%2Fdevelopment-of-drag-and-drop-components.html</url>
    <content type="text"><![CDATA[先要搞懂配置参数和默认参数 有配置参数，走配置参数，没有配置参数走默认参数。（前提是属性的名字必须一样，这样配置参数才会覆盖默认参数） 先来看一个例子 12345678910111213var a = &#123; //配置参数 name:"Jack"&#125;;var b = &#123; //默认参数 name: "Mary"&#125;;extend(b,a);console.log(b.name); //"Jack" 如果有配置参数，就走配置参数function extend(obj1,obj2)&#123; for(var attr in obj2)&#123; obj1[attr] = obj2[attr]; &#125;&#125; 12345678910111213var a = &#123; //配置参数 //name:"Jack"&#125;;var b = &#123; //默认参数 name: "Mary"&#125;;extend(b,a);console.log(b.name); //"Mary" 如果没有配置参数，就走默认参数function extend(obj1,obj2)&#123; for(var attr in obj2)&#123; obj1[attr] = obj2[attr]; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687//组件开发:多组对象,像兄弟之间的关系(代码复用)window.onload = function () &#123; var d1 = new Drag(); d1.init(&#123; //配置参数 id:"div1" &#125;); var d2 = new Drag(); d2.init(&#123; id:"div2", toDown: function () &#123; document.getElementById("div2").style.backgroundColor = "yellow" &#125; &#125;); var d3 = new Drag(); d3.init(&#123; id:"div3", toDown: function () &#123; document.getElementById("div3").style.backgroundColor = "yellowgreen" &#125;, toUp : function () &#123; document.getElementById("div3").style.backgroundColor = "purple" &#125; &#125;); var d4 = new Drag(); d4.init(&#123; id:"div4", toUp: function () &#123; alert("byebye") &#125; &#125;)&#125;;function Drag()&#123; this.obj = null; this.deltaX = 0; this.deltaY = 0; //默认参数 this.settings = &#123; toDown : function ()&#123;&#125;, toUp : function () &#123;&#125; &#125;&#125;Drag.prototype.init = function (opt) &#123; var This = this; this.obj = document.getElementById(opt.id); extend(this.settings,opt); //重要语句 this.obj.onmousedown = function (ev) &#123; var ev = ev || window.event; This.fnDown(ev); This.settings.toDown(); document.onmousemove = function (ev) &#123; var ev = ev || window.event; This.fnMove(ev); return false; &#125;; document.onmouseup = function () &#123; This.fnUp(); This.settings.toUp(); &#125;; return false; &#125;&#125;;Drag.prototype.fnDown = function (ev) &#123; this.deltaX = ev.clientX - this.obj.offsetLeft; this.deltaY = ev.clientY - this.obj.offsetTop;&#125;;Drag.prototype.fnMove = function (ev) &#123; var l = ev.clientX - this.deltaX; var t = ev.clientY - this.deltaY; this.obj.style.left = l + "px"; this.obj.style.top = t + "px";&#125;;Drag.prototype.fnUp = function () &#123; document.onmousemove = null; document.onmouseup = null;&#125;;function extend(obj1,obj2)&#123; for(var attr in obj2)&#123; obj1[attr] = obj2[attr]; &#125;&#125; 本文结束，感谢阅读。 本文作者：melody0z 本文链接：https://melodyvoid/JavaScript/development-of-drag-and-drop-components.html 欢迎转载，转载请注明文本链接]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[验证node单线程]]></title>
    <url>%2FNode%2Fverify-node-single-thread.html</url>
    <content type="text"><![CDATA[现象我们由一段代码入手(文件名：02.js); 123456789101112131415const http = require("http");let count = 0;const server = http.createServer((req,res) =&gt; &#123; res.writeHead(200,&#123;"Content-Type":"text/html;charset=UTF-8"&#125;); res.write(`你是第$&#123;count++&#125;个访问用户`); res.end();&#125;);server.listen(3000,(err) =&gt; &#123; //出现错误的情况就是端口被占用 if(err) throw err; console.log("server is running at http://localhost:3000/")&#125;); 然后我们执行它 12$ node 02.js server is running at http://localhost:3000/ 打开浏览器 我们能看到“你是第0个访问用户”，当我们刷新的时候，我们发现… 问题1：count并没有重新归零 问题2：count直接由0变到了2 我们来看下问题1，count并没有重新归零，说明我们在刷新页面的时候并不是重新执行了整个脚本，而是只执行了server里的代码 12345const server = http.createServer((req,res) =&gt; &#123; res.writeHead(200,&#123;"Content-Type":"text/html;charset=UTF-8"&#125;); res.write(`你是第$&#123;count++&#125;个访问用户`); res.end();&#125;); 所以count不会重新归零，而是执行里面的count++，但是…应该由0变为1啊。 好了，我们来看第二个问题，为什么直接从0变为2，我们打开调试工具 我们发现，刷新页面的时候会发送两个请求，一个是localhost，一个是favicon.ico，所以 1res.write(`你是第$&#123;count++&#125;个访问用户`); 会执行两次，然后我们就会看见0，2，4，6… 解决办法 做一个判断 if(req.url === &quot;/favicon.ico&quot;) return; 12345678910111213141516const http = require("http");let count = 0;const server = http.createServer((req,res) =&gt; &#123; if(req.url === "/favicon.ico") return; //如果请求的是favicon.ico我们就return掉 res.writeHead(200,&#123;"Content-Type":"text/html;charset=UTF-8"&#125;); res.write(`你是第$&#123;count++&#125;个访问用户`); res.end();&#125;);server.listen(3000,(err) =&gt; &#123; //出现错误的情况就是端口被占用 if(err) throw err; console.log("server is running at http://localhost:3000/")&#125;); 单线程我们再把代码修改一下 1234567891011121314151617181920 const http = require("http"); let count = 0; const server = http.createServer((req,res) =&gt; &#123; if(req.url === "/favicon.ico") return; res.writeHead(200,&#123;"Content-Type":"text/html;charset=UTF-8"&#125;); res.write(`你是第$&#123;count++&#125;个访问用户`);+ //如果count计数到5的话，我们就让它阻塞+ if(count === 5)&#123;+ while(true) &#123; &#125;+ &#125; res.end(); &#125;); server.listen(3000,(err) =&gt; &#123; //出现错误的情况就是端口被占用 if(err) throw err; console.log("server is running at http://localhost:3000/") &#125;); 我们再来执行它，然后刷新刷新，count计数到5的时候就会阻塞，我们看 这是，我们重新开一个页面，输入http://localhost:3000 我们发现新开的页面也是阻塞的，为什么呢？就是因为node是单线程，一个地方阻塞了，就都阻塞了。 本文结束，感谢阅读。 本文作者：melody0z 本文链接：https://melodyvoid.github.io/Node/verify-node-single-thread.html 欢迎转载，转载请注明文本链接]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0723]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0723.html</url>
    <content type="text"><![CDATA[必备句型​ Oh,boy! 天哪 I think I have a crush on her. 我觉得我是喜欢上她了 ​ 场景对话​ A: Oh,boy! Look at the girl over there, she’s gorgeous. B: Hey,are you okay? A: I think I have a cruse on her. B: Excuse me? A: I guess that’s love at first sight. ​ 参考译文​ A: 天哪！快看那边的那个女孩，太漂亮了。 B: 嗯，你还好吧？ A: 我觉得我是喜欢上她了。 B: 什么？ A: 我想这就是一见钟情吧。 ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组去重]]></title>
    <url>%2FJavaScript%2Faray-weighting.html</url>
    <content type="text"><![CDATA[1.遍历数组法最简单的去重方法，实现思路：新建一新数组，遍历传入数组，值不在新数组就加入该新数组中；注意点：判断值是否在数组的方法“indexOf”是ECMAScript5 方法，IE8以下不支持，需多写一些兼容低版本浏览器代码，源码如下： 123456789function unique1(arr)&#123; var newArr = []; for(var i=0;i&lt;arr.length;i++)&#123; if(newArr.indexOf(arr[i]) == -1)&#123; newArr.push(arr[i]); &#125; &#125; return newArr;&#125; 2.对象键值对法该方法执行的速度比其他任何方法都快， 就是占用的内存大一些，实现思路：新建一js对象以及新数组，遍历传入数组时，判断值是否为js对象的键，不是的话给对象新增该键并放入新数组。注意 点： 判断是否为js对象键时，会自动对传入的键执行“toString()”，不同的键可能会被误认为一样；例如： a[1]、a[“1”] 。解决上述问题还是得调用“indexOf”。 12345678910111213141516function unique2(arr)&#123; var obj = &#123;&#125;; var newArr = []; for(var i=0;i&lt;arr.length;i++)&#123; var cur = arr[i]; var type = typeof arr[i]; if(obj[cur] == undefined)&#123; obj[cur] = [type]; newArr.push(arr[i]); &#125;else if(obj[cur].indexOf(type) == -1)&#123; obj[cur].push(type); newArr.push(arr[i]); &#125; &#125; return newArr;&#125; 3.数组下标判断法还是得调用“indexOf”性能跟方法1差不多，实现思路：如果当前数组的第i项在当前数组中第一次出现的位置不是i，那么表示第i项是重复的，忽略掉。否则存入结果数组。 123456789function unique3(arr)&#123; var newArr = [arr[0]]; for(var i=1;i&lt;arr.length;i++)&#123; if(arr.indexOf(arr[i]) == i)&#123; newArr.push(arr[i]); &#125; &#125; return newArr;&#125; 4.排序后相邻去除法 虽然原生数组的”sort”方法排序结果不怎么靠谱，但在不注重顺序的去重里该缺点毫无影响。实现思路：给传入数组排序，排序后相同值相邻，然后遍历时新数组只加入不与前一值重复的值。 123456789101112131415function unique4(arr)&#123; arr.sort(); var newArr = [arr[0]]; for(var i=1;i&lt;arr.length;i++)&#123; if(arr[i] !== arr[length - 1])&#123; newArr.push(arr[i]); &#125; &#125; return newArr;&#125;//这种方法有漏洞var arr = [1, 4, 6, 6, "2", 2, "2"];console.log(unique4(arr)); //[1, "2", 2, "2", 4, 6]为什么会这样呢？因为arr.sort();的结果是[1, "2", 2, "2", 4, 6, 6]排序不会区分字符串和数字 5.优化遍历数组法该方法的实现代码相当酷炫，实现思路：获取没重复的最右一值放入新数组。（检测到有重复值时终止当前循环同时进入顶层循环的下一轮判断）推荐 12345678910// 思路：获取没重复的最右一值放入新数组 function unique5(arr)&#123; var newArr = []; for(var i = 0; i &lt; arr.length; i++) &#123; for(var j = i + 1; j &lt; arr.length; j++) if (arr[i] === arr[j]) j = ++i; newArr.push(arr[i]); &#125; return newArr; &#125; 判断浏览器是否支持indexOf ，indexOf 为ecmaScript5新方法 IE8以下（包括IE8， IE8只支持部分ecma5）不支持 1234567891011121314151617if (!Array.prototype.indexOf) &#123; // 新增indexOf方法 Array.prototype.indexOf = function (item) &#123; var result = -1, a_item = null; if (this.length == 0) &#123; return result; &#125; for (var i = 0, len = this.length; i &lt; len; i++) &#123; a_item = this[i]; if (a_item === item) &#123; result = i; break; &#125; &#125; return result; &#125;&#125; 本文结束，感谢阅读。 本文作者：melody0z 本文链接：https://melodyvoid/JavaScript/aray-weighting.html 欢迎转载，转载请注明文本链接]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node事件驱动模型]]></title>
    <url>%2FNode%2Fnode-event-driven-model.html</url>
    <content type="text"><![CDATA[Event driven（事件驱动）Node采用的是事件驱动的方式，通过事件驱动的方式处理请求时无需为每一个请求创建额外的线程。在事件驱动模型中，每一个I/O操作都会被添加到事件队列中，主线程循环地处理队列上的工作任务，当执行过程中遇到阻塞（读取文件、查询数据库）时，线程不会停下来等待结果，而是留下一个处理结果的回调函数，转而继续执行队列中的下一个任务。这个传递到队列中的回调函数在阻塞任务运行结束后才被线程调用。 主线程的代码执行完毕就会从事件队列中读取事件，如果有就取出事件并执行相关的回调函数。事件队列事件全部执行完毕，node应用就会终止。Node对于阻塞I/O的处理在幕后使用线程池来确保工作的执行。Node从线程池中取得一个线程来执行复杂任务，而不占用主循环线程。这样就防止阻塞I/O占用空闲资源。当阻塞任务执行完毕通过添加到事件队列中的回调函数来处理接下来的工作。 Node基于事件的工作调度能很自然地将主要的调度工作限制到了一个线程，应用能很高效地处理多任务。程序每一时刻也只需管理一个工作中的任务。当必须处理阻塞I/O时，通过将这个部分的I/O控制权交给线程池中的线程，能最小地影响到应用处理事件，快速地反应web请求。 123456789101112131415161718192021222324252627const fs = require("fs");console.time("timer");//判断是否存在a.txt文件fs.stat("./a.txt",(err,stats) =&gt; &#123; if(err)&#123; console.log("文件不存在"); //不存在的话，我们就创建 fs.writeFile("./a.txt",new Date(),(err) =&gt; &#123; if(err) throw err; console.log("文件创建成功") &#125;) &#125;else &#123; //如果存在的话，先删除 fs.unlink("./a.txt",(err) =&gt; &#123; if(err) throw err; //创建 fs.writeFile("./a.txt",new Date(),(err) =&gt; &#123; if(err) throw err; console.log("文件删除后创建成功"); &#125;) &#125;) &#125;&#125;);console.timeEnd("timer"); 1234567$ node 01-event-driven.js timer: 0.444ms文件不存在文件创建成功$ node 01-event-driven.js timer: 0.427ms文件删除后创建成功 我们来看一下具体过程 本文结束，感谢阅读。 本文作者：melody0z 本文链接：https://melodyvoid.github.io/Node/node-learning-notes-01.html 欢迎转载，转载请注明文本链接]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>事件驱动模型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0722]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-072.html</url>
    <content type="text"><![CDATA[必备句型​ Let’s have a get-together tonight. 我们今晚聚会吧 How about a rain check? 换个时间行吗？ ​ 场景对话​ A: Let’s have a get-together tonight.Would you come? B: I’d love to, but I have a class at that time and I have to finish my homework.How about a rain check? ​ 参考译文​ A: 我们今晚聚会吧，你能来吗？ B: 我很想啊，但是今晚有课，还有作业要完成，换个时间行吗？ ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象常用的一些属性和方法]]></title>
    <url>%2FJavaScript%2Fsome-atributes-and-methods-comonly-used-in-object-oriented.html</url>
    <content type="text"><![CDATA[hasOwnProperty():看是不是对象自身（自己有别人没有）下面的属性。hasOwnProperty() 12345var arr = [];arr.num = 10;Array.prototype.num2 = 20;console.log(arr.hasOwnProperty("num")); //true 说明num属性只属于arr对象，其他对对象没有console.log(arr.hasOwnProperty("num2")); //false 说明num2属性不是arr独享的 constructor：查看对象的构造函数 每个原型都会自动添加constructor属性 for in 的时候有些属性是找到不到的 避免修改constructor属性 123456789101112function A ()&#123; &#125;var a = new A();console.log(a.constructor); //结果是：function A()&#123;&#125;var arr = [];console.log(arr.constructor); //Array 我们可以利用这个属性来做判断 123var arr = [];//判断arr是不是数组console.log(arr.constructor == Array); //true 再来看 12345function A()&#123; &#125;//当我们执行上一句时，程序会为我们自动添加A.prototype.constructor = A; //这个是隐式的 我们来做个试验 1234567function A()&#123; &#125;//我们手动来写一下A.prototype.constructor = Array; //相当于覆盖了隐式的var a = new A();console.log(a.constructor); //Array 123456function A()&#123; &#125;var a = new A();//顺着原型链往上找，找到了最外层console.log(a.hasOwnProperty == Object.prototype.hasOwnProperty); //true 注意：A.prototype.constructor = A;是系统自动添加的，我们不要去改它，但是有些情况我们会不自觉地就给改了。 12345678910function A()&#123; &#125;A.prototype.name = "Jack";A.prototype.age = 20;var a = new A();console.log(a.constructor); //结果function A()&#123; &#125; 下面我们将A.prototype.name = &quot;Jack&quot;;A.prototype.age = 20;改写成JSON的形式 1234567891011function A()&#123; &#125;//这样写你感觉好像没有什么问题A.prototype = &#123; name:"Jack", age:20&#125;;var a = new A();//可以看出构造函数已经改变console.log(a.constructor); //function Object() &#123; [native code] &#125; 1234A.prototype = &#123; name:"Jack", age:20&#125;; //这样相当于把A.prototype改写了，那么a再去找构造函数的时候，就会找到json的构造函数，自然就是function Object() &#123; [native code] &#125; 那要怎么办呢？答案就是在使用json的时候，把constructor给修正过来 12345678910function A()&#123; &#125;A.prototype = &#123; constructor:A, name:"Jack", age:20&#125;;var a = new A();console.log(a.constructor); //function A ()&#123;&#125;; 系统自带的属性不能被for in 循环到 12345function A()&#123;&#125;for(var attr in A.prototype)&#123; console.log(attr);&#125;//什么都没有，那好，我们自己写一个试试 123456function A()&#123;&#125;A.prototype.name = "Jack";for(var attr in A.prototype)&#123; console.log(attr);&#125;//结果输出name; 好，我们再写一个 1234567function A()&#123;&#125;A.prototype.name = "Jack";A.prototype.constructor = A;for(var attr in A.prototype)&#123; console.log(attr);&#125;//结果还是只有一个name,说明系统自带属性用for in 遍历不到，即使自己写一遍也不行 instanceof:对象与构造函数在原型链上是否有关系看例子 1234function A()&#123;&#125;var a = new A();console.log(a instanceof A); //trueconsole.log(a instanceof Object); //true toString():系统对象下面都是自带的，自己写的对象都是通过原型链找Object下面的。12var arr = [];console.log(arr.toString); //function toString() &#123; [native code] &#125; 123function A()&#123;&#125;var a = new A();console.log(a.toString); //function toString() &#123; [native code] &#125; 1234//自定义对象function A()&#123;&#125;var a = new A();console.log(a.toString == Object.prototype.toString); //true 123//系统对象var arr = [];console.log(arr.toString == Object.prototype.toString); //false toString():把对象转成字符串 123var arr = [1,2,3];console.log(typeof arr.toString()); //stringconsole.log(arr.toString()); //"1,2,3" 知道原理之后可以自己改写 123456var arr = [1,2,3];//我们知道系统对象的toString方法在自己的包装对象原型里Array.prototype.toString = function()&#123; return this.join("+");&#125;;console.log(arr.toString()); //"1+2+3" 我们还可以用toString()来进行进制的转换 123var num = 255;//转成16进制console.log(num.toString(16)); //"ff" 利用toString()做类型的判断 1234567891011121314var arr = []; var num = 123;var str = "";var obj = &#123;&#125;;var date = new Date();var reg = /^$/;var v = null;console.log(Object.prototype.toString.call(arr)); //[object Array]console.log(Object.prototype.toString.call(num)); //[object Number]console.log(Object.prototype.toString.call(str)); //[object String]console.log(Object.prototype.toString.call(obj)); //[object Object]console.log(Object.prototype.toString.call(date)); //[object Date]console.log(Object.prototype.toString.call(reg)); //[object RegExp]console.log(Object.prototype.toString.call(v)); //[object Null] 小结：如何判断一个对象是不是数组？1234var arr = [];console.log(arr.constructor == Array); //trueconsole.log(arr instanceof Array); //trueconsole.log(Object.prototype.toString.call(arr) == "[object Array]"); //true 扩展：写一个函数，获得函数名 1234function getFnName(fn)&#123; if(typeof fn != "function") return; return fn.name || /function (.+)\(/.exec(fn+"")[1];&#125; 简化一下 123456function getFnName(fn)&#123; return typeof fn !== "function"? undefined: fn.name || /function (.+)\(/.exec(fn)[1];&#125; 12345function Person()&#123; this.name = "Jack"&#125;var p = new Person();console.log(getFnName(p.constructor)); //Person 本文结束，感谢阅读。 本文作者：melody0z 本文链接：https://melodyvoid/JavaScript/some-atributes-and-methods-comonly-used-in-object-oriented.html 欢迎转载，转载请注明文本链接]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[框架设计]]></title>
    <url>%2FJavaScript%2Fframework-design.html</url>
    <content type="text"><![CDATA[思路： 选择引擎 DOM操作模块（增删） 事件模块click，on，… 属性模块attr,text,html,val… 样式模块css,hasClass… 动画模块 整合 做个小例子：页面有一堆div和p，给它们加上背景色 12345678var aDiv = document.getElementsByTagName("div");var aP = document.getElementsByTagName("p");for(var i = 0;i&lt;aDiv.length;i++)&#123; aDiv[i].style.backgroundColor = "red";&#125;for(var i = 0;i&lt;aP.length;i++)&#123; aP[i].style.backgroundColor = "red";&#125; 这么做有什么不好的地方？ 代码冗余 丑 无法复用 容错 效率 性能 函数化所以我们考虑给它函数化 123456789101112var g = function(tag)&#123; return document.getElementsByTagName(tag);&#125;;var aDiv = g("div");var aP = g("p");var each = function(arr)&#123; for(var i=0;i&lt;arr.length;i++)&#123; arr[i].style.backgroundColor = "red"; &#125;&#125;;each(aDiv);each(aP); 显然each这个函数写的太死 我们思考一下：如果你想要遍历一个数组，要对数组做什么事情？ 凡是涉及到遍历才可以完成的事情都应该可以做（修改，查询） 123var arr = [1,2,3,4,5];要求：1.求和 2.求最大值 3.求最小值 4.查找3 5.查找5 12345678910111213141516171819202122232425262728293031323334353637var sum = 0;for(var i=0;i&lt;arr.length;i++)&#123; sum += arr[i];&#125;console.log(sum);var max = arr[0];for(var i=0;i&lt;arr.length;i++)&#123; if(arr[i]&gt;max)&#123; max = arr[i]; &#125;&#125;console.log(max);var min = arr[0];for(var i=0;i&lt;arr.length;i++)&#123; if(arr[i]&lt;min)&#123; min = arr[i]; &#125;&#125;console.log(min);var find1 = -1;for(var i=0;i&lt;arr.length;i++)&#123; if(arr[i] == 3)&#123; find1 = i; break; &#125;&#125;var find2 = -1;for(var i=0;i&lt;arr.length;i++)&#123; if(arr[i] == 5)&#123; find2 = i; break; &#125;&#125; 发现我们可以发现，遍历操作有一个特点：所有都需要循环，就是循化体不同。 那么我们来优化一下each 123456function each(arr,string)&#123; for(var i=0;i&lt;arr.length;i++)&#123; //执行string &#125;&#125;怎么执行string呢？eval()，或者我们传个函数进去 12345function each(arr,fn)&#123; for(var i=0;i&lt;arr.length;i++)&#123; fn(); //注意：这里函数要传参数啊，要不然怎么能读到arr[i]呢？ &#125;&#125; 12345function each(arr,fn)&#123; for(var i=0;i&lt;arr.length;i++)&#123; fn(arr[i]); &#125;&#125; //第一次优化 我们来求个和试试 1234var sum = 0;each(arr,function(v)&#123; sum += v;&#125;) 再来求个最大值试试 123456var max = arr[0];each(arr,function(v)&#123; if(v&gt;max)&#123; max = v; &#125;&#125;); 是不是完美了呢？不，如果我们求下标为偶数的和呢？没办法了吧，所以我们还需要把下标i传进去。 12345function each(arr,fn)&#123; for(var i=0;i&lt;arr.length;i++)&#123; fn(i,arr[i]); &#125;&#125; //第二次优化 1234567var arr = [1,2,3,4,5];var sum = 0;each(arr, function (i, v) &#123; if (i % 2) return; //如果下标是奇数,就跳过 sum += v;&#125;);console.log(sum); //9 完美了吗？不，如果要查找怎么办呢？没有break，那么会循环整个数组，性能低，并且，如果有相同的，后面的会把前面的覆盖掉。 12345678910111213function each(arr,fn)&#123; for(var i=0;i&lt;arr.length;i++)&#123; if( fn(i,arr[i]) === false) break; //第三次优化 &#125;&#125; var index = -1;each(arr,function(i,v)&#123; if(v == 3)&#123; index = i; return false; &#125;&#125;);console.log(index); 我们还不满足 12345678function each(arr,fn)&#123; for(var i=0;i&lt;arr.length;i++)&#123; if( fn(i,arr[i]) === false) break; //第三次优化 &#125;&#125;each(arr,function(i,v)&#123; console.log(this); //window，我们的期望是this指向arr[i]&#125;) 可以这么做 12345678function each(arr,fn)&#123; for(var i=0;i&lt;arr.length;i++)&#123; if( fn.call(arr[i],i,arr[i]) === false) break; //第四次优化 &#125;&#125;each(arr,function(i,v)&#123; console.log(this); //Number &#123;[[PrimitiveValue]]: 1&#125;...(打印四次)&#125;) 好了，我们再来写前面的例子 12345678910111213141516function getByTag (tag)&#123; return document.getElementsByTagName(tag);&#125;function each(arr,fn)&#123; for(var i=0;i&lt;arr.length;i++)&#123; if( fn.call(arr[i],i,arr[i]) === false) break; &#125;&#125;var aDiv = getByTag("div");var aP = getByTag("p");each(aDiv,function()&#123; this.style.backgroundColor = "red";&#125;);each(aP,function()&#123; this.style.backgroundColor = "red";&#125;) 本文结束，感谢阅读。 本文作者：melody0z 本文链接：https://melodyvoid/JavaScript/framework-design.html 欢迎转载，转载请注明文本链接]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>框架设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0721]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0721.html</url>
    <content type="text"><![CDATA[必备句型​ She had a quarrel with Tom. 她跟Tom吵架了 The course of true love never did run smoothly. 爱情路上多波折 ​ 场景对话​ A: Zoe is so upset. B: Yes, but I don’t know what’s going on with her. A: She had a quarrel with Tom. B: People say “The course of true love never did run smoothly”. ​ 参考译文​ A: Zoe心情不是很好。 B: 是的，不知道她怎么了。 A: 她跟Tom吵架了。 B: 人们说：“爱情路上多波折”。 ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node学习笔记01]]></title>
    <url>%2FNode%2Fnode-learning-notes-01.html</url>
    <content type="text"><![CDATA[Node简介什么是Node Node 就是 JavaScript 语言在服务器端的运行环境 所谓“运行环境（平台）”有两层意思： 首先，JavaScript 语言通过 Node 在服务器运行，在这个意义上，Node 有点像 JavaScript 虚拟机； 其次，Node 提供大量工具库，使得 JavaScript 语言与操作系统互动（比如读写文件、新建子进程），在这个意义上， Node 又是 JavaScript 的工具库。 重点理解 Node是一个JavaScript的运行环境（平台），不是一门语言，也不是JavaScript的框架； Node的实现结构； Node可以用来开发服务端应用程序，Web系统； 基于Node的前端工具集 Node.js的特点 Node.js® is a JavaScript runtime built on Chrome’s V8 JavaScript engine. Node.js uses an event-driven, non-blocking I/O model that makes it lightweight and efficient. Node.js’ package ecosystem, npm, is the largest ecosystem of open source libraries in the world. 单线程 事件驱动（event-driven) 非阻塞I/O（non-blocking I/O) Node命令的基本用法进入REPL(Read Eval Print Loop:交互解释器) Read：读取用户输入，解析输入了JavaScript数据结构并存储在内存中。 Eval：执行输入的数据结构 Print：输出结果 Loop：循环操作以上步骤直到用户退出 12$ node&gt; 简单的表达式运算 123$ node&gt; 2 + 46 使用变量 12345678910$ node&gt; x = 1010&gt; var y = 20undefined&gt; x + y30&gt; console.log("Hello World")Hello Worldundefined 多行表达式 123456789&gt; for(let i = 0;i &lt; 5;i++)&#123;... console.log("i:" + i);... &#125;i:0i:1i:2i:3i:4undefined ...三个点的符号是系统自动生成的，回车换行后即可，Node会自动检测是否为连续的表达式。 下划线变量 1234567891011&gt; let a = 10undefined&gt; let b = 10undefined&gt; a + b20&gt; let sum = _undefined&gt; console.log(sum)20undefined REPL命令 ctrl + c 退出当前终端 ctrl + c 按下两次 退出Node REPL .exit 退出Node REPL process.exit() 退出REPL ctrl + d 退出Node REPL up/down键 查看输入的历史命令 tab键 列出当前命令 .help 列出使用命令 .break 退出多行表达式 .clear 退出多行表达式 .save filename 保存当前的Node REPL会话到指定文件 .load filename 载入当前Node REPL会话的文件内容 执行脚本字符串1$ node -e "console.log('Hello World')" 执行脚本文件123$ node index.js$ node path/index.js$ node path/index 查看帮助1$ node --help 全局作用域成员全局对象 global： 类似于客户端JavaScript运行环境中的window process：用于获取当前的Node进程信息，一般用于获取变量之类的信息 console：Node中内置的console模块，提供操作控制台的输入输出功能，常见使用方法与客户端类似。 全局函数 setInterval(callback,millisecond) clearInterval(timer) setTimeout(callback,millisecond) clearTimeout(timer) Buffer:Class 用于操作二进制数据 异步编程异步操作 Node采用Chrome V8引擎处理JavaScript脚本，V8最大特点就是单线程运行，一次只能运行一个任务。 Node大量采用异步操作(asynchonous operation),即任务不是马上执行，而而是插在任务队列的尾部，等到前面的任务运行完后再执行。 提高代码的响应能力 回调函数的设计 对于一个函数如果需要定义回调函数： 回调函数一定作为参数的最后一个参数出现： 12function foo (name,age,callback) &#123;&#125;function bar (value,callback1,callback2)&#123;&#125; 回调函数的第一个参数默认接收错误信息，第二个参数采食真正的回调数据（便于外界获取调用的错误情况）： 1234foo("Jack",18,(error,data) =&gt; &#123; if(error) throw error; console.log(data);&#125;) Node统一约定：强调错误优先 因为之后的操作大多数都是异步的方式，无法通过try…catch捕获异常。 错误优先的回调函数，第一个参数为上一步的错误信息。 什么是异步比如说：setTimeout()、$.ajax() 异步操作回调 由于系统永远不知道用户什么时候会输入内容，所以代码不能永远停在一个地方 Node中的操作方式就是以异步回调的方式解决无状态的问题。 异步回调的问题callback hell 123456789foo1(function()&#123; foo2(function()&#123; foo3(function()&#123; foo4(function()&#123; foo5() &#125;) &#125;) &#125;)&#125;) 相比较与传统的代码： 异步事件驱动的代码不容易阅读 不容易调试 不容易维护 非阻塞I/O什么是I/O I/O：input/output 可以理解为输入到输出之间的转化过程 敲击键盘（输入）看到编辑器中多出字符（输出） 移动鼠标（输入）看到光标移动（输出） 事件驱动和非阻塞机制 Node平台将一个任务连同该任务的回调函数放到一个事件循环系统中 事件循环高效地管理系统线程池同时高效执行每一个任务 当任务执行完成过后自动执行回调函数 Node中的异步I/O 非阻塞的优势 提高代码的响应效率 充分利用单核CPU的优势 改善I/O的不可预测带来的问题 进程与线程什么是进程 每一个正在运行的应用程序都称之为进程 每一个应用程序至少有一个进程 进程是用来给应用程序提供一个运行的环境 进程是操作系统为应用程序分配资源的一个单位 什么是线程 用来执行应用程序中的代码 在一个进程内部，可以有很多线程 在一个线程内部，同时只可以干一件事 而且传统的开发方式大部分是I/O阻塞的 所以需要多线程来更好地利用硬件资源 给人带来的一种错觉：线程越多越好 本文结束，感谢阅读。 本文作者：melody0z 本文链接：https://melodyvoid.github.io/Node/node-learning-notes-01.html 欢迎转载，转载请注明文本链接]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0720]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0720.html</url>
    <content type="text"><![CDATA[必备句型​ I’ve been worried sick about you. 我担心死你了 I am totally fine. 我很好啊 ​ 场景对话​ A: I’ve been worried sick about you, where have you been? B: I am totally fine,I just went shopping with my friends. A: Well, at least you should’ve told me. B: Mom,please. I am not a kid anymore. ​ 参考译文​ A: 我担心死你了，你去哪里了？ B: 我没事啊，跟朋友出去购物了。 A: 嗯，你至少应该告诉我啊。 B: 拜托了，妈，我又不是小孩子。 ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[继承的几种形式]]></title>
    <url>%2FJavaScript%2Fseveral-forms-of-sucesion.html</url>
    <content type="text"><![CDATA[简单原型链继承1234567function Super()&#123; this.name = "Jack";&#125;function Sub()&#123; //...&#125;Sub.prototype = new Super(); //核心 缺点：修改sub1.name后sub2.name也变了，因为来自原型对象的引用属性是所有实例共享的。Sub.prototype.constructor变成了Super 借用构造函数式继承12345678910function Super(val)&#123; this.val = val; this.fun = function()&#123; //实例函数 //... &#125;&#125;function Sub(val)&#123; Super.call(this,val); //核心 //...&#125; 缺点：无法实现函数复用，每个子类实例都持有一个新的fun函数，太多了就会影响性能，内存爆炸。。 组合式继承（原型+借用构造函数）123456789101112function Super(val)&#123; this.val = val;&#125;//原型函数Super.prototype.fun1 = function()&#123;&#125;;Super.prototype.fun2 = function()&#123;&#125;;//Super.prototype.fun3...function Sub(val)&#123; Super.call(this,val); //核心 //...&#125;Sub.prototype = new Super(); //核心 缺点：子类原型上有一份多余的父类实例属性，因为父类构造函数被调用了两次，生成了两份，而子类实例上的那一份屏蔽了子类原型上父类的。。。又是内存浪费。 原型式继承基本想法：借助原型可以基于已有的对象创建新对象，同时还不必须因此创建自定义的类型。 12345function createObj(obj)&#123; function F()&#123;&#125; F.prototype = obj; return new F();&#125; 5、寄生式继承 基本思想：创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后再像真正是它做了所有工作一样返回对象。 12345678910111213141516171819202122function Super()&#123; this.val = 1; this.arr = [1];&#125;function create(obj)&#123; var F = function()&#123;&#125;; F.prototype = obj; return new F();&#125;function getSubObject(obj)&#123; //创建新对象 var clone = create(obj); //核心 //增强 clone.attr1 = 1; clone.attr2 = 2; //clone.attr3... return clone;&#125;var sub = getSubObject(new Super());alert(sub.val); //1alert(sub.arr); //1alert(sub.attr1); //1 给原型式继承穿了个马甲而已，看起来更像继承了（上面介绍的原型式继承更像是对象复制） 注意：create函数并不是必须的，换言之，创建新对象 -&gt; 增强 -&gt; 返回该对象，这样的过程叫寄生式继承，新对象是如何创建的并不重要（用create生的，new出来的，字面量现做的。。都可以） 优点： 还是不需要创建自定义类型 缺点： 无法实现函数复用（没用到原型，当然不行） 寄生组合式继承123456789101112131415161718function Super(val)&#123; this.val = val;&#125;Super.prototype.fun1 = function()&#123;&#125;;Super.prototype.fun2 = function()&#123;&#125;;//Super.prototype.fun3...function Sub(val)&#123; Super.call(this,val); //核心 //...&#125;Sub.prototype = Object.create(Super.prototype); //核心Sub.prototype.constructor = Sub; //核心或者：function F()&#123;&#125;Super.prototype = F.prototype;Sub.prototype = new F();Sub.prototype.constructor = Sub; es6的class继承方式12345678class A&#123; &#125;class B extends A&#123; &#125;B.__proto__ === A; //trueB.prototype.__proto__ === A.prototype; //true; es6引入了class、extends、super、static(部分为ES2016标准) 本文结束，感谢阅读。 本文作者：melody0z 本文链接：https://melodyvoid/JavaScript/several-forms-of-sucesion.html 欢迎转载，转载请注明文本链接]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[包装对象]]></title>
    <url>%2FJavaScript%2Fpackage-object.html</url>
    <content type="text"><![CDATA[什么是包装对象？JavaScript中只要引用了字符串（数字、布尔值也是一样的）的属性，JS就会将字符串通过调用new String(s)的方式转换成对象，这个对象继承了字符串的方法，并被用来处理属性的引用。一旦属性引用结束，这个新创建的对象就会销毁（真实实现并不一定是这样，但整个过程看起来是这样）。这个过程就叫包装对象。 我们来看段代码： 123var str = "hello";console.log(typeof str); //stringconsole.log(str.charAt(0)); //h 以上代码平淡无奇，但是我们仔细想一下，str是字符串，字符串类型的变量怎么会有方法呢？同理像number和boolean也一样，为什么基本类型的变量会有方法呢？ 原因就是包装对象，这是我们再阅读一下什么是包装对象。 1234567var str1 = new String("hello");console.log(typeof str1); //object//因为str1是object所以有方法很正常str1.charAt(0);//charAt是怎么来的呢？String.prototype.String = function()&#123;...&#125;; //当然我们如果这么写了会覆盖原生的charAt方法，这里只演示原理。console.log(str1.charAt(0)); //h 我们发现：基本类型（string、number、boolean)z这三个有对应的包装对象。null和undefined也是基本类型，但是没有对应的包装对象。 我们回过头来再看上面第一个例子： 1234var str = "hello"; //这里确实是字符串console.log(typeof str); //stringstr.charAt(0); //当字符串调用方法的时候，基本类型会找到对应的包装对象类型，然后包装对象把所有的属性和方法给了基本类型。然后包装对象消失。console.log(str.charAt(0)); //h 那么我么想要给字符串添加一个方法怎么办呢？ 1234567var str = "hello";//在原型里面添加String.prototype.lastValue = function()&#123; return this.charAt(this.length-1);&#125;;//这样我们就可以调用我们写的新方法了str.lastValue(); //o 我们再往下看 123var str = "hello";str.number = 10;console.log(str.number); //undefined; 咦？怎么是undefined？ 答案还是因为包装对象。 str是我们隐式地创建的包装对象，在使用完之后就被抛弃了。 str.number=10这时候创建一个包装对象，赋值。 执行到console.log(str.number)这句话的时候，之前的包装对象已经被抛弃，我们打点调用num的时候，又重新创建一个包装对象，所以此时这个包装对象一定没有num属性，故输出undefined。 那么我们一定要输出str.num呢？ 123var str = "hello";String.prototype.number = 10;console.log(str.number); //10 我们再看一个现象 1234var str = "hello";var str1 = new String("hello");console.log(str == str1); //trueconsole.log(str === str1); //false 不严格相等，一个是字符串类型，一个是对象类型，必然不全等 本文结束，感谢阅读。 本文作者：melody0z 本文链接：https://melodyvoid/JavaScript/package-object.html 欢迎转载，转载请注明文本链接]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0719]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0719.html</url>
    <content type="text"><![CDATA[必备句型​ May I speak to Zoe, please? 可以请Zoe接听电话吗？ She’s tied up at the moment. 她现在走不开 ​ 场景对话​ A: May I speak to Zoe, please? B: I’m sorry, she’s tied up at the moment. Would you like to leave a message? A: No, Thank you. I’ll call her later. ​ 参考译文​ A: 可以请Zoe接听电话吗？ B: 抱歉，她现在走不开。你要留个口信吗？ A: 不用了，谢谢。我待会儿再打给她。 ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0718]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0718.html</url>
    <content type="text"><![CDATA[必备句型​ You look restless. 看你一副坐立不安的样子 I’d like to stay and talk longer, but I really do have to run. 我很想再多聊一会儿，不过我真的很赶时间。 ​ 场景对话​ A: You look restless. Do you have to be somewhere, or am I just boring you? B: I’d like to stay and talk longer, but I really do have to run. I have to be at a meeting at around noon. ​ 参考译文​ A: 看你一副坐立不安的样子，是不是还要去别处，或者是我让你觉得无聊了呢？ B: 我很想再多聊一会儿，不过我真的很赶时间，中午时候还要参加一个会议。 ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[创建对象的几种方式的优缺点对比]]></title>
    <url>%2FJavaScript%2Fcontrast-the-advantages-and-disadvantages-of-several-ways-of-creating-objects.html</url>
    <content type="text"><![CDATA[工厂模式1234567891011function createObj(name, gender)&#123; var obj = new Object(); obj.name = name; obj.gender = gender; obj.sayName = function()&#123; alert(this.name); &#125; return obj;&#125;var person = createObj("Jack", "female"); 缺点： 无法无法确定对象的类型（因为都是Object） 创建的多个对象之间没有关联。 构造函数模式123456789function createObj(name, gender)&#123; this.name = name; this.gender = gender; this.sayName = function()&#123; alert(this.name); &#125;&#125;var person = new createObj("Jack", "female"); 缺点： 多个实例重复创建方法，无法共享。 多个实例都有sayName方法，但均不是同一个Function的实例。 原型方法123456789function createObj()&#123;&#125;createObj.prototype.name = "Jack";createObj.prototype.gender = "female";createObj.prototype.sayName = function()&#123; alert(this.name);&#125;var person = new createObj(); 缺点： 无法传入参数，不能初始化属性值。 如果包含引用类型的值时，改变其中一个实例的值，则会在所有实例中体现。 组合式（构造函数+原型方法）推荐使用1234567891011function createObj(name, gender)&#123; this.name = name; this.gender = gender; if(typeof this.sayName != 'function')&#123; createObj.prototype.sayName = function()&#123; alert(this.name); &#125; &#125;&#125;var person = new createObj("Jack", "female"); 说明： if语句中只会调用一次，就是在碰到第一个实例调用方法时会执。此后所有实例都会共享该方法。在动态原型方法下，不能使用对象字面量重写原型。 寄生构造函数寄生构造函数,其实就是工厂模式+构造函数模式,这种模式比较通用,但不能确定对象关系,所以,在可以使用之前所说的模式时,不建议使用此模式 ​ 在什么情况下使用寄生构造函数比较合适呢?假设要创建一个具有额外方法的引用类型,例如直接String.prototype.addstring,可以通过寄生构造的方式来添加. 123456789function myString(string)&#123; var str = new String(string); str.addstring = function () &#123; return this + ",被添加了"; &#125;; return str;&#125;var box = new myString("lee");alert(box.addstring()); 稳妥构造函数在一些安全环境中,比如禁止使用this和new,这里的this是构造函数里不使用this,这里的new是在外部实例化构造函数时不使用new,这种创建方式叫做稳妥构造函数. 123456789function A(name,age)&#123; var obj = new Object(); obj.showName = function () &#123; return name; &#125;; return obj;&#125;var a = A("Jack",18);alert(a.showName()); 本文结束，感谢阅读。 本文作者：melody0z 本文链接：https://melodyvoid.github.io/JavaScript/contrast-the-advantages-and-disadvantages-of-several-ways-of-creating-objects.html 欢迎转载，转载请注明文本链接]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[类数组转数组]]></title>
    <url>%2FJavaScript%2Fclas-aray-to-aray.html</url>
    <content type="text"><![CDATA[什么是类数组ArrayLike?我们举一个比较经典的类数组（最经典的类数组是Arguments，这里暂且不说）。 1var nodeList=document.querySelectorAll(&quot;div&quot;); 这个nodeList就是一个类数组。何以见得？它可以用nodeList[0]取到第一个子元素。但是当我们用console.log(nodeList instanceof Array)返回false也就是说它并不是数组的实例，也就不是数组。 ArrayLike对象的精妙在于它和javascript原生的Array类似，但是它是自由构建的，它来自开发者对javascript对象的扩展，也就是说：对于它的原型（prototype）我们可以自由定义，而不会污染到javascript原生的Array。 类数组转换为数组之后进行操作有什么优势？简而言之：便捷。Array在js里面是非常强大有用的，它有很多方法：shift,unshift,splice,slice,concat,reverse,sort。ECMAscript 2015又新增了一些方法forEach,isArray,indexOf,lastIndexOf,every,some,map,filter,reduce等等。包括那个IT笑话，“对程序员来说push的反义词是pop（^_^）” 说的都是和数组相关的。但是这些强大的方法，类数组是不一定全部支持的。当我们需要进行数组属性操作的时候才发现，啊原来这是个类数组，啊，要是能变成数组多好啊，否则我还得自己写。虽然每一种方法都是可以自己靠基础api实现的，但是每次都做重复的基础工作，多枯燥。学会偷懒有时候能帮助提高效率~~ #转换方式：Array.prototype.slice.call(arrayLike) 首先Array.prototype.slice.call(arrayLike)的结果是将arrayLike对象转换成一个Array对象。所以其后面可以直接调用数组具有的方法。譬如 1Array.prototype.slice.call(arrayLike).forEach(function(element,index)&#123; //可以随意操作每一个element了 &#125;) 解析点1：Array.prototype.slice表示数组的原型中的slice方法。注意这个slice方法返回的是一个Array类型的对象(这句话很多分析的文章没有点破，我就问了凭什么非得是slice啊?原因就在这)。splice行不行呢？Array.prototype.splice.call(arrayLike,0)这种形式也可以。只要返回的是原数组就可以。当然，那种写法更省事一目了然。 解析点2：能调用call的只有方法，所以不能用[].call这种形式，得用[].slice。而call的第一个参数表示真正调用slice的环境变为了arrayLike对象。所以就好像arrayLike也具有了数组的方法。 本文结束，感谢阅读。 本文作者：melody0z 本文链接：https://melodyvoid/JavaScript/clas-aray-to-aray.html 欢迎转载，转载请注明文本链接]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0717]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0717.html</url>
    <content type="text"><![CDATA[必备句型​ I feel dizzy. 我感到晕晕的 Poor thing. 好可怜啊 ​ 场景对话​ A: I feel dizzy. I have a fever of 38℃ B: Poor thing! Go back to bed and get some rest. I’ll make some soup for you. A: That’s sweet of you. ​ 参考译文​ A: 我感到晕晕的，发烧了，38度。 B: 好可怜啊，回床上睡一会儿吧，我给你做点儿汤。 A: 谢谢你。 ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0716]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0716.html</url>
    <content type="text"><![CDATA[必备句型​ It seems that everybody likes her. 好像每个人都很喜欢她 She really turns me off. 她真的使我厌恶 ​ 场景对话​ A: That girl is so pretty, it seems that everybody likes her. B: I don’t really think so. A: How come? B: She’s too chatty, and she really turns me off. ​ 参考译文​ A: 那个女孩真好看，好像每个人都很喜欢她。 B: 我不这么想。 A: 为什么？ B: 她太啰嗦了，真的让我很讨厌。 ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0715]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0715.html</url>
    <content type="text"><![CDATA[必备句型​ I got stuck in traffic. 我遇上堵车了 Don’t beat around the bush. 别拐弯抹角 ​ 场景对话​ A: I’ve been waiting for an hour, where have you been? B: Sorry, I’m late. I got stuck in traffic. A: Okay, tell me exactly what Tom said. Don’t beat around the bush.Get to the point. ​ 参考译文​ A: 我已经等上一个小时了，你去哪里了？ B: 不好意思，遇上堵车了。 A: 好吧，告诉我Tom说什么了。不要拐弯抹角，直接说重点吧。 ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0714]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0714.html</url>
    <content type="text"><![CDATA[必备句型​ Don’t get me wrong. 请不要误会我的意思 You have to admit that he is not very responsible. 你也得承认他不是很负责任 ​ 场景对话​ A: Don’t get me wrong. I think Tom is a very nice person, but you have to admit that he is not very responsible. B: I guess you are right. He’s got a lot of growing up to do. ​ 参考译文​ A: 请不要误会我的意思。我任务Tom是个很好的人，不过你也得承认他不是很负责任。 B: 你说的不错，他要长大还得学习很多东西。 ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0713]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0713.html</url>
    <content type="text"><![CDATA[必备句型​ Got it ? 明白了吗？ Let me explain this one more time. 让我再解释一次 ​ 场景对话​ A: Got it ? B: Sorry, I still don’t understand. A: Okay, let me explain this one more time. I don’t wanna go out because I don’t like hanging out with Tom. B: Alright, I got it. ​ 参考译文​ A: 明白了吗？ B: 不好意思，我还是不理解。 A: 好吧，我再解释一下，wo’bu’xiang我不想出去，因为我不想跟Tom一起出去逛。 B: 好吧，知道了。 ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0712]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0712.html</url>
    <content type="text"><![CDATA[必备句型​ I’ll never forgive myself. 我永远不能原谅我自己 How can I make it up to you. 我要怎样才能补偿 ​ 场景对话​ A: It’s all my fault. I’ll never forgive myself. B: Don’t say that. We wouldn’t have known that. A: How can I make it up to you? B: You can’t have to do that. ​ 参考译文​ A: 都是我的错，我永远不能原谅自己。 B: 别那么说，我们都无法未卜先知。 A: 我要怎样才能补偿你？ B: 不用啦。 ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0711]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-071.html</url>
    <content type="text"><![CDATA[必备句型​ Are you fond of reading? 你喜欢读书吗？ I like to read all kinds of books. 什么书我都喜欢看 ​ 场景对话​ A: Are you fond of reading? B: Yes, I am. Books can enrich your mind. A: Exactly, what kind of books do you like to read most? B: I like to read all kinds of books. ​ 参考译文​ A: 你喜欢读书吗？ B: 喜欢啊，书籍能丰富你的思想。 A: 确实，你最喜欢读哪种书？ B: 什么书我都喜欢看。 ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0710]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0710.html</url>
    <content type="text"><![CDATA[必备句型​ I dreamed to be a pliot, but I didn’t make it come true. 我曾梦想做一名飞行员，不过我没有实现儿时的梦想 I’m trying my best to learn English. 现在我努力学英文 ​ 场景对话​ A: Hey, did you have a dream when you were a little boy ? B: Of course I did. I dreamed to be a pliot, but I didn’t make it come true. A: Okay, so. How about now? B: Now I’m trying my best to learn English, and I want to be an interpreter some day. ​ 参考译文​ A: 嘿，你小的时候有过什么梦想吗？ B: 当然有啦，我曾梦想过当一名飞行员，不过我没有实现儿时的梦想。 A: 嗯，那现在呢？ B: 现在我在努力学英文，我想成文一名翻译。 ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0708]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0708.html</url>
    <content type="text"><![CDATA[必备句型​ let me explain one more time. 再让我解释一回 I am out of patience. 我忍无可忍了 ​ 场景对话​ A: Please, let me explain one more time. B: Sorry, I am out of patience. A: Why are you so angry? B: I don’t wanna talk to you, I’ve had enough! ​ 参考译文​ A: 求求你，再让我解释一回。 B: 对不起，我忍无可忍了。 A: 你干嘛这么生气？ B: 我不想跟你讲话，我真的受够了。 ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0707]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0707.html</url>
    <content type="text"><![CDATA[必备句型​ Are you satisfied? 你满意吗？ I have to say I am not photogenic at all. 我不得不说，我确实一点儿也不上相啊。 ​ 场景对话​ A: Say cheese. B: Cheese.Okay? A: Yes, have a look. Are you satisfied? B: Oh, I have to say I am not photogentic at al. I just don’t know how to smile. A: Would you like another one? ​ 参考译文​ A: 说“茄子”。 B: 茄子，照好了吗？ A: 是的，来看一眼吧。你满意吗？ B: 哦，我不得不说，我确定一点儿也不上相啊，我就是不知道该怎么微笑。 A: 还想要再照一张吗？ ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0706]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0706.html</url>
    <content type="text"><![CDATA[必备句型​ I don’t like horror movies at all. 我一点儿都不喜欢恐怖片 I am really into his British accent. 我太喜欢他的英国口音了 ​ 场景对话​ A: You like horror movies, don’t you ? B: No, I don’t. I don’t like horror movies at all. I like comedy movies. A: Who is your favorite actor? B: Hugh Grant, I am really into his British accent. 参考译文​ A: 你喜欢恐怖片，是吗？ B: 不，我不喜欢，我一点儿都不喜欢恐怖片，我喜欢喜剧片。 A: 你最喜欢的男演员是谁？ B：休 格兰特。我太喜欢他的英国口音了。 ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0705]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0705.html</url>
    <content type="text"><![CDATA[必备句型​ Are you good at singing ? 你唱歌拿手吗？ I’m a tone-deaf, but I like singing. 我五音不全，但是我喜欢唱歌 ​ 场景对话​ A: Are you good at singing ? B: No, I’m a tone-deaf, but I like singing. A: Okay! Let’s go to karaoke. B: My singing is out of tune. A: Oh, come on. It’s just entertainment. ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0704]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0704.html</url>
    <content type="text"><![CDATA[必备句型​ You are not supposed to smoke here. 你不能在这里吸烟 I am a heavy smoker. 我是个老烟民 ​ 场景对话​ A: Excuse me sir. You are not supposed to smoke here. B: Why not? A: Your seat is in the non-smoking section. So, you can’t smoke here. B: I am a heavy smoker, may I change my seat? ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0703]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0703.html</url>
    <content type="text"><![CDATA[必备句型​ Honesty is very important to me. 诚实对我很重要 The problem is that… 问题是… ​ 场景对话​ A:I don’t like to make friends with people who aren’t honest.Honesty is very important to me. B:I think it’s important to most people. The problem is that you can usually only find out if someone is honest by getting to know them. ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0701]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0701.html</url>
    <content type="text"><![CDATA[必备句型 How come? 为什么？ Don’t judge a book by it’s cover. 不要以貌取人 场景对话​ A:Hey,Look at the man over there,he’s definitely not a good person. B:How come? you don’t even know him. A:I just feel that way. B:Hey!Don’t judeg a book by it’s cover. ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0630]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0630.html</url>
    <content type="text"><![CDATA[必备句型​ I shouldn’t have yelled at you in front of everyone. 我不该在大家面前对你大吼 I don’t know what happened to me. 我不知道我昨天是怎么了 ​ 场景对话​ A:Hey,Bob.I’m so sorry about yesterday.I shouldn’t have yelled at you in front of everyone. B:Don’t worry about it. A:I don’t know what happened to me.I just lost it. B:It’s okay. ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0629]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0629.html</url>
    <content type="text"><![CDATA[必备句型​ You have to finish your dinner before you leave the table. 你离开饭桌之前必须把饭吃完 I’m stuffed. 我吃得太饱了 ​ 场景对话​ A:You have to finish your dinner before you leave the table. B:But,mom.I can’t eat anymore. A:What’s the matter? B:I ate some cookies before we had dinner.I’m stuffed. 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0628]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0628.html</url>
    <content type="text"><![CDATA[必备句型​ You’d better get up or you’ll be late. 你最好起床，否则你要迟到了 Rise and shine,sleepyhead. 贪睡鬼，起床啦 ​ 场景对话​ A:Hey,Bob.Weak up! B:Do I have to get up now? A:You’d better get up or you’ll be late. B:What are you talking about?The alarm hasn’t even gone off yet. A:It went off 30 minutes ago.Rise and shine,sleepyhead. 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0627]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0627.html</url>
    <content type="text"><![CDATA[必备句型​ Can I talk to you for a minute? 我能跟你谈一会儿吗？ It’s out of the question. 不可能 ​ 场景对话​ A:Mom,can I talk to you for a minute? B:Sure,what’s wrong? A:My best friend is going to throw a party tonight,can I stay out all night with my friends? B:No way. A:We’ll be careful. B:It’s out of the question. 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0625]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0625.html</url>
    <content type="text"><![CDATA[必备句型​ I’ve been so stressed these days. 我这几天压力很大 I have no idea what I should major in. 我不知道学什么专业 ​ 场景对话​ A:I’ve been so stressed these days. B:What’s wrong?Are you okay? A:I haven’t decided which college I should go to.I have no idea whta I should major in. B:Don’t worry.You still have time to decide. ## 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0624]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0624.html</url>
    <content type="text"><![CDATA[必备句型​ My back is sore and my meck hurts. 我的背很酸，脖子也疼 I was always absent-minded in the class. 我在课上走神儿了 ​ 场景对话​ A:Finally the class is over. B:Oh,I am so tired.My back is sore and my neck hurts. A:That’s normal.You have been sitting for three hours,with your attention highly concontrated. B:That’s not true.I was always absent-minded in the class. 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0623]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0623.html</url>
    <content type="text"><![CDATA[必备句型​ Why are you asking me this strange question? 你干嘛问我这么奇怪的问题？ I think IQ matters more. 我觉得智商更重要一点 #### 场景对话​ A:Hey,Bob,In your opinion,which one is more important,IQ or EQ? B:Why are you asking me this strange question? A:Just asking. B:Well,I Think IQ matters more,but it won’t work without EQ. ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0622]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-062.html</url>
    <content type="text"><![CDATA[必备句型​ I really wish I hadn’t done it. 我真希望我没那么做 What on earth are you talking about? 你究竟在说什么？ ​ 场景对话​ A:Hey,Bob.You look unhappy.What’s wrong? B:Oh,Alex,I mad e a big mistake A:What happened? B:I really wish I hadn’t done it. A:What on earth are you talking about? B:I got caught cheating.I feel so ashamed.The teacher saw me and told me I failed. ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语跟读计划0621]]></title>
    <url>%2FEnglish%2Fenglish-reading-plan-0621.html</url>
    <content type="text"><![CDATA[必备句型​ Why on earth are you waning to learn a new language now? 你到底为什么学习一门新语言？ It’s never too late to learn. 活到老，学到老。 ​ 场景对话​ A:Hey,What are you up to? B:I’m learning English. A:Why on earth are you wanting to learn a new language now? B:It’s never too late to learn,you never know when these things will come into use. 黑体表示连读 ​斜体表示弱读 Why on earth did you do?你到底做了什么？ ​ 本文结束，感谢阅读 参考资料LOKO乐口英语微信公众号: lokoenglish]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
</search>
